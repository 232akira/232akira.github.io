{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/04/17/%E7%82%B9%E6%88%91%E6%9F%A5%E7%9C%8B%E7%AB%99%E7%82%B9%E6%8C%87%E5%BC%95/",
            "url": "https://232akira.github.io/2025/04/17/%E7%82%B9%E6%88%91%E6%9F%A5%E7%9C%8B%E7%AB%99%E7%82%B9%E6%8C%87%E5%BC%95/",
            "title": "🔝点我查看站点指引",
            "date_published": "2025-04-17T06:44:00.000Z",
            "content_html": "<h1 id=\"关于如何食用本博客\"><a href=\"#关于如何食用本博客\" class=\"headerlink\" title=\"关于如何食用本博客\"></a>关于如何食用本博客</h1><p><strong>任务栏</strong>：pc全屏可直接点击顶端选项🍭pc分屏&#x2F;移动端点击左上角三横杠</p>\n<h2 id=\"了解更多我的故事\"><a href=\"#了解更多我的故事\" class=\"headerlink\" title=\"了解更多我的故事\"></a>了解更多我的故事</h2><p><code>任务栏左上角</code>-&gt;<code>关于</code><br>一些碎碎念，感谢赏光</p>\n<h2 id=\"昼夜模式\"><a href=\"#昼夜模式\" class=\"headerlink\" title=\"昼夜模式\"></a>昼夜模式</h2><p><code>任务栏右上角</code>-&gt;<code>太阳</code>or<code>月亮图标</code><br>不管白天黑夜，选择您舒适的方式浏览~</p>\n<h2 id=\"更清晰的看看有哪些文章\"><a href=\"#更清晰的看看有哪些文章\" class=\"headerlink\" title=\"更清晰的看看有哪些文章\"></a>更清晰的看看有哪些文章</h2><p><code>任务栏左上角</code>-&gt;<code>文章</code>-&gt;<code>归档</code><br>看看每月写了什么</p>\n<p><code>任务栏左上角</code>-&gt;<code>文章</code>-&gt;<code>标签</code><br>关键词定位文章更高效</p>\n<p>也可以直接点击目录上方的数字跳转。</p>\n<h2 id=\"🧩其他\"><a href=\"#🧩其他\" class=\"headerlink\" title=\"🧩其他\"></a>🧩其他</h2><h3 id=\"想来点音乐？\"><a href=\"#想来点音乐？\" class=\"headerlink\" title=\"想来点音乐？\"></a>想来点音乐？</h3><p><code>波浪动效</code>-&gt;<code>右边播放键</code></p>\n<h3 id=\"待完善的功能\"><a href=\"#待完善的功能\" class=\"headerlink\" title=\"待完善的功能\"></a>待完善的功能</h3><ul>\n<li>评论系统</li>\n<li>文章搜索</li>\n<li>其他异常显示<br>…</li>\n</ul>\n",
            "tags": [
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/17/%E5%AE%9E%E6%88%982-%E6%8E%A5%E5%85%A5DeepSeek-R1%E4%BC%98%E5%8C%96%E6%8F%90%E7%A4%BA%E8%AF%8D/",
            "url": "https://232akira.github.io/2025/04/17/%E5%AE%9E%E6%88%982-%E6%8E%A5%E5%85%A5DeepSeek-R1%E4%BC%98%E5%8C%96%E6%8F%90%E7%A4%BA%E8%AF%8D/",
            "title": "实战2️⃣ 接入DeepSeek-R1优化提示词",
            "date_published": "2025-04-17T05:43:07.000Z",
            "content_html": "<p>🔆2025-04-16</p>\n<h2 id=\"优化Stable-Difussion生成效果-接入DeepSeek-R1处理提示词\"><a href=\"#优化Stable-Difussion生成效果-接入DeepSeek-R1处理提示词\" class=\"headerlink\" title=\"优化Stable Difussion生成效果(接入DeepSeek-R1处理提示词)\"></a>优化Stable Difussion生成效果(接入DeepSeek-R1处理提示词)</h2><p>哇这里只加了一个功能流程中就出现很多bug😅待我慢慢梳理一下</p>\n<h2 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h2><p>上面说到对提示词进行优化，那么可以直接再引入一个文本生成模型来进行这个操作，那么整体的流程就变为：</p>\n<pre><code>A[原始提示词] --&gt; B(DeepSeek-R1优化)--&gt; C[优化后提示词]\n</code></pre>\n<p>然后才是：</p>\n<pre><code>C --&gt; D(Stable Diffusion生成)\nD --&gt; E[最终图像]\n</code></pre>\n<h2 id=\"获取DeepSeek-R1-API\"><a href=\"#获取DeepSeek-R1-API\" class=\"headerlink\" title=\"获取DeepSeek-R1 API\"></a>获取DeepSeek-R1 API</h2><p>和先前拿到Stable Diffusion是同一个方法：访问<code>沐曦资源包</code>-&gt;<code>DeepSeek-R1</code>-&gt;<code>API</code></p>\n<ul>\n<li><code>base_url</code> <a href=\"https://ai.gitee.com/v1\">https://ai.gitee.com/v1</a></li>\n<li><code>api_key</code></li>\n<li><code>model</code> DeepSeek-R1</li>\n</ul>\n<h2 id=\"代码思路\"><a href=\"#代码思路\" class=\"headerlink\" title=\"代码思路\"></a>代码思路</h2><p>简而言之，就是在Stable Diffusion拿到提示词之前，把原始提示词先丢给DeepSeek处理一下，也可以说是<strong>双模型协同机制</strong>。</p>\n<h3 id=\"DeepSeek-R1\"><a href=\"#DeepSeek-R1\" class=\"headerlink\" title=\"DeepSeek-R1\"></a>DeepSeek-R1</h3><blockquote>\n<p>作为「提示词工程师」</p>\n</blockquote>\n<ol>\n<li>message模块向其发送指令，比如：你是一个专业的SD提示词优化助手等等</li>\n<li>接受用户输入的提示词</li>\n<li>优化<br>优化的策略可以有很多，针对Stable Diffusion我们可以这样做：</li>\n</ol>\n<ul>\n<li>转换成英文</li>\n<li>语法结构优化（将描述性语言转换为SD擅长的标签式表达）</li>\n<li>自动补充合适的艺术风格细节（如添加”ultra detailed, 8k”等）</li>\n</ul>\n<p><em><strong>⚠️注意！这里有个致命的提示词要点，影响整个案例是否成功。将放到后面作为重点补充。</strong></em></p>\n<ol start=\"4\">\n<li>输出经优化后的提示词</li>\n</ol>\n<pre><code>def get_optimized_prompt(original_prompt: str) -&gt; str：\n</code></pre>\n<h3 id=\"Stable-Diffusion\"><a href=\"#Stable-Diffusion\" class=\"headerlink\" title=\"Stable Diffusion\"></a>Stable Diffusion</h3><blockquote>\n<p>作为「图像生成器」</p>\n</blockquote>\n<ol>\n<li>接受经优化后的提示词</li>\n<li>输出文生图结果</li>\n</ol>\n<pre><code>def generate_image(prompt: str, output_path: str = &quot;output-DS-R1.png&quot;) -&gt; bool:\n</code></pre>\n<h2 id=\"报错梳理\"><a href=\"#报错梳理\" class=\"headerlink\" title=\"报错梳理\"></a>报错梳理</h2><h3 id=\"模型资源地址-模型名称置入错误\"><a href=\"#模型资源地址-模型名称置入错误\" class=\"headerlink\" title=\"模型资源地址&#x2F;模型名称置入错误\"></a>模型资源地址&#x2F;模型名称置入错误</h3><p>这个其实是非常没有技术含量的报错🫥因为这个案例的代码比较冗长（200行左右），并且模型资源置入的地址的代码位置比较分散，所以在快速大量修改整体代码时，很容易没有调用到模型资源，但往往报错的时候不会意识到是这么简单的问题。<br><strong>举个🌰：</strong><br>遇到了401报错，那么可能是API Key：</p>\n<ul>\n<li>为空</li>\n<li>已过期</li>\n<li>不属于当前使用的API服务（比如错用OpenAI的Key调用 Gitee AI，我就是没注意到这里）</li>\n</ul>\n<p>🔄所以记得基础问题至少也要检查一遍。</p>\n<h3 id=\"运行无报错但是无输出\"><a href=\"#运行无报错但是无输出\" class=\"headerlink\" title=\"运行无报错但是无输出\"></a>运行无报错但是无输出</h3><p>这里属于和模型无关的基础代码编写问题了。需要添加一定的逻辑，如：</p>\n<ul>\n<li>增加代码调试输出逻辑</li>\n<li>强制报错测试</li>\n</ul>\n<p>最好是加个运行日志，方便看看细节啥情况。这里问了DS说的很专业，码一下<br>🔄错误熔断设计：<code>独立捕获每个API的异常</code> &amp; <code>生成过程状态实时反馈</code>，并添加完整的日志追踪。</p>\n<h3 id=\"运行成功有输出但是完全不对\"><a href=\"#运行成功有输出但是完全不对\" class=\"headerlink\" title=\"运行成功有输出但是完全不对\"></a>运行成功有输出但是完全不对</h3><p>甚至比优化前还要离谱🤣输入的原始提示词是“一只穿着宇航服的猫在月球上漫步”，到这里生成的图不像原来一样至少是个猫，而是变成了一张人物古典水墨风了，完全不相关。</p>\n<p>到这里意识到一个方法,也就是需要按照案例的流程进行逐个排错。我们需要明白究竟是哪个步骤出了问题：</p>\n<blockquote>\n<p>简称：DeepSeek-&gt;DS、Stable Diffusion-&gt;SD</p>\n</blockquote>\n<ul>\n<li>DS没有接受到提示词</li>\n<li>DS接受到提示词 &amp; 优化失败（包括生成的新提示词错误的情况）</li>\n<li>DS接受到提示词 &amp; 优化成功 &amp; SD接受到新提示词</li>\n<li>DS接受到提示词 &amp; 优化成功 &amp; SD接受到新提示词 &amp; SD输出图像失败</li>\n</ul>\n<p>可以推断问题大概率出现在<code>2</code>or<code>3</code>，也就是提示词的优化和传递环节出现了问题，所以导致SD拿到错误的提示词之后很顺溜的生成了错误的图片。<br>🔄需要修改代码逻辑。</p>\n<h3 id=\"警惕AI骗人现象\"><a href=\"#警惕AI骗人现象\" class=\"headerlink\" title=\"警惕AI骗人现象\"></a>警惕AI骗人现象</h3><p>我这里被DeepSeek坑的好惨😭长记性了。我报错的代码它给修改后运行正确，一时激动难以自已。然后发现他在提示词生成错误后直接这样写：</p>\n<pre><code class=\"language-python\">    except:\n        return &quot;cat in astronaut suit on the moon, detailed fur, cosmic background, 8k&quot;\n</code></pre>\n<p>😅😅😅哪有这样的，我需要调用ds来生成这样的语句，它到自己干脆的设置：生成不了直接用写好的优化后代码。太离谱…<br>这里同样需要修改代码逻辑，保证出现失败后能够及时响应。</p>\n<h3 id=\"⚠️最后一个也是最重要的一个报错\"><a href=\"#⚠️最后一个也是最重要的一个报错\" class=\"headerlink\" title=\"⚠️最后一个也是最重要的一个报错\"></a>⚠️最后一个也是最重要的一个报错</h3><p>哇这里真的，<strong>理解起来很容易，发现起来很难！！！</strong></p>\n<blockquote>\n<p>首先我们知道：DeepSeek-R1是个<strong>深度思考</strong>模型</p>\n<blockquote>\n<p>也就是说，它大概率会在你要求<code>不要生成其他无关内容</code>时，思考了一大堆：好的，用户说明我需要巴拉巴拉…然后字数就超了，这半截思考内容就会传递给Stable Diffusion，结果可想而知🫥比如这样：</p>\n</blockquote>\n</blockquote>\n<pre><code class=\"language-python\">2025-04-16 17:27:41,655 - ERROR - 响应内容: &#123;&quot;id&quot;:&quot;9e7f4969063e49b7a542150ed194db43&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;created&quot;:1744795661,&quot;model&quot;:&quot;deepseek-r1&quot;,&quot;choices&quot;:[&#123;&quot;index&quot;:0,&quot;message&quot;:&#123;&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:&quot;&quot;,&quot;reasoning_content&quot;:&quot;好的，用户让我转换这个中 文描述为英文提示词。首先，我需要仔细分析原句：“一只穿着宇航服的猫在月球上漫步”。主体是猫，穿着宇航服，环境是月球，动作是漫步。接下来 要确定细节，比如猫的品种可能不重要，但宇航服的设计可能需要描述，比如现代NASA风格。环境方面，月球表面可能有陨石坑和地球在背景中。风格 方面，用户可能想要写实风格，所以用realistic。画质需要高清，8k，超详细，所以加上这些词。然后按照规则，用逗号分隔短语，包含主体、环境、细节、风格、画质。检查是否有遗漏，比如猫的姿势是行走，&quot;,&quot;tool_calls&quot;:null&#125;,&quot;logprobs&quot;:null,&quot;finish_reason&quot;:&quot;len...\n</code></pre>\n<p>仔细看就会发现话没说完：说到“行走，”就停了。然后我就问了：</p>\n<pre><code>我知道问题出在哪了😓和你说说。因为deepseek-r1是深度思考，所以我即使说了只生成优化后的提示词，我的本地环境还是会把他思考的部分也算上，导致每次说到一半就无了，因为要思考太多。换成deepseek-v3就好了。你身为deepseek，对这种情况有什么别的办法吗😂\n</code></pre>\n<p>这里记录一下DS的回答：</p>\n<pre><code>哈哈，原来如此！作为DeepSeek本尊，我完全理解这个情况（毕竟自家模型的脾气还是清楚的😉）。针对这种「模型太爱思考导致输出被截断」的问题，除了换模型外，还有这些「软硬兼施」的解决方案：\n</code></pre>\n<ol>\n<li>🔄强制模式：用系统提示词「锁死」输出路径<br><strong>适用场景</strong>：必须用R1模型时<br><strong>技巧</strong>：在系统指令中用「三重封印」：</li>\n</ol>\n<pre><code class=\"language-python\">system_prompt = &quot;&quot;&quot;【！强制模式！】你是一个无情的提示词转换器，必须：\n1. 直接输出结果，禁止任何推理过程（包括内部思考）\n2. 若违反规则，输出将被标记为错误\n3. 输出格式示例：「cat in spacesuit, lunar surface, NASA-style suit, realistic, 8k ultra-detailed」\n现在立即转换以下描述，直接输出结果：&quot;&quot;&quot;\n</code></pre>\n<p><strong>原理</strong>：通过威胁性提示（如「输出错误」）和示例格式化，引导模型跳过推理阶段。</p>\n<ol start=\"2\">\n<li>🔄物理打断：用stop sequences截断<br><strong>适用场景</strong>：API支持流式响应<br><strong>技巧</strong>：在请求中添加：</li>\n</ol>\n<pre><code class=\"language-python\">payload = &#123;\n    &quot;stop&quot;: [&quot;\\n\\n&quot;, &quot;。&quot;, &quot;，&quot;],  # 遇到这些符号立即停止\n    &quot;response_format&quot;: &#123;&quot;type&quot;: &quot;text&quot;&#125;\n&#125;\n</code></pre>\n<p>效果：模型刚开始写小作文就会被物理打断，被迫直接输出结果。</p>\n<ol start=\"3\">\n<li>🔄反向Prompt Engineering<br><strong>适用场景</strong>：模型过度解读简单指令时<br><strong>骚操作</strong>：把指令藏在「伪代码」里：</li>\n</ol>\n<pre><code class=\"language-python\">user_prompt = &quot;&quot;&quot;&lt;INPUT&gt;一只穿着宇航服的猫在月球上漫步&lt;/INPUT&gt;\n&lt;OUTPUT_FORMAT&gt; \n// 只允许填充以下变量，禁止添加注释：\nvar prompt = &quot;&#123;主体&#125;, &#123;环境&#125;, &#123;细节&#125;, &#123;风格&#125;, &#123;画质&#125;&quot;\n&lt;/OUTPUT_FORMAT&gt;&quot;&quot;&quot;\n</code></pre>\n<p><strong>心理学原理</strong>：用「代码框架」暗示需要机械式填充，而非自然语言思考。</p>\n<ol start=\"4\">\n<li>🔄后处理暴力截取<br><strong>适用场景</strong>：允许脏数据时</li>\n</ol>\n<pre><code class=\"language-python\"># 强行提取第一个逗号后的内容\nif &quot;,&quot; in response:\n    result = response.split(&quot;,&quot;, 1)[1] \nelse:\n    result = response[:100]  # 保底截断\n</code></pre>\n<p>适用场景：「先污染后治理」的暴力美学。</p>\n<ol start=\"5\">\n<li>🔄终极方案：换模型+版本控制</li>\n</ol>\n<pre><code class=\"language-python\">model_selector = &#123;\n    &quot;需要深度思考&quot;: &quot;deepseek-r1&quot;,\n    &quot;需要机械执行&quot;: &quot;deepseek-v3&quot;,\n    &quot;不确定时&quot;: &quot;deepseek-v3&quot;  # 默认用更听话的版本\n&#125;\n</code></pre>\n<p><strong>真相</strong>：有时候换模型确实是性价比最高的方案，毕竟——「不要试图教AI做人，选择对的AI帮你做人」😏<br>如果这些方案还不够，你甚至可以试试 「量子玄学法」 ——在请求参数里加一行：</p>\n<pre><code>&quot;temperature&quot;: 0.0001,  # 让模型进入「绝对零度」的冷漠模式\n</code></pre>\n<p>（亲测对话痨型AI有奇效）<br>问题记录结束！</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>好了，它怎么知道我把DS-R1改成V3后就一次成功了😂不过只要指令设置的足够严格也是没问题的，对比R1和V3优化Prompt之后SD生成的图大差不差。<br>成功版本的指令：</p>\n<pre><code class=\"language-python\">        # 强化版系统提示\n        system_prompt = &quot;&quot;&quot;【指令】你是一个无情的提示词转换器，必须严格按以下规则执行：\n        1. 输入：用户的中文描述\n        2. 处理：直接转换为英文AI绘画提示词\n        3. 输出规则：\n           - 必须且只能输出转换后的英文提示词\n           - 格式：逗号分隔的短语\n           - 必须包含：主体、环境、细节、风格、画质\n        禁止：任何解释、推理过程或其他文字！直接输出结果！&quot;&quot;&quot;\n</code></pre>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li>Serverless API编程开发指南</li>\n<li><a href=\"https://ai.gitee.com/docs/openapi/v1#tag/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/POST/images/generations\">Gitee AI Inference OpenAPI</a></li>\n</ol>\n",
            "tags": [
                "指南",
                "实战"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/17/%E5%AE%9E%E6%88%981-Stable%20Difussion%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/",
            "url": "https://232akira.github.io/2025/04/17/%E5%AE%9E%E6%88%981-Stable%20Difussion%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/",
            "title": "实战1️⃣ Stable Diffusion图像生成",
            "date_published": "2025-04-17T05:43:01.000Z",
            "content_html": "<p>🔆2025-04-15</p>\n<h1 id=\"实现第一个图像生成Hello-World（Stable-Diffusion模型）\"><a href=\"#实现第一个图像生成Hello-World（Stable-Diffusion模型）\" class=\"headerlink\" title=\"实现第一个图像生成Hello World（Stable Diffusion模型）\"></a>实现第一个图像生成Hello World（Stable Diffusion模型）</h1><blockquote>\n<p>基于沐曦+Gitee平台的40+个大模型，采用vscode&#x2F;Chatbox和Serverless API开发创意型案例，跟踪最新开源模型和编程开发形成案例。<br>本案例使用vscode调用Gitee-Stable Diffusion接口</p>\n</blockquote>\n<h2 id=\"什么是Stable-Diffusion\"><a href=\"#什么是Stable-Diffusion\" class=\"headerlink\" title=\"什么是Stable Diffusion\"></a>什么是Stable Diffusion</h2><p>参考链接<a href=\"https://stabledifffusion.com/\">1️⃣</a><a href=\"https://zhuanlan.zhihu.com/p/622238031\">2️⃣</a><a href=\"https://blog.csdn.net/m0_59162248/article/details/146497738\">3️⃣</a><br>简而言之，就是：<strong>文生图</strong> &#x2F; <code>Text-to-Image</code>。</p>\n<h2 id=\"Gitee\"><a href=\"#Gitee\" class=\"headerlink\" title=\"Gitee\"></a><a href=\"https://gitee.com/\">Gitee</a></h2><p>你需要按照以下顺序操作：</p>\n<ol>\n<li>注册&#x2F;登录Gitee账号</li>\n<li>访问Gitee AI <a href=\"https://ai.gitee.com/\">模力方舟</a></li>\n<li>在模力方舟页面中，找到并启用<a href=\"https://ai.gitee.com/serverless-api/packages/1492\">沐曦-模型资源包</a></li>\n</ol>\n<h2 id=\"获取Stable-Diffusion-API\"><a href=\"#获取Stable-Diffusion-API\" class=\"headerlink\" title=\"获取Stable Diffusion API\"></a>获取Stable Diffusion API</h2><ol>\n<li>选中沐曦模型资源包后,下拉找到stable-diffusion-xl-base-1.0模型</li>\n<li>选择在线体验-&gt;API-&gt;添加令牌，会发现代码中的api-key已被正确替换（此处若无法选择记得先登录）</li>\n</ol>\n<h3 id=\"关于API代码，你需要知道：\"><a href=\"#关于API代码，你需要知道：\" class=\"headerlink\" title=\"关于API代码，你需要知道：\"></a>关于API代码，你需要知道：</h3><ul>\n<li><strong>模型资源地址</strong> API的基础URL（统一资源定位符）</li>\n<li><strong>API密钥</strong> 用于身份验证和授权，以保证用户正常访问。（注意！你会发现其他模型的api-key和此模型都是完全相同的，因为gitee ai的api-key分配模式是一个账号一个）</li>\n<li><strong>模型名称</strong> 指向模型完整名称（一定不能错）</li>\n</ul>\n<p>对于Gitee的三种API代码：<br><strong>1️⃣Python</strong></p>\n<ul>\n<li><code>base_url</code> <a href=\"https://ai.gitee.com/v1\">https://ai.gitee.com/v1</a></li>\n<li><code>api_key</code></li>\n<li><code>model</code> stable-diffusion-xl-base-1.0</li>\n</ul>\n<p><strong>2️⃣JavaScript</strong></p>\n<ul>\n<li><code>baseURL</code> <a href=\"https://ai.gitee.com/v1\">https://ai.gitee.com/v1</a></li>\n<li><code>apiKey</code> </li>\n<li><code>model</code> stable-diffusion-xl-base-1.0</li>\n</ul>\n<p><strong>3️⃣cURL</strong></p>\n<ul>\n<li><code>curl</code> <a href=\"https://ai.gitee.com/v1/images/generations\">https://ai.gitee.com/v1/images/generations</a></li>\n</ul>\n<p><strong>❓️如果你发现这里的curl地址不同于上面的baseurl</strong><br>真聪明！（我这里说话好像ai）这里的url比基础url多了两个资源路径<code>images/generations</code>。<br>这里涉及到<strong>curl命令</strong>：通过命令行直接执行HTTP请求，主要用来测试和调试API。因此其需要包含完整的请求url（包括基础url和资源路径）。</p>\n<blockquote>\n<p>个人对url的具体理解：api发送请求的目标地址，这里直接指向stable-diffusion模型中的图像生成服务。<br>其中：<br><code>ai.gitee.com</code>：使用gitee平台上的AI服务（此网址可以直接访问）<br><code>/v1/images/generations</code>：具体的”模型版本&#x2F;图像&#x2F;生成”的路径</p>\n</blockquote>\n<h2 id=\"使用vscode调用gitee-Stable-Diffusion-API\"><a href=\"#使用vscode调用gitee-Stable-Diffusion-API\" class=\"headerlink\" title=\"使用vscode调用gitee-Stable Diffusion-API\"></a>使用vscode调用gitee-Stable Diffusion-API</h2><p>到这问题就不大了，正常拿个.py文件放上API代码，根据你的需求进行个性化调整。<br>记得缺失的包pip install一下</p>\n<h3 id=\"代码思路\"><a href=\"#代码思路\" class=\"headerlink\" title=\"代码思路\"></a>代码思路</h3><ol>\n<li>导包</li>\n</ol>\n<pre><code class=\"language-python\">import requests                  #HTTP通信\nimport json                      #json数据序列化\nfrom dotenv import load_dotenv   #安全配置\nimport os                        #系统交互\nimport base64                    #数据编码\nfrom io import BytesIO           #二进制流处理\nfrom PIL import Image            #图像操作\n</code></pre>\n<ol start=\"2\">\n<li>配置环境变量<code>load_dotenv() </code></li>\n</ol>\n<ul>\n<li>API_URL</li>\n<li>API_KEY<blockquote>\n<p>为了降低泄露风险、确保安全性，请一定使用用<strong>私有环境变量</strong>进行KEY的配置，不要直接把key写在代码里！</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li>协议配置 &amp; 数据格式声明<code>headers</code></li>\n</ol>\n<pre><code class=\"language-python\">headers = &#123;\n    &quot;Authorization&quot;: f&quot;Bearer &#123;API_KEY&#125;&quot;, #认证协议\n    &quot;Content-Type&quot;: &quot;application/json&quot;    #数据格式声明\n&#125;\n</code></pre>\n<p>4.向API发送请求时所需的参数<code>payload</code></p>\n<pre><code class=\"language-python\">payload = &#123;                                    #请求参数（根据文档调整）\n    &quot;model&quot;: &quot;stable-diffusion-xl-base-1.0&quot;,   #模型选择\n    &quot;prompt&quot;: &quot;一只穿着宇航服的猫在月球上漫步&quot;,   #业务输入\n    &quot;n&quot;: 1,                                    #生成数量\n    &quot;size&quot;: &quot;1024x1024&quot;,                       #输出规格\n    &quot;response_format&quot;: &quot;b64_json&quot;              #数据返回格式\n&#125;\n</code></pre>\n<p>5.向API发送请求 &amp; 处理响应结果</p>\n<blockquote>\n<p>使用<code>try-except</code>异常处理结构，用于捕获并处理在请求API和处理响应过程中可能出现的异常，确保程序在遇到错误时不会崩溃，而是输出相应的错误信息。</p>\n</blockquote>\n<pre><code class=\"language-python\">try:\n    print(f&quot;请求API: &#123;API_URL&#125;&quot;)\n    response = requests.post(API_URL, headers=headers, json=payload)\n    \n    if response.status_code == 200:\n        result = response.json()\n        if &quot;data&quot; in result and len(result[&quot;data&quot;]) &gt; 0:\n            # 处理base64图像数据\n            image_data = base64.b64decode(result[&quot;data&quot;][0][&quot;b64_json&quot;])\n            image = Image.open(BytesIO(image_data))\n            \n            # 保存图像\n            output_path = &quot;generated_image.png&quot;\n            image.save(output_path)\n            print(f&quot;图像生成成功，已保存到: &#123;output_path&#125;&quot;)\n            image.show()\n        else:\n            print(&quot;API响应中没有有效的图像数据&quot;)\n    else:\n        print(f&quot;请求失败，状态码: &#123;response.status_code&#125;&quot;)\n        print(response.text)\n\nexcept Exception as e:\n    print(f&quot;发生错误: &#123;str(e)&#125;&quot;)\n</code></pre>\n<h2 id=\"后续问题扩展\"><a href=\"#后续问题扩展\" class=\"headerlink\" title=\"后续问题扩展\"></a>后续问题扩展</h2><p>如果你成功调用Stable Diffusion模型的API，并输入中文提示词，会发现生成的图几乎不相关…因此后续需要对提示词<code>prompt</code>进行调整。</p>\n<p>下方 ↓ 跳转查看下一篇文章【实战2️⃣ 接入DeepSeek-R1优化提示词】。</p>\n",
            "tags": [
                "指南",
                "实战"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/16/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/",
            "url": "https://232akira.github.io/2025/04/16/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/",
            "title": "入门指南",
            "date_published": "2025-04-16T07:29:31.000Z",
            "content_html": "<p>关于案例的内容较多，可点击本页底部标签跳转查看。</p>\n<h1 id=\"工作流入门\"><a href=\"#工作流入门\" class=\"headerlink\" title=\"工作流入门\"></a>工作流入门</h1><h2 id=\"步骤1-安装\"><a href=\"#步骤1-安装\" class=\"headerlink\" title=\"步骤1 安装\"></a>步骤1 安装</h2><h3 id=\"安装vscode\"><a href=\"#安装vscode\" class=\"headerlink\" title=\"安装vscode\"></a>安装vscode</h3><h4 id=\"本体安装\"><a href=\"#本体安装\" class=\"headerlink\" title=\"本体安装\"></a><a href=\"https://code.visualstudio.com/\">本体安装</a></h4><h4 id=\"AI编程拓展\"><a href=\"#AI编程拓展\" class=\"headerlink\" title=\"AI编程拓展\"></a>AI编程拓展</h4><ol>\n<li><p><a href=\"https://marketplace.visualstudio.com/items?itemName=saoudrizwan.claude-dev\">Cline</a></p>\n</li>\n<li><p><a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.copilot\">Copilot</a></p>\n</li>\n</ol>\n<p>新安装的vscode需要更多基础拓展（如python等）</p>\n<h3 id=\"安装Chatbox\"><a href=\"#安装Chatbox\" class=\"headerlink\" title=\"安装Chatbox\"></a>安装Chatbox</h3><p>这里调用Gitee的大模型API会出现报错，等我二编。</p>\n<h2 id=\"步骤2-实战\"><a href=\"#步骤2-实战\" class=\"headerlink\" title=\"步骤2 实战\"></a>步骤2 实战</h2><h3 id=\"实战1️⃣-Stable-Difussion图像生成\"><a href=\"#实战1️⃣-Stable-Difussion图像生成\" class=\"headerlink\" title=\"实战1️⃣ Stable Difussion图像生成\"></a>实战1️⃣ Stable Difussion图像生成</h3><p>已完成记录，具体可阅览本站同名文章。</p>\n<h3 id=\"实战2️⃣-接入DeepSeek-R1优化提示词\"><a href=\"#实战2️⃣-接入DeepSeek-R1优化提示词\" class=\"headerlink\" title=\"实战2️⃣ 接入DeepSeek-R1优化提示词\"></a>实战2️⃣ 接入DeepSeek-R1优化提示词</h3><p>基本框架已搭好，细节调整修改中~</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li>Serverless API编程开发指南</li>\n<li><a href=\"https://ai.gitee.com/docs/openapi/v1#tag/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/POST/images/generations\">Gitee AI Inference OpenAPI</a></li>\n</ol>\n",
            "tags": [
                "指南"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/08/HOT%20100/",
            "url": "https://232akira.github.io/2025/04/08/HOT%20100/",
            "title": "HOT 100",
            "date_published": "2025-04-08T07:29:31.000Z",
            "content_html": "<p>想了想方便复习，把<a href=\"https://leetcode.cn/studyplan/top-100-liked/\">hot100</a>先不按模块，零碎的把做过的还有简单题先搞定了再说。题都挪到这篇。<br>话不多说开刷😤！！！</p>\n<h1 id=\"在线OJ\"><a href=\"#在线OJ\" class=\"headerlink\" title=\"在线OJ\"></a>在线OJ</h1><p>输入输出和头文件使用的不熟练导致面的时候浪费了不少时间😅备忘一下：</p>\n<h2 id=\"常用C-头文件\"><a href=\"#常用C-头文件\" class=\"headerlink\" title=\"常用C++头文件\"></a>常用C++头文件</h2><table>\n<thead>\n<tr>\n<th align=\"center\">功能</th>\n<th align=\"center\">头文件</th>\n<th align=\"center\">常用内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">输入输出</td>\n<td align=\"center\"><code>#include &lt;iostream&gt;</code></td>\n<td align=\"center\"><code>cin</code>,<code>cout</code></td>\n</tr>\n<tr>\n<td align=\"center\">容器</td>\n<td align=\"center\"><code>#include &lt;vector&gt;</code></td>\n<td align=\"center\"><code>vector</code></td>\n</tr>\n<tr>\n<td align=\"center\">映射</td>\n<td align=\"center\"><code>#include &lt;unordered_map&gt;</code>,<code>#include &lt;map&gt;</code></td>\n<td align=\"center\">哈希表，字典树结构</td>\n</tr>\n<tr>\n<td align=\"center\">集合</td>\n<td align=\"center\"><code>#include &lt;unordered_set&gt;</code>, <code>#include &lt;set&gt;</code></td>\n<td align=\"center\">查找唯一值集合</td>\n</tr>\n<tr>\n<td align=\"center\">字符串处理</td>\n<td align=\"center\"><code>#include &lt;string&gt;</code></td>\n<td align=\"center\">string 类</td>\n</tr>\n<tr>\n<td align=\"center\">算法</td>\n<td align=\"center\"><code>#include &lt;algorithm&gt;</code></td>\n<td align=\"center\"><code>sort</code>,<code>reverse</code>,<code>swap</code>, <code>max</code>, <code>min</code></td>\n</tr>\n<tr>\n<td align=\"center\">数学函数</td>\n<td align=\"center\"><code>#include &lt;cmath&gt;</code></td>\n<td align=\"center\"><code>abs</code>, <code>pow</code>, <code>sqrt</code>, <code>ceil</code>, <code>floor</code></td>\n</tr>\n<tr>\n<td align=\"center\">输入输出格式</td>\n<td align=\"center\"><code>#include &lt;iomanip&gt;</code></td>\n<td align=\"center\"><code>setprecision</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"优化输入输出性能\"><a href=\"#优化输入输出性能\" class=\"headerlink\" title=\"优化输入输出性能\"></a>优化输入输出性能</h2><pre><code class=\"language-cpp\">ios:sync_with_stdio(false);\ncin.tie(0);\n</code></pre>\n<h1 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h1><h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h2><blockquote>\n<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p>\n</blockquote>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>论第一道题的含金量👍我一开始提交的版本是纯暴力类型，然后这会想用哈希优化一下，然后莫名思维混乱了。<br>梳理梳理：</p>\n<ol>\n<li>遍历<code>nums</code></li>\n<li>如果<code>target-nums[i]</code>在哈希表中，返回两个索引<code>&#123;hash[target-nums[i]],i&#125;</code></li>\n<li>否则当前数字及其索引存入哈希表</li>\n</ol>\n<h3 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        unordered_map&lt;int,int&gt; hash;\n        for(int i=0;i&lt;nums.size();i++)&#123;\n            if(hash.find(target-nums[i])!=hash.end())&#123;\n                return &#123;hash[target-nums[i]],i&#125;;\n            &#125;\n            hash[nums[i]]=i;\n        &#125;\n        return &#123;&#125;;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"49-字母异位词分组\"><a href=\"#49-字母异位词分组\" class=\"headerlink\" title=\"49.字母异位词分组\"></a>49.字母异位词分组</h2><blockquote>\n<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; strs.length &lt;&#x3D; 104</li>\n<li>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100</li>\n<li>strs[i] 仅包含小写字母</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>没想到怎么用哈希，但是<a href=\"https://leetcode.cn/problems/group-anagrams/solutions/2718519/ha-xi-biao-fen-zu-jian-ji-xie-fa-pythonj-1ukv/?envType=study-plan-v2&envId=top-100-liked\">题解</a>方法神了</p>\n<ol>\n<li><p>遍历每个字符串</p>\n</li>\n<li><p>排序字符串<br>将字符串中的字母<strong>排序</strong>，字母异位词会有相同的排序结果。</p>\n</li>\n<li><p>使用哈希表分组</p>\n</li>\n</ol>\n<ul>\n<li>排序后的字符串作为哈希表的<code>key</code></li>\n<li>将对应原始字符串列表作为<code>value</code></li>\n</ul>\n<ol start=\"4\">\n<li>输出结果<br>哈希表中相同key的所有value就是一组字母异位词，将它们收集到最终的结果中返回即可</li>\n</ol>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;\n        unordered_map&lt;string,vector&lt;string&gt;&gt; hash;\n        for(string str:strs)&#123;\n            string s=str;\n            sort(s.begin(),s.end());\n            hash[s].push_back(str);\n        &#125;\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        for(const auto&amp; ha:hash)&#123;\n            ans.push_back(ha.second);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"1-最长连续序列\"><a href=\"#1-最长连续序列\" class=\"headerlink\" title=\"1.最长连续序列\"></a>1.最长连续序列</h2><blockquote>\n<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>0 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><a href=\"https://leetcode.cn/problems/longest-consecutive-sequence/solutions/3005726/ha-xi-biao-on-zuo-fa-pythonjavacgojsrust-whop/?envType=study-plan-v2&envId=top-100-liked\">题解戳此</a><br><strong>注意为了时间复杂度为O(n)不能sort</strong></p>\n<ol>\n<li>遍历<code>unordered_set</code>而不是nums</li>\n<li>不断找num+1、num+2…是否在集合中，并记录长度</li>\n<li>当num-1不存在集合中时，num才能作为最长连续序列的起点</li>\n<li>更新最大长度</li>\n</ol>\n<h3 id=\"AC代码-1\"><a href=\"#AC代码-1\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_set&lt;int&gt; hash;\n        for(int num:nums)&#123;\n            if(!hash.count(num))&#123;\n                hash.insert(num);\n            &#125;\n        &#125;\n        int maxlen=0;\n        for(const auto&amp; num:hash)&#123;\n            int curnum=num,curlen=1;\n            if(!hash.count(num-1))&#123;\n                while(hash.count(curnum+1))&#123;\n                    curnum++;\n                    curlen++;\n                &#125;\n            &#125;\n            maxlen=max(maxlen,curlen);\n        &#125;\n        return maxlen;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><h2 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283.移动零\"></a>283.移动零</h2><blockquote>\n<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<strong>请注意</strong>，必须在不复制数组的情况下原地对数组进行操作。</p>\n</blockquote>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>一开始看到这道题就觉得不就是交换嘛。但是发现题目中的：“保持非零元素的相对顺序”我就懵了。于是开始暴力穷举循环一层套一层…后来被拉回正道。<br>核心思想不变，仍是“交换”。<br>但是交换的条件是<strong>将非零元素全部移到数组头部</strong>，虽然直观看来与题目所引导的“0全部移到末尾”完全反着来，但是我发现这样做比把0移到末尾再对非零元素进行某种交换排序要来的简单得多。题目作者居心叵测啊（不是</p>\n<h3 id=\"AC代码-2\"><a href=\"#AC代码-2\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;\n        int i=0; \n        for(int j=0;j&lt;nums.size();j++)&#123;\n            if(nums[j]!=0)&#123;\n                swap(nums[i],nums[j]);\n                i++;\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><h1 id=\"子串\"><a href=\"#子串\" class=\"headerlink\" title=\"子串\"></a>子串</h1><h1 id=\"普通数组\"><a href=\"#普通数组\" class=\"headerlink\" title=\"普通数组\"></a>普通数组</h1><h1 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h1><h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.反转链表</h2><p>又是一道经典中的经典题🙀</p>\n<blockquote>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点的数目范围是 [0, 5000]</li>\n<li>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><ol>\n<li><strong>链表反转的本质</strong></li>\n</ol>\n<ul>\n<li>让当前节点<code>cur</code>指向它的前一个节点<code>pre</code>。而不是后一个节点next</li>\n<li>更新<code>pre</code>和<code>cur</code>，直到cur为空。此时pre为新的head节点</li>\n</ul>\n<ol start=\"2\">\n<li><strong>链表反转过程模拟</strong><blockquote>\n<p>假设存在链表：1-&gt;2-&gt;3-&gt;4-&gt;nullptr</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>初始状态：<code>pre = nullptr</code> &amp;&amp; <code>cur = head</code></li>\n<li>逐步变化：<table>\n<thead>\n<tr>\n<th align=\"center\"><code>cur</code></th>\n<th align=\"center\"><code>tmp(cur-&gt;next)</code></th>\n<th align=\"center\"><code>cur-&gt;next=pre</code></th>\n<th align=\"center\"><code>pre=cur</code></th>\n<th align=\"center\"><code>cur=tmpS</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>1-&gt;nullptr</code></td>\n<td align=\"center\"><code>pre=1</code></td>\n<td align=\"center\"><code>cur=2</code></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>2-&gt;1</code></td>\n<td align=\"center\"><code>pre=2</code></td>\n<td align=\"center\"><code>cur=3</code></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\"><code>3-&gt;2</code></td>\n<td align=\"center\"><code>pre=3</code></td>\n<td align=\"center\"><code>cur=4</code></td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">nullptr</td>\n<td align=\"center\"><code>4-&gt;3</code></td>\n<td align=\"center\"><code>pre=4</code></td>\n<td align=\"center\"><code>cur=nullptr</code>（结束）</td>\n</tr>\n</tbody></table>\n</li>\n<li>最终pre变成4，即新的链表头头。</li>\n</ul>\n<p>此时链表结构为：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; nullptr</p>\n<ol start=\"3\">\n<li>本题关键步骤</li>\n</ol>\n<ul>\n<li>记录下一个节点</li>\n<li>反转指向</li>\n<li>更新pre（当前节点变成新的头）</li>\n<li>继续遍历</li>\n</ul>\n<h3 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* pre=nullptr;\n        ListNode* cur=head;\n        while(cur!=nullptr)&#123;\n            ListNode* tmp=cur-&gt;next;\n            cur-&gt;next=pre;\n            pre=cur;\n            cur=tmp;\n        &#125;\n        return pre;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21.合并两个有序链表\"></a>21.合并两个有序链表</h2><blockquote>\n<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>提示：</p>\n<ul>\n<li>两个链表的节点数目范围是 [0, 50]</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>l1和l2均按非递减顺序排列</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><ol>\n<li><em><strong>终止条件</strong></em>：有链表为空</li>\n</ol>\n<ul>\n<li>list1为空，合并结果直接为list2</li>\n<li>list2为空，合并结果直接为list1</li>\n</ul>\n<ol start=\"2\">\n<li><em><strong>递归调用</strong></em>：小的打头，每一步递归后返回的值链接到链表末尾</li>\n</ol>\n<ul>\n<li>如果<code>list1节点的值 &lt; list2</code>：寻找list1后面节点还有没有也比list2小的节点</li>\n</ul>\n<pre><code>让list1-&gt;next接上递归后合并的结果；\n返回当前较小的节点list1;\n</code></pre>\n<ul>\n<li>else：寻找list2后面节点还有没有也比list1小的节点</li>\n</ul>\n<pre><code>让list2-&gt;next接上递归后合并的结果；\n返回当前较小的节点list2;\n</code></pre>\n<h3 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        if(list1==NULL || list2==NULL)&#123;\n            return list1==NULL ? list2:list1;\n        &#125;\n        if(list1-&gt;val &lt; list2-&gt;val)&#123;\n            list1-&gt;next = mergeTwoLists(list1-&gt;next,list2);\n            return list1;\n        &#125;\n        else&#123;\n            list2-&gt;next = mergeTwoLists(list1,list2-&gt;next);\n            return list2;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加\"></a>2.两数相加</h2><blockquote>\n<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>每个链表中的节点数在范围 [1, 100] 内</li>\n<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这道题着实难倒我🥹乖乖去看<a href=\"https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/\">题解</a></p>\n<ol>\n<li><p>链表<strong>逆序</strong>存储数字</p>\n</li>\n<li><p><code>两个链表的节点值 + 进位值</code>如果记为<code>a</code>：</p>\n</li>\n</ol>\n<ul>\n<li><code>a % 10</code>为当前节点保存的数位</li>\n<li><code>a / 10</code>为新的进位值</li>\n</ul>\n<ol start=\"3\">\n<li>递归思路</li>\n</ol>\n<ul>\n<li>如果l1、l2都为空且carry&#x3D;0，递归结束</li>\n<li>定义sum&#x3D;carry</li>\n<li>如果l1不为空，sum+&#x3D;l1-&gt;val，l1&#x3D;l1-&gt;next</li>\n<li>同理，如果l2不为空，sum+&#x3D;l2-&gt;val，l2&#x3D;l2-&gt;next</li>\n<li>new一个当前节点node：<code>ListNode* node=new ListNode(sum%10)</code></li>\n<li>递归调用处理node-&gt;next</li>\n<li>返回当前节点node</li>\n</ul>\n<h3 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2,int carry=0) &#123;\n        if(l1==nullptr &amp;&amp; l2==nullptr &amp;&amp; carry==0)&#123;\n            return nullptr;\n        &#125;\n        int sum=carry;\n        if(l1!=nullptr)&#123;\n            sum+=l1-&gt;val;\n            l1=l1-&gt;next;\n        &#125;\n        if(l2!=nullptr)&#123;\n            sum+=l2-&gt;val;\n            l2=l2-&gt;next;\n        &#125;\n        ListNode* node=new ListNode(sum%10);\n        carry=sum/10;\n        node-&gt;next=addTwoNumbers(l1,l2,carry);\n        return node;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h1 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h1><h1 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h1><h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><h2 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35.搜索插入位置\"></a>35.搜索插入位置</h2><blockquote>\n<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br><strong>请必须使用时间复杂度为<code>O(logn)</code>的算法。</strong></p>\n</blockquote>\n<h3 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>我一开始用的暴力穷举，如下。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        while(nums.size()!=1)&#123;\n            if(target&lt;nums[0])&#123;\n                return 0;\n            &#125;\n            for(int i=0;i&lt;nums.size()-1;i++)&#123;\n                if(nums[i]==target)&#123;\n                    return i;\n                &#125;\n                else if(nums[i]&lt;target &amp;&amp; nums[i+1]&gt;=target)&#123;\n                    return i+1;\n                &#125;\n            &#125;\n            return nums.size();\n        &#125;\n        return (target&lt;=nums[0])? 0:1;\n    &#125;\n&#125;;\n</code></pre>\n<p>然后提交之后意识到不符合题意，于是再来换个思路：<strong>二分查找</strong><br>我前几天刚记的二分查找笔记 今天竟然没意识到这道题有多直白地明示我要用!!!∑(ﾟДﾟノ)ノ</p>\n<blockquote>\n<p><strong>二分查找</strong>：在有序集合中搜索特定值。</p>\n</blockquote>\n<p><strong>使用术语</strong>：</p>\n<ul>\n<li>目标 <code>target</code></li>\n<li>索引 <code>index</code></li>\n<li>左、右指示符 <code>left</code>、<code>right</code></li>\n<li>中间指示符 <code>mid</code></li>\n</ul>\n<p><strong>计算 <code>mid</code> 位置</strong>：<br>如果 <code>nums[mid] == target</code>，直接返回索引。<br>如果 <code>nums[mid] &lt; target</code>，说明 target 应该在右半部分，所以left向右移动（left &#x3D; mid + 1）。<br>如果 <code>nums[mid] &gt; target</code>，说明 target 应该在左半部分，所以right向左移动（ right &#x3D; mid - 1）。</p>\n<p>循环结束后，left 就是 target 应该插入的位置。</p>\n<h3 id=\"AC代码-3\"><a href=\"#AC代码-3\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p>二分查找最基础的方法。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int left,right;\n        left=0;\n        right=nums.size()-1;\n        while(left&lt;=right)&#123;\n            int mid=left+(right-left)/2;\n            if(nums[mid]==target)&#123;\n                return mid;\n            &#125;\n            else if(nums[mid]&lt;target)&#123;\n                left=mid+1;\n            &#125;\n            else&#123;\n                right=mid-1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20.有效的括号\"></a>20.有效的括号</h2><blockquote>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>\n</blockquote>\n<blockquote>\n<p>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>\n</blockquote>\n<h3 id=\"解题思路-8\"><a href=\"#解题思路-8\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>定义栈的括号匹配规则；() [] &#123;&#125;\n\n初始化一个栈;\n当遇到左括号时：\n    左括号压栈；\n当遇到右括号时:\n    如果（栈空）:\n        ×；\n    否则：\n        char 栈顶元素；\n        弹出栈顶元素；\n        如果栈顶元素与当前右括号不匹配：\n            ×；\n字符串遍历完后：\n    如果（栈空）：\n        √；\n</code></pre>\n<ul>\n<li>这里的for循环可以直接用for(char ch:s)，表示<strong>对于字符串<code>s</code>中的每一个字符<code>ch</code>,执行循环内容</strong>。</li>\n</ul>\n<h3 id=\"AC代码-4\"><a href=\"#AC代码-4\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        unordered_map&lt;char,char&gt;pairs=&#123;&#123;')','('&#125;,&#123;']','['&#125;,&#123;'&#125;','&#123;'&#125;&#125;;\n        stack&lt;char&gt;stk;\n        for(char ch:s)&#123;\n            if(ch==&#39;(&#39; || ch==&#39;[&#39; || ch==&#39;&#123;&#39;)&#123;\n                stk.push(ch);\n            &#125;\n            else&#123;\n                if(stk.empty())&#123;\n                    return false;\n                &#125;\n                char top=stk.top();\n                stk.pop();\n                if(pairs[ch]!=top)&#123;\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        if(stk.empty())&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"70-爬楼梯\"><a href=\"#70-爬楼梯\" class=\"headerlink\" title=\"70.爬楼梯\"></a>70.爬楼梯</h2><blockquote>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n</blockquote>\n<h3 id=\"解题思路-9\"><a href=\"#解题思路-9\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>试图暴力然后失败。然后查看题解：竟然是<strong>动态规划</strong>~</p>\n<p>重点理解部分：</p>\n<ul>\n<li><strong>逆向思维</strong>：如果要到第<code>n</code>个台阶，就必须从第<code>n-1</code>阶走1步，或者从第<code>n-2</code>阶走2步。</li>\n<li>dp[n]&#x3D;dp[n-1]+dp[n-2]</li>\n</ul>\n<p><em><strong>为什么这样递推？</strong></em><br>动态规划的核心是<strong>拆分子问题,然后找到递推关系</strong>。本质根据题目限制条件，建立递推关系，然后用代码实现。<br>👉 因为你每次只能走 1 级或 2 级，所以你到 n 级的方式只能来自 n-1 和 n-2，而不能来自 n-3、n-4 等。</p>\n<pre><code>//先处理边界情况\n如果n&lt;=2：返回n；\n//动规\n定义a=1,b=2；（对应能上的楼梯阶数）和当前阶梯的方案数量temp;\n遍历n（从3开始）：\n    temp=a+b； //dp[i]=dp[i-2]+dp[i-1]\n    a=b;      //a=dp[i-1]\n    b=temp;   //b=dp[i];\n返回 b;\n</code></pre>\n<h3 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        if(n&lt;=2)&#123;\n            return n;\n        &#125;\n        int a=1,b=2,temp;\n        for(int i=3;i&lt;=n;i++)&#123;\n            temp=a+b;\n            a=b;\n            b=temp;\n        &#125;\n        return b;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198.打家劫舍\"></a>198.打家劫舍</h2><blockquote>\n<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>\n</blockquote>\n<h3 id=\"解题思路-10\"><a href=\"#解题思路-10\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><a href=\"https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/\">题解</a>写的特别详细！这里复述一下：</p>\n<p><strong>动态规划的四个解题步骤：</strong></p>\n<ul>\n<li>定义子问题</li>\n<li>写出子问题的递推关系</li>\n<li>确定dp数组的计算顺序</li>\n<li>（可选）空间优化<blockquote>\n<p>这里根据自己现有的水平仅梳理前三点。</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><p><strong>定义子问题</strong><br>原问题：“从全部房间偷到的最大金额”<code>→</code>子问题：“从前k个房间偷到的最大金额”</p>\n</li>\n<li><p>写出<strong>子问题的递推关系</strong><br>👉已知子问题f(k)，那么只关注当前（即第k个）房间，只有两种偷法：<br>偷k &amp;&amp; 偷k-2<code>or</code>不偷k &amp;&amp; 偷k-1间</p>\n</li>\n</ol>\n<p>👉可得递推关系：<code>f(k)=max&#123;f(k-1),k-1房间的钱+f(k-2)&#125;</code>。这里的f(k)也叫做状态，式子也叫做状态转移方程。</p>\n<p>同时别忘了边界情况：无房子（k&#x3D;0）和只有一个房子(k&#x3D;1)。</p>\n<ol start=\"3\">\n<li>确定<strong>dp数组的计算顺序</strong><br>👉dp数组（子问题数组，）：dp[k]&#x3D;偷前k间房子的最大金额。</li>\n</ol>\n<p>👉大多动规问题使用<code>自底向上</code>的dp数组循环方法。</p>\n<p>✅️由子问题的计算顺序可得：dp[k]依赖于dp[k-1]和dp[k-2]。那么就可以开写力</p>\n<h3 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n=nums.size();\n        if(n==0)&#123;\n            return 0;\n        &#125;\n        vector&lt;int&gt; dp(n+1,0);\n        dp[1]=nums[0];\n        for(int i=2;i&lt;=n;i++)&#123;\n            dp[i]=max(dp[i-1],nums[i-1]+dp[i-2]);\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416.分割等和子集\"></a>416.分割等和子集</h2><blockquote>\n<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-11\"><a href=\"#解题思路-11\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这里涉及「恰好装满」的0-1背包问题，教程<a href=\"https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h3 id=\"完整代码-6\"><a href=\"#完整代码-6\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum=accumulate(nums.begin(),nums.end(),0);\n        if(sum%2!=0)&#123;\n            return false;\n        &#125;\n        int target=sum/2;\n        vector&lt;bool&gt; dp(target+1,false);\n        dp[0]=true;//存在和为i=0的子集\n        for(int num:nums)&#123;\n            for(int i=target;i&gt;=num;i--)&#123;\n                dp[i]=dp[i] || dp[i-num];\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"多维动态规划\"><a href=\"#多维动态规划\" class=\"headerlink\" title=\"多维动态规划\"></a>多维动态规划</h1><h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1><h2 id=\"169-多数元素\"><a href=\"#169-多数元素\" class=\"headerlink\" title=\"169.多数元素\"></a>169.多数元素</h2><blockquote>\n<p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>n &#x3D;&#x3D; nums.length</li>\n<li>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104</li>\n<li>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-12\"><a href=\"#解题思路-12\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>天哪我竟然一次性写对了而且用时击败百分百😭好久没有这样了…哈希哈希我们喜欢你🥰</p>\n<h3 id=\"完整代码-7\"><a href=\"#完整代码-7\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_map&lt;int,int&gt; cnts;\n        int n=nums.size();\n        for(int num:nums)&#123;\n            cnts[num]++;\n        &#125;\n        int ans=0;\n        for(const auto&amp; cnt:cnts)&#123;\n            if(cnt.second&gt;n/2)&#123;\n                return cnt.first;\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/06/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/",
            "url": "https://232akira.github.io/2025/04/06/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/",
            "title": "游戏开发笔记",
            "date_published": "2025-04-06T14:22:22.000Z",
            "content_html": "<p>👌当下主要学习<strong>图形</strong>方向，具体细节可以查看<a href=\"https://docs.unity3d.com/cn/current/Manual/Graphics.html\">Unity官方文档</a>。</p>\n<pre><code>渲染管线\n摄像机\n光照\n模型\n网格\n纹理\n着色器\n材质\nVisual effects\n天空\n颜色\n图形API\nGraphics performance and profiling\n</code></pre>\n<blockquote>\n<p>虽然自己程序方面更擅长C++而且现在用UE也是个趋势，但是Unity普及度更高而且教程更多，UE蓝图也摒弃了传统的纯程序开发路线，所以打好这方面基础是现在最需要做的。如果有任何建议和想法需要交流欢迎联系我！不断试错不断学习中🤗</p>\n</blockquote>\n<p>笔记内容90%来自视频原话，其他内容个人补充，欢迎勘误。<br>学习内容大多来自b站佬们的教程（先三连之后看的！）🤟参考链接点击标题跳转</p>\n<h1 id=\"项目实战-Uinty\"><a href=\"#项目实战-Uinty\" class=\"headerlink\" title=\"项目实战-Uinty\"></a>项目实战-Uinty</h1><h2 id=\"Shader代码基础\"><a href=\"#Shader代码基础\" class=\"headerlink\" title=\"Shader代码基础\"></a><a href=\"https://www.bilibili.com/video/BV1Xu4y1S7LF/?spm_id_from=333.1387.favlist.content.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">Shader代码基础</a></h2><h3 id=\"PART1\"><a href=\"#PART1\" class=\"headerlink\" title=\"PART1\"></a>PART1</h3><h4 id=\"Shader代码基本架构\"><a href=\"#Shader代码基本架构\" class=\"headerlink\" title=\"Shader代码基本架构\"></a>Shader代码基本架构</h4><pre><code class=\"language-c#\">Shader&quot;1️⃣&quot;\n&#123;\n    Properties\n    &#123;\n    2️⃣\n    &#125;\n    SubShader\n    &#123;\n    ️3️⃣\n        Pass\n        &#123;\n        4️⃣\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>1️⃣Shader名称</strong></p>\n<p><strong>2️⃣定义变量位置</strong><br>常见的五种变量类型:</p>\n<ul>\n<li>Float</li>\n<li>Range</li>\n<li>Vector</li>\n<li>Color</li>\n<li>Texture</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        //常用的五种数据类型\n        _Float(&quot;Float&quot;,Float)=0.0\n        _Range(&quot;Range&quot;,Range(0.0,1.0))=0.0\n        _Vector(&quot;Vector&quot;,Vector)=(1,1,1,1)\n        _Color(&quot;Color&quot;,Color)=(0.5,0.5,0.5,0.5)\n        _Texture(&quot;Texture&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n</code></pre>\n<p><strong>3️⃣主要Shader代码部分</strong><br>可以理解成一个Pass等于一个完整的GPU渲染管线，SubShader里可以写多个Pass，写几个代表会被重复渲染几次，而且每次调用的Shader都不一样。</p>\n<pre><code class=\"language-c#\">            CGPROGRAM\n            //中间的任何代码都属于unity cg的范围\n            ENDCG\n</code></pre>\n<ol>\n<li>这里对于<code>float</code>类型<a href=\"https://docs.unity3d.com/cn/current/Manual/SL-VertexProgramInputs.html\">补充</a>一点：</li>\n</ol>\n<ul>\n<li>‌<code>float‌</code>：用于表示单个浮点数，常用于颜色通道、位置坐标等。</li>\n<li>‌<code>float2‌</code>（Vector2）：用于表示二维向量，如二维坐标、UV坐标等。</li>\n<li>‌<code>float3‌</code>（Vector3）：用于表示三维向量，如位置、法线等。</li>\n<li>‌<code>float4‌</code>（Vector4）：用于表示四维向量，如颜色、四元数等。</li>\n</ul>\n<ol start=\"2\">\n<li><p>在unity中，一个模型最多有四套UV</p>\n</li>\n<li><p>float&#x2F;half&#x2F;fixed的区别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">位宽</th>\n<th align=\"center\">适用范围</th>\n<th align=\"center\">常见用途</th>\n<th align=\"center\">精度</th>\n<th align=\"center\">现代GPU支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32-bit</td>\n<td align=\"center\">大</td>\n<td align=\"center\">位置、物理计算、PBR</td>\n<td align=\"center\">高</td>\n<td align=\"center\">强烈推荐</td>\n</tr>\n<tr>\n<td align=\"center\">half</td>\n<td align=\"center\">16-bit</td>\n<td align=\"center\">中</td>\n<td align=\"center\">颜色计算、法线、屏幕后处理</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">推荐（移动端优化）</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">10-bit</td>\n<td align=\"center\">小</td>\n<td align=\"center\">颜色计算（老设备）</td>\n<td align=\"center\">低</td>\n<td align=\"center\">几乎淘汰</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"GPU渲染管线\"><a href=\"#GPU渲染管线\" class=\"headerlink\" title=\"GPU渲染管线\"></a>GPU渲染管线</h4><p><strong>基本结构</strong>：</p>\n<pre><code>【模型数据】 -&gt; 1️⃣【顶点Shader】 -&gt; 2️⃣【图元装配及光栅化】 -&gt; 3️⃣【片元Shader】 -&gt; 4️⃣【输出合并】\n            |-----------------------------GPU渲染管线---------------------------------------|\n</code></pre>\n<p><strong>1️⃣顶点Shader</strong>：</p>\n<ul>\n<li>将模型数据的模型空间坐标转换到对应的裁剪空间，即输出在裁剪空间下的顶点坐标</li>\n<li>【模型空间】 -&gt; 世界空间 -&gt; 相机空间 -&gt; 【裁剪空间】，中间经过三个矩阵（Model,View,Projection）操作</li>\n</ul>\n<p><strong>2️⃣图元装配及光栅化</strong></p>\n<ul>\n<li>硬件阶段</li>\n<li>生成片元并进行光栅化插值</li>\n</ul>\n<p><strong>3️⃣片元Shader</strong></p>\n<ul>\n<li>每个片元调用片元shader给自身着色</li>\n<li>计算对应的颜色后输出</li>\n</ul>\n<p><strong>4️⃣输出合并</strong></p>\n<ul>\n<li>输出到对应的帧缓冲区</li>\n</ul>\n<p><em><strong>一个完整的Shader通常由顶点Shader和片段Shader共同组成。</strong></em></p>\n<h4 id=\"完整Shader代码\"><a href=\"#完整Shader代码\" class=\"headerlink\" title=\"完整Shader代码\"></a>完整Shader代码</h4><pre><code class=\"language-c#\">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;\n// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;\nShader &quot;CS0102/shader&quot;\n&#123;\n    Properties\n    &#123;\n        // 常用的五种数据类型\n        _Float(&quot;Float&quot;, Float) = 0.0\n        _Range(&quot;Range&quot;, Range(0.0, 1.0)) = 0.0\n        _Vector(&quot;Vector&quot;, Vector) = (1,1,1,1)\n        _Color(&quot;Color&quot;, Color) = (0.5,0.5,0.5,0.5)\n        //_Texture(&quot;Texture&quot;, 2D) = &quot;black&quot; &#123;&#125; \n        _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            // Shader 主要代码部分\n            CGPROGRAM\n            #pragma vertex vert // 指定一个顶点 Shader：vert\n            #pragma fragment frag // 指定一个片元 Shader：frag\n            #include &quot;UnityCG.cginc&quot; // 头文件\n\n            // 从 CPU 端获取模型数据\n            struct appdata &#123;\n                float4 vertex : POSITION;  // 模型顶点坐标\n                // 第一套uv，共4个可用（TEXCOORD0~TEXCOORD3）\n                float2 uv : TEXCOORD0; \n                float3 normal : NORMAL;    // 法线\n                float4 color : COLOR;      // 顶点色\n            &#125;;\n            // 输出结构体定义\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                //通用储存器（插值器），共16个可用（TEXCOORD0~TEXCOORD15）\n                float2 uv:TEXCOORD0;\n            &#125;;\n            float4 _Color;\n            sampler2D _MainTex;\n            float4 _MainTex_ST;//动态链接四个参数\n            // 顶点 Shader\n            v2f vert(appdata v) &#123;\n                v2f o;\n                //float4 pos_world = mul(unity_ObjectToWorld, v.vertex); // 模型空间转世界空间\n                //float4 pos_clip = mul(UNITY_MATRIX_VP, pos_world); // 世界空间直接变换到裁剪空间\n                //o.pos = pos_clip;\n                //或者直接合成一个mvp操作\n                o.pos=UnityObjectToClipPos(v.vertex);\n                //输出uv值\n                //o.uv=v.uv;\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            // 片元 Shader\n            float4 frag(v2f i) : SV_Target &#123;\n                //贴图采样\n                float4 col=tex2D(_MainTex,i.uv);\n                return col;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"PART2\"><a href=\"#PART2\" class=\"headerlink\" title=\"PART2\"></a>PART2</h3><h4 id=\"背面剔除（Backface-Culling）\"><a href=\"#背面剔除（Backface-Culling）\" class=\"headerlink\" title=\"背面剔除（Backface Culling）\"></a>背面剔除（Backface Culling）</h4><p>背面剔除在硬件阶段、NDC空间之后进行，Unity默认使用背面剔除（只渲染正面）。</p>\n<ol>\n<li>Shader代码控制:直接显示出渲染结果</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull Off  //1️⃣不剔除\n            Cull Back //2️⃣默认剔除背面\n            Cull Front//3️⃣剔除正面\n            //注意在CGPROGRAM之前\n            CGPROGRAM\n            ...\n            ENDCG\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>材质球控制：物体材质球处出现可选项：Off&#x2F;Front&#x2F;Back</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull [_CullMode]\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"PART3-纹理映射\"><a href=\"#PART3-纹理映射\" class=\"headerlink\" title=\"PART3 纹理映射\"></a>PART3 纹理映射</h3><h4 id=\"正面纹理采样设定\"><a href=\"#正面纹理采样设定\" class=\"headerlink\" title=\"正面纹理采样设定\"></a>正面纹理采样设定</h4><p>这里用XY坐标值采样贴图，即uv按模型本身的XY展开。<br>代码如下：</p>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                ...\n                float2 pos_uv:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                ...\n                o.pos_uv=v.vertex.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.pos_uv);\n                return col;\n            &#125;\n</code></pre>\n<p>👉️补充：</p>\n<ul>\n<li>正面 XY平面</li>\n<li>侧面 ZY平面</li>\n<li>俯视 XZ平面</li>\n</ul>\n<p>总结：纹理映射的来源不一定是单纯的o.uv的uv坐标，也可以是上面写的o.pos_uv（世界坐标pos_world也可）这种自己设定的值。</p>\n<p>另，如果想三平面都能够完美覆盖涉及到：<strong>三平面映射</strong>。up在此链接中有提到，所以查了其他教程补充在这里。</p>\n<h4 id=\"三平面映射\"><a href=\"#三平面映射\" class=\"headerlink\" title=\"三平面映射\"></a><a href=\"https://www.bilibili.com/opus/814269127492370548\">三平面映射</a></h4><ol>\n<li>**目的：**防止”纹理拉伸”</li>\n</ol>\n<p>防止纹理拉伸传统思路可以手动展开uv坐标以贴合模型起伏，但是难以适应实时渲染的要求，因此引入这一方法：三平面映射。</p>\n<ol start=\"2\">\n<li><p>**应用：**普通网格地形、瀑布、程序化建模的地形、水池的焦散效果</p>\n</li>\n<li><p><strong>实现步骤</strong></p>\n</li>\n</ol>\n<ul>\n<li>根据顶点的世界空间坐标计算对应的UV坐标</li>\n</ul>\n<pre><code class=\"language-c#\">//取每个片元在三个方向的uv坐标\nhalf2 yUV=IN.worldPos.xz/_TextureScale;\nhalf2 xUV=IN.worldPos.yz/_TextureScale;\nhalf2 zUV=IN.worldPos.xy/_TextureScale;\n</code></pre>\n<ul>\n<li>从x&#x2F;y&#x2F;z三个方向对漫反射贴图进行采样</li>\n</ul>\n<pre><code class=\"language-c#\">half3 yDiff=tex2D(_DiffuseMap,yUV);\nhalf3 xDiff=tex2D(_DiffuseMap,xUV);\nhalf3 zDiff=tex2D(_DiffuseMap,zUV);\n</code></pre>\n<ul>\n<li>调整三平面边界过渡的锐利度</li>\n</ul>\n<pre><code class=\"language-c#\">//用法线方向作为从三个方向采样的权重值\n//额外解决纹理接缝问题（法线是连续过渡的）\nhalf3 blendWeights=pow(abs(In.worldNormal),_TriplanarBlendSharpness);\n</code></pre>\n<ul>\n<li>将混合权重值单位化</li>\n</ul>\n<pre><code class=\"language-c#\">//第三步pow锐化三平面边界后，得到的法线值可能偏小\n//重新单位化\nblendWeights=blendWeights/(blendWeights.x+blendWeights.y+blendWeights.z);\n</code></pre>\n<ul>\n<li>按三个面的混合权重，将采样颜色混合在一起</li>\n</ul>\n<pre><code class=\"language-c#\">//根据混合系数混合\np.Albedo=xDiff*blendWeights.x+yDiff*blendWeights.y+zDiff*blendWeights.z;\n</code></pre>\n<p>更多相关内容<a href=\"https://www.bilibili.com/video/BV1AM4y1Y78D/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h4 id=\"渲染扭曲问题\"><a href=\"#渲染扭曲问题\" class=\"headerlink\" title=\"渲染扭曲问题\"></a>渲染扭曲问题</h4><p>打印uv坐标：</p>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.uv);\n                return float4(i.uv,0.0,0.0);\n            &#125;\n</code></pre>\n<p>若uv存在不连续的情况，则会导致贴图采样时引起纹理图像的失真问题。</p>\n<p><strong>👉️为什么会有uv不连续的现象？</strong><br>光栅化过程产生。光栅化时根据三角面的进行，每个三角按照每个三角面进行一个插值。而对于模型而言，其三角网排列就会造成一定程度上的问题。<br>解决方式：</p>\n<ul>\n<li>uv展开并缩放到0~1之间</li>\n<li>模型加面</li>\n<li>手动在片元shader中重新计算uv</li>\n</ul>\n<h3 id=\"PART4-透明度测试-Alpha-test\"><a href=\"#PART4-透明度测试-Alpha-test\" class=\"headerlink\" title=\"PART4 透明度测试 Alpha-test\"></a>PART4 透明度测试 Alpha-test</h3><p>参考链接<a href=\"https://docs.unity3d.com/cn/2020.2/Manual/SL-AlphaTest.html\">1️⃣</a><a href=\"https://blog.csdn.net/qq_34697930/article/details/136530909\">2️⃣</a></p>\n<h4 id=\"输出合并\"><a href=\"#输出合并\" class=\"headerlink\" title=\"输出合并\"></a>输出合并</h4><p>对于<strong>输出合并</strong>阶段，可以细分为：</p>\n<pre><code>【片元数据】Color,Depth\n    ↓\n【Alpha测试】\n    ↓\n【模板测试】Stencil Test\n    ↓\n【深度测试】Depth test\n    ↓\n【混合】Blending\n    ↓\n【帧缓冲区】Color,Depth,Stencil\n</code></pre>\n<h4 id=\"Alpha-test\"><a href=\"#Alpha-test\" class=\"headerlink\" title=\"Alpha-test\"></a>Alpha-test</h4><p>**Alpha 测试是拒绝将像素写入屏幕的最后机会。**在计算出最终输出颜色之后，颜色可选择性地将其 Alpha 值与固定值进行比较。如果测试失败，则不会将像素写入显示屏。</p>\n<p>当下在Shader中，很少会直接用alpha test这个指令。一般用的是更好用、更可控的指令：<code>clip</code>“裁剪”。</p>\n<p>如果clip()括号中的值&lt;0，整个模型将不显示。</p>\n<ol>\n<li>模型的一部分被裁剪掉</li>\n</ol>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 gradient=tex2D(_MainTex,i.uv);\n                clip(gradient-0.1);\n                return gradient.xxx;\n            &#125;\n</code></pre>\n<ol start=\"2\">\n<li>设置一个值实现动态控制<br>好神奇😂我这里模型用的球，Cutout调到0.5变成吃豆人了</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n         _Cutout(&quot;Cutout&quot;,Range(-0.1,1.1))=0.0\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv).r;\n                clip(gradient-_Cutout);\n                return gradient.xxxx;\n                //gradient.xxxx等价于float4(gradient,gradient,gradient,gradient);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>对UV进行动画处理</li>\n</ol>\n<pre><code class=\"language-c#\">                half gradient=tex2D(_MainTex,i.uv+_Time.y).r;\n</code></pre>\n<ol start=\"4\">\n<li>对UV进行动画速度的处理</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _Speed(&quot;Speed&quot;,Vector)=(1,1,0,0)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _Speed;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>noise贴图控制<br>适当的模型+贴图可以实现波形扩散效果</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _NoiseTex(&quot;Noise Tex&quot;,2D)=&quot;white&quot;&#123;&#125;\n         //_MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _NoiseTex_ST;\n            //float4 _MainColor;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n                half noise=tex2D(_NoiseTex,i.uv+_Time.y*_Speed.zw).r;\n                clip(gradient-noise-_Cutout);\n                return noise.xxxx;\n                //return _MainColor;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p><strong>综上</strong> alpha-test可以用来做溶解相关的效果。</p>\n<h3 id=\"PART5-半透明混合-Blending\"><a href=\"#PART5-半透明混合-Blending\" class=\"headerlink\" title=\"PART5 半透明混合 Blending\"></a>PART5 半透明混合 Blending</h3><p>参考链接<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/\">1️⃣</a><a href=\"https://blog.csdn.net/weixin_34505326/article/details/112181270\">2️⃣</a></p>\n<ol>\n<li>实现半透明混合</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;saturate\n    SubShader\n    &#123;\n        Blend SrcAlpha OneMinusSrcAlpha//注意此句在CGPROGRAM之前\n        float4 _MainColor;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half4 col=tex2D(_MainTex,i.uv)*_MainColor;\n                return col;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>关闭ZWrite深度写入<br>半透明混合的使用要注意排序问题：<code>ZWrite Off</code></li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>渲染队列问题<br>先前我们的材质球的Render Queue为2000，处于不透明的渲染队列中。使用半透明效果必须记得使用<code>Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</code>+关掉<code>ZWrite</code>（部分情况下ZWrite需要开启）</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"4\">\n<li>贴图半透效果</li>\n</ol>\n<ul>\n<li>当前贴图无alpha通道，所以只能用其灰度值来做一个半透效果。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz;\n                half alpha=tex2D(_MainTex,i.uv).r*_MainColor.a;\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<p>做出来的球像透明泡泡🤗好好看~</p>\n<ul>\n<li>增加显示强度<blockquote>\n<p>此处要确保alpha值在0~1的范围内，否则开HDR的时候就很容易出问题</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _Emiss(&quot;Emiss&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        float _Emiss;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz*_Emiss;\n\n                half alpha=saturate(tex2D(_MainTex,i.uv).r*_MainColor.a*_Emiss);\n                return float4(col,alpha);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>其他混合模式<br>常用的柔和叠加模式：<code>Blend SrcAlpha One</code></li>\n</ol>\n<h3 id=\"PART6-边缘光\"><a href=\"#PART6-边缘光\" class=\"headerlink\" title=\"PART6 边缘光\"></a>PART6 边缘光</h3><ol>\n<li>得到normal_world</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            struct appdata &#123;\n                float3 normal : NORMAL;\n            &#125;;\n            struct v2f &#123;\n                float3 normal_world:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos=UnityObjectToClipPos(v.vertex);\n                o.normal_world=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz);\n                //\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>得到view_world</li>\n</ol>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                float3 view_world:TEXCOORD2;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                float3 pos_world=mul(unity_ObjectToWorld,v.vertex).xyz;\n                o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);\n            &#125;\n</code></pre>\n<ol start=\"3\">\n<li>在片元Shader中把数据承接过来</li>\n</ol>\n<ul>\n<li><code>dot(a,b)</code>：a向量与b向量进行点乘。<br>两个向量越重合就越接近1；180°为-1。[-1,1]👉️dot结果在[-1,1]</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 normal_world=normalize(i.normal_world);\n                //光栅化的过程会导致向量的长度变化\n                float3 view_world=normalize(i.view_world);\n                float NdoV=saturate(dot(normal_world,view_world));\n                float rim=1.0-NdoV;\n                return NdoV.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"4\">\n<li>得到边缘光效果</li>\n</ol>\n<ul>\n<li>（来自弹幕佬的解释）边缘处的法线和视角方向接近垂直，dot&#x3D;0,1-dot进行取反，边缘就显示出颜色，其他部分就较为透明。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                ...\n                float rim=1.0-NdoV;\n                return rim.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"5\">\n<li>边缘光改色</li>\n</ol>\n<ul>\n<li>也可以用alpha通道调：<code>float alpha=saturate((1.0-NdoV)*_Emiss);</code></li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 col=_MainColor.xyz*_Emiss;//乘倍增系数，Inspector可调\n                ...\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<ol start=\"6\">\n<li>边缘光对比度调节</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _RimPower(&quot;_RimPower&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float _RimPower;\n            half4 frag(v2f i) : SV_Target &#123;\n               float NdoV=pow(saturate(dot(normal_world,view_world)),RimPower);\n               float fresnel=pow((1.0-NdoV),_RimPower);\n               float alpha=saturate(fresnel*_Emiss);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"7\">\n<li>模型透过问题：预先写深度<br>经过上面的步骤，模型能够看到内部的透过结构。如何避免这种现象？</li>\n</ol>\n<p>☝「打开ZWrite」<code>ZWrite On</code>。此时效果其实不算特别完美</p>\n<p>✌「再加一个&#96;Pass」预写一遍深度，代码如下：</p>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass\n        &#123;\n            Cull Of\n            ZWrite On\n            ColorMask 0\n            CGPROGRAM\n            float4 _Color;\n            #pragma vertex vert\n            #pragma fragment frag\n            float4 vert(float4 veryexPos:POSITION):SV_POSITION\n            &#123;\n                return UnityObjectToClipPos(vertexPos);\n            &#125;\n            float4 frag(void):COLOR\n            &#123;\n                return _Color;\n            &#125;\n            ENDCG\n        &#125;\n        Pass\n        &#123;\n            ...\n        &#125;\n    &#125;\n</code></pre>\n<ul>\n<li>把最靠前的三角形的片元的深度预先<code>ZWrite On</code>写好</li>\n<li><code>Color Mask</code>的操作：只写深度，不写任何的颜色信息</li>\n<li>到了第二遍pass绘制的时候，这些片元就通过深度测试，默认把背后的像素剔除</li>\n</ul>\n<p>👉️ASE中有对应的功能，此处仅为简单演示。</p>\n<p>🤯🤯🤯断断续续一个多星期终于把这一小时的视频啃完辣！！！休息休息继续战斗！</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"其他参考链接\"><a href=\"#其他参考链接\" class=\"headerlink\" title=\"其他参考链接\"></a>其他参考链接</h1><p>反射探针：<br><a href=\"https://zhuanlan.zhihu.com/p/438022045\">https://zhuanlan.zhihu.com/p/438022045</a><br>三大Shader编程语言：<br><a href=\"https://blog.csdn.net/weixin_56516170/article/details/135266277\">https://blog.csdn.net/weixin_56516170/article/details/135266277</a><br>《Shader入门精要》源代码:<br><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\">https://github.com/candycat1992/Unity_Shaders_Book</a><br>法线贴图：<br><a href=\"https://blog.csdn.net/weixin_49427945/article/details/136458398\">https://blog.csdn.net/weixin_49427945/article/details/136458398</a><br><a href=\"https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html\">https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html</a></p>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/01/%E4%B8%93%E9%A2%983-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "url": "https://232akira.github.io/2025/04/01/%E4%B8%93%E9%A2%983-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "title": "专题3️⃣ 动态规划",
            "date_published": "2025-04-01T01:18:00.000Z",
            "content_html": "<p>动规来力！！！</p>\n<h1 id=\"2140-解决智力问题\"><a href=\"#2140-解决智力问题\" class=\"headerlink\" title=\"2140.解决智力问题\"></a>2140.解决智力问题</h1><blockquote>\n<p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] &#x3D; [pointsi, brainpoweri] 。<br>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。<br>比方说，给你 questions &#x3D; [[3, 2], [4, 3], [4, 4], [2, 5]] ：</p>\n<ul>\n<li>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</li>\n<li>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br>请你返回这场考试里你能获得的 最高分数。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; questions.length &lt;&#x3D; 105</li>\n<li>questions[i].length &#x3D;&#x3D; 2</li>\n<li>1 &lt;&#x3D; pointsi, brainpoweri &lt;&#x3D; 105</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>解决我的智力问题（不是🤯</p>\n<p>看了<a href=\"https://leetcode.cn/problems/solving-questions-with-brainpower/solutions/1213919/dao-xu-dp-by-endlesscheng-2qkc/?envType=daily-question&envId=2025-04-01\">题解</a>发现是打家劫舍的变体题，所以带着一块儿做了。</p>\n<p>👉相当于如果选了k，接下来有x个不能选：打家劫舍是x&#x3D;1，本题x&#x3D;questions[i][1]。</p>\n<ol>\n<li><p>子问题<br>原问题：“完成考试（即所有题都已解决or跳过）能获得的最大分数”<code>→</code>子问题：“完成前k道题能获得的最大分数”</p>\n</li>\n<li><p>递推关系<br>👉已知子问题f(k)，那么只关注当前（即第k道）题，只有两种做题方法：<br>做k &amp;&amp; 做k+x<code>or</code>不做k &amp;&amp; 做k+1</p>\n</li>\n</ol>\n<p>👉递推关系：<code>f(k)=max&#123;f(k-1),k-1道题的分数+f(k-1+x)&#125;</code></p>\n<p>边界：无题目（k&#x3D;0）和只有一道题(k&#x3D;1)</p>\n<ol start=\"3\">\n<li>dp数组的计算顺序<br>✅️dp[k]依赖于dp[k-1]和dp[k-1+x]</li>\n</ol>\n<p>不对。这题搞得我现在有点懵，这会正好感冒昏昏沉沉的😵‍💫等我二编…</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"53-最大子数组和\"><a href=\"#53-最大子数组和\" class=\"headerlink\" title=\"53.最大子数组和\"></a>53.最大子数组和</h1><blockquote>\n<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>经典解法：Kadane算法</strong>。核心思路是动态规划，通过遍历数组维护当前最大子数组和。整体思路如下：<br>1️⃣<strong>维护两个变量：</strong></p>\n<ul>\n<li><code>sum</code>当前最大子数组和</li>\n<li><code>maxsum</code>全局最大子数组和<br>2️⃣<strong>遍历数组，每次决定是否扩展当前子数组</strong></li>\n<li>如果<code>sum+nums[i] &lt; nums[i]</code> 从nums[i]重新开始（之前的子数组必定与最大和无关</li>\n<li>否则继续累加nums[i]<br>3️⃣<strong>每次更新<code>maxsum</code></strong></li>\n</ul>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int sum=nums[0];\n        int maxsum=nums[0];\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            sum=max(nums[i],sum+nums[i]);\n            maxsum=max(sum,maxsum);\n        &#125;\n        return maxsum;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "专题",
                "C++"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "url": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "title": "专题1️⃣ 滑动窗口",
            "date_published": "2025-03-12T10:20:15.000Z",
            "content_html": "<p>今天照例每日一题，然后麻溜的看题解，发现又是一道滑动窗口题。所以开个专题归类一下。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><h2 id=\"基础算法精讲03-滑动窗口\"><a href=\"#基础算法精讲03-滑动窗口\" class=\"headerlink\" title=\"基础算法精讲03-滑动窗口\"></a><a href=\"https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">基础算法精讲03-滑动窗口</a></h2><p>👉️双指针的应用场景：</p>\n<ul>\n<li>单调性</li>\n</ul>\n<h1 id=\"713-乘积小于K的子数组\"><a href=\"#713-乘积小于K的子数组\" class=\"headerlink\" title=\"713.乘积小于K的子数组\"></a>713.乘积小于K的子数组</h1><blockquote>\n<p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p>\n</blockquote>\n<blockquote>\n<p>提示: </p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; 106</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3.无重复字符的最长子串\"></a>3.无重复字符的最长子串</h1><blockquote>\n<p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</li>\n<li>s 由英文字母、数字、符号和空格组成</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h1><blockquote>\n<p>给定一个含有n个正整数的数组和一个正整数target。<br>找出该数组中满足其总和大于等于target的长度最小的子数组 [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; target &lt;&#x3D; 109</li>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>进阶：</p>\n<ul>\n<li>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>在数组字串问题中，经常会用到<strong>双指针</strong>这一技巧。</p>\n<ol>\n<li><p>暴力方法 时间复杂度<code>O(n^2)</code></p>\n</li>\n<li><p>枚举右端点，收缩左端点 时间复杂度<code>O(n)</code></p>\n</li>\n</ol>\n<ul>\n<li>拿到数组的长度n</li>\n<li>答案ans初始化为n+1或者更大</li>\n<li>总和sum初始化为0</li>\n<li>左端点left初始化为0</li>\n<li>right右端点for循环(0~n-1)：sum+&#x3D;nums[right]</li>\n<li>for嵌套while(s-nums[left]):此时子数组的和减去左端点依旧&gt;&#x3D;target：sum-&#x3D;nums[left];left+&#x3D;1;(移掉左端点)</li>\n<li>如果sum&gt;&#x3D;target:更新答案最小值 ans&#x3D;min(ans,right-left+1)</li>\n<li>返回ans（&lt;&#x3D;n返回ans，否则返回0）</li>\n</ul>\n<p><em><strong>注意：此题不需要判断left和right两者间的大小关系。</strong></em><br>因为当left&#x3D;right时，s-nums[left]&#x3D;0，一定比target小（target为正整数），不满足while条件。</p>\n<ol start=\"3\">\n<li>在「2」的基础上，把ans的更新写到while里面</li>\n</ol>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;\n        int n,ans,sum,left;\n        n=nums.size();\n        ans=n+1;\n        sum=left=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            // sum+=nums[i];\n            // while(sum-nums[left]&gt;=target)&#123;\n            //     sum-=nums[left];\n            //     left++;\n            // &#125;\n            // if(sum&gt;=target)&#123;\n            //     ans=min(ans,i-left+1);\n            // &#125;\n            while(sum&gt;=target)&#123;\n                ans=min(ans,i-left+1);\n                sum-=nums[left++];\n            &#125;\n        &#125;\n        return ans&lt;=n?ans:0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><p>今天字符串也要美丽了🆘</p>\n<blockquote>\n<p>一个整数num的k美丽值定义为num中符合以下条件的子字符串数目：</p>\n<ul>\n<li>子字符串长度为k。</li>\n<li>子字符串能整除num。<br>给你整数num和k，请你返回num的k美丽值。<br>注意：<br>允许有前缀0。<br>0不能整除任何值。<br>一个子字符串是一个字符串里的连续一段字符序列。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= num &lt;= 109</code></li>\n<li><code>1 &lt;= k &lt;= num.length</code> （将 num 视为字符串）</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我觉得这道的要点就是子串怎么得，剩下的就好判断了。偏偏我就栽在这儿了😅</p>\n<ul>\n<li><strong>int转string</strong> <code>to_string()</code>注意此函数需要赋给个string变量</li>\n<li><strong>string转int</strong> <code>stoi()</code>同样，需要赋给个int变量</li>\n<li><strong>获取长度为k的字符串</strong> <code>substr(i,k)</code>距离c++学这个函数已经过了一两年了，忘的一干二净，趁此好机会来总结一下。</li>\n</ul>\n<p>👇️ <em><strong>获取子串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>substr(pos,len)</code></td>\n<td align=\"center\">从pos开始，提取长度为len的子串</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>查找字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>find(str,pos)</code></td>\n<td align=\"center\">在pos之后查找str的位置，找不到返回string::pos</td>\n</tr>\n<tr>\n<td align=\"center\"><code>rfind(str,pos)</code></td>\n<td align=\"center\">逆向查找str,从pos开始向前找</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_first_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的第一次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_last_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的最后一次出现</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>替换字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>replace(pos,len,str)</code></td>\n<td align=\"center\">从pos开始，用str替换len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>erase(pos,len)</code></td>\n<td align=\"center\">删除从pos开始的len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>insert(pos,str)</code></td>\n<td align=\"center\">在pos位置插入str</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>大小写转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>toupper(c)</code></td>\n<td align=\"center\">将字符c转换为大写</td>\n</tr>\n<tr>\n<td align=\"center\"><code>tolower(c)</code></td>\n<td align=\"center\">将字符c转换为小写</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>数字与字符串转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>to_string(num)</code></td>\n<td align=\"center\">把num转换为字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stoi(str)</code></td>\n<td align=\"center\">把str转换为int</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stol(str)</code></td>\n<td align=\"center\">把str转换为long</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stod(str)</code></td>\n<td align=\"center\">把str转换为double</td>\n</tr>\n</tbody></table>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int divisorSubstrings(int num, int k) &#123;\n        int cnt=0;\n        string str=to_string(num);\n        for(int i=0;i&lt;=str.size()-k;i++)&#123;\n            string ans=str.substr(i,k);\n            int answer=stoi(ans);\n            if(answer!=0 &amp;&amp; num%answer==0)&#123;\n                cnt++;\n            &#125;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3305-元音辅音字符串计数Ⅰ\"><a href=\"#3305-元音辅音字符串计数Ⅰ\" class=\"headerlink\" title=\"3305.元音辅音字符串计数Ⅰ\"></a>3305.元音辅音字符串计数Ⅰ</h1><blockquote>\n<p>给你一个字符串word和一个非负整数 k。<br>返回word的子字符串中，每个元音字母（’a’、’e’、’i’、’o’、’u’）至少出现一次，并且恰好包含k个辅音字母的子字符串的总数。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>5 &lt;&#x3D; word.length &lt;&#x3D; 250</li>\n<li>word 仅由小写英文字母组成。</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; word.length - 5</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先试了试暴力😤循环套三层观感太差，不放上来。</p>\n<p><strong>正经解法</strong></p>\n<ul>\n<li>滑动窗口代替暴力循环</li>\n<li>哈希表统计元音出现次数</li>\n</ul>\n<p><strong>注意几个用法</strong><br><em><strong>1️⃣ 几个键值对容器</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键值对容器</th>\n<th align=\"center\">实现方式</th>\n<th align=\"center\">键值</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">是否有序</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unordered_map</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找键对应的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>map</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要有序键值对</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_set</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找元素是否存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>set</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要排序的集合</td>\n</tr>\n</tbody></table>\n<p><em><strong>2️⃣ 键值对容器+函数求的是什么？</strong></em></p>\n<ul>\n<li><code>unordered_map.size()</code>返回unordered_map中<strong>键值对的数量</strong>。</li>\n<li><code>unordered_set.count(x)</code>unordered_set中<strong>某个元素是否存在</strong>，返回1表示在，0表示不在。</li>\n</ul>\n<p>代码思路如下。这个方法时间空间上并非最优，后续需要调整思路。</p>\n<pre><code class=\"language-cpp\">定义n：word长度;\n定义unordered_map类型的vowel_cnt:元音出现次数;\n定义consonant_cnt:辅音个数;\n定义ans：统计最终答案;\n定义unordered_set类型的vowels:所有元音字母;\n定义左指针j=0;\n遍历word从下标0~word.size():\n    定义右元素right=word[i];\n    统计元音出现次数：\n        进行元/辅音计数;\n    当辅音数量超过k://收缩窗口左边界\n        定义左元素left=word[左指针];//取左边界字符\n        如果left是元音：\n            该元音出现次数--;\n            当元音的计数减少到0时：\n                将它从vowel_cnt中删除；\n        否则：\n            辅音个数--;\n        左指针右移;\n    如果包含所有元音且辅音个数为k:\n        //避免修改原窗口状态,思路整体与上半部分相同☝️\n        定义临时变量temp_vowel=vowel_cnt;\n        定义临时变量temp_consonant=consonant_cnt;\n        定义临时变量temp_j=j;\n        定义计数cnt=0;\n        当临时左下标&lt;=右下标:\n            如果包含所有临时元音且临时辅音个数为k:\n                cnt++;\n            否则:\n                退出该层循环;\n            定义c:word[临时左指针];\n            如果c是元音：\n                临时该元音出现次数--;\n                当临时元音的计数减少到0时：\n                    将它从临时vowel_cnt中删除;\n            否则:\n                临时辅音个数--;\n            临时左指针j右移;\n        ans+=cnt;\n返回ans;\n</code></pre>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countOfSubstrings(string word, int k) &#123;\n        int len=word.size();\n        unordered_map&lt;char,int&gt;vowel_cnt;\n        int consonant_cnt=0;\n        int ans=0;\n        unordered_set&lt;int&gt;vowels=&#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;&#125;;\n        int j=0;\n        for(int i=0;i&lt;len;i++)&#123;\n            char right=word[i];\n            if(vowels.count(right))&#123;\n                vowel_cnt[right]++;\n            &#125;\n            else&#123;\n                consonant_cnt++;\n            &#125;\n            while(consonant_cnt&gt;k)&#123;\n                char left=word[j];\n                if(vowels.count(left))&#123;\n                    vowel_cnt[left]--;\n                    if(vowel_cnt[left]==0)&#123;\n                        vowel_cnt.erase(left);\n                    &#125;\n                &#125;\n                else&#123;\n                    consonant_cnt--;\n                &#125;\n                j++;\n            &#125;\n            if(vowel_cnt.size()==5 &amp;&amp; consonant_cnt==k)&#123;\n                unordered_map&lt;char,int&gt;temp_vowel=vowel_cnt;\n                int temp_consonant=consonant_cnt;\n                int temp_j=j;\n                int cnt=0;\n                while(temp_j&lt;=i)&#123;\n                    if(temp_vowel.size()==5 &amp;&amp; temp_consonant==k)&#123;\n                        cnt++;\n                    &#125;\n                    else&#123;\n                        break;\n                    &#125;\n                    int c=word[temp_j];\n                    if(vowels.count(c))&#123;\n                        temp_vowel[c]--;\n                        if(temp_vowel[c]==0)&#123;\n                            temp_vowel.erase(c);\n                        &#125;\n                    &#125;\n                    else&#123;\n                        temp_consonant--;\n                    &#125;\n                    temp_j++;\n                &#125;\n                ans+=cnt;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3306-元音辅音字符串计数Ⅱ\"><a href=\"#3306-元音辅音字符串计数Ⅱ\" class=\"headerlink\" title=\"3306.元音辅音字符串计数Ⅱ\"></a>3306.元音辅音字符串计数Ⅱ</h1><p>不行，彻底懵了脑子转不动做梦都是元辅音😫先把copy的官方题解放这，过两天我再苟回来看。</p>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long countOfSubstrings(string word, int k) &#123;\n        set&lt;char&gt; vowels = &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;&#125;;\n        auto count = [&amp;](int m) -&gt; long long &#123;\n            int n = word.size(), consonants = 0;\n            long long res = 0;\n            map&lt;char, int&gt; occur;\n            for (int i = 0, j = 0; i &lt; n; i++) &#123;\n                while (j &lt; n &amp;&amp; (consonants &lt; m || occur.size() &lt; vowels.size())) &#123;\n                    if (vowels.count(word[j])) &#123;\n                        occur[word[j]]++;\n                    &#125; else &#123;\n                        consonants++;\n                    &#125;\n                    j++;\n                &#125;\n                if (consonants &gt;= m &amp;&amp; occur.size() == vowels.size()) &#123;\n                    res += n - j + 1;\n                &#125;\n                if (vowels.count(word[i])) &#123;\n                    occur[word[i]]--;\n                    if (occur[word[i]] == 0) &#123;\n                        occur.erase(word[i]);\n                    &#125;\n                &#125; else &#123;\n                    consonants--;\n                &#125;\n            &#125;\n            return res;\n        &#125;;\n        return count(k) - count(k + 1);\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "专题",
                "C++"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "url": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "title": "Leetcode链表",
            "date_published": "2025-03-06T02:25:28.000Z",
            "content_html": "<p>链表这东西真的学一阵忘一阵😂</p>\n<h1 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h1><h2 id=\"结构定义\"><a href=\"#结构定义\" class=\"headerlink\" title=\"结构定义\"></a>结构定义</h2><ul>\n<li>节点结构 <code>ListNode</code></li>\n<li>值 <code>data</code></li>\n<li>指向下一个节点的指针 <code>next</code></li>\n</ul>\n<pre><code class=\"language-cpp\">struct ListNode&#123;\n    int data;\n    ListNode* next;\n    ListNode(int x):data(x),next(nullptr)&#123;&#125;\n&#125;Node;\n</code></pre>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h3 id=\"创建链表\"><a href=\"#创建链表\" class=\"headerlink\" title=\"创建链表\"></a>创建链表</h3><p>定义单链表类，封装基本操作。下面的几个操作都在public里~</p>\n<pre><code class=\"language-cpp\">class LinkedList&#123;\npublic:\n    ListNode* head;\n    LinkedList():head(nullptr);\n&#125;\n</code></pre>\n<h3 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h3><ul>\n<li>头插法:新节点加到链表头部</li>\n</ul>\n<pre><code class=\"language-cpp\">void insertAtHead(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    newNode-&gt;next=head;\n    head=newNode;\n&#125;\n</code></pre>\n<ul>\n<li>尾插法：:新节点加到链表尾部</li>\n</ul>\n<pre><code class=\"language-cpp\">void insertAtTail(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    if(!head)&#123;\n        head=newNode;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    temp-&gt;next=newNode;\n&#125;\n</code></pre>\n<h3 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h3><pre><code class=\"language-cpp\">void deleteNode(int data)&#123;\n    if(!head)&#123;\n        return;\n    &#125;\n    if(head-&gt;data==data)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;val !=val)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    if(temp-&gt;next)&#123;\n        ListNode* delNode=temp-&gt;next;\n        temp-&gt;next=temp-&gt;next-&gt;next;\n        delete delNode;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"修改节点\"><a href=\"#修改节点\" class=\"headerlink\" title=\"修改节点\"></a>修改节点</h3><pre><code class=\"language-cpp\">void updateNode(int oldData,newData)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-data==oldData)&#123;\n            temp-&gt;data==oldData;\n            return;\n        &#125;\n        temp=temp-&gt;next;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h3><pre><code class=\"language-cpp\">bool searchNode(int data)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-&gt;data==data)&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h3 id=\"打印链表\"><a href=\"#打印链表\" class=\"headerlink\" title=\"打印链表\"></a>打印链表</h3><pre><code class=\"language-cpp\">void printList()&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        cout&lt;&lt;temp-&gt;val&lt;&lt;&quot;-&gt;&quot;;\n        temp=temp-&gt;next;\n    &#125;\n    cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl;\n&#125;\n</code></pre>\n<h3 id=\"释放链表内存\"><a href=\"#释放链表内存\" class=\"headerlink\" title=\"释放链表内存\"></a>释放链表内存</h3><pre><code class=\"language-cpp\">~LinkedList()&#123;\n    while(head)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"83-删除排序链表中的重复元素\"><a href=\"#83-删除排序链表中的重复元素\" class=\"headerlink\" title=\"83.删除排序链表中的重复元素\"></a>83.删除排序链表中的重复元素</h1><blockquote>\n<p>给定一个已排序的链表的头head，删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点数目在范围 [0, 300] 内</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>题目数据保证链表已经按升序排列</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li>【如果】头节点&#x3D;空：直接返回该节点</li>\n<li>初始化一个当前节点变量&#x3D;头节点</li>\n<li>【只要】当前<code>节点-&gt;next</code>不为空</li>\n</ol>\n<ul>\n<li>「如果」<code>当前节点-&gt;next的值</code>&#x3D;<code>当前节点的值</code>： <code>当前节点-&gt;next</code>&#x3D;<code>当前节点-&gt;next-&gt;next</code></li>\n<li>「否则」<code>当前节点</code>&#x3D;<code>当前节点-&gt;next</code></li>\n</ul>\n<ol start=\"4\">\n<li>返回头节点</li>\n</ol>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if(head==nullptr)&#123;\n            return head;\n        &#125;\n        ListNode* cur=head;\n        while(cur-&gt;next!=nullptr)&#123;\n            if(cur-&gt;next-&gt;val==cur-&gt;val)&#123;\n                cur-&gt;next=cur-&gt;next-&gt;next;\n            &#125;\n            else&#123;\n                cur=cur-&gt;next;\n            &#125;\n        &#125;\n        return head;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "链表"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/05/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://232akira.github.io/2025/03/05/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "Leetcode字符串",
            "date_published": "2025-03-05T07:22:48.000Z",
            "content_html": "<h1 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58.最后一个单词的长度\"></a>58.最后一个单词的长度</h1><blockquote>\n<p><strong>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</strong></p>\n</blockquote>\n<p>KMP有点难理解了对我而言…看不懂就放两天继续钻，再多看看大佬博客的不同理解，效果会更好。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ul>\n<li>参考链接：<br><a href=\"https://www.cnblogs.com/dusf/p/kmp.html\">1️⃣</a><br><a href=\"https://blog.csdn.net/yyzsir/article/details/89462339?ops_request_misc=%257B%2522request%255Fid%2522%253A%252292dce769a412320e26ef79eb85ca18cd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=92dce769a412320e26ef79eb85ca18cd&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-89462339-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=yyzsir%20kmp&spm=1018.2226.3001.4187\">2️⃣</a></li>\n</ul>\n<hr>\n<h3 id=\"朴素模式匹配BF\"><a href=\"#朴素模式匹配BF\" class=\"headerlink\" title=\"朴素模式匹配BF\"></a>朴素模式匹配<code>BF</code></h3><p>首先来个<strong>暴力</strong>方法：不匹配模式串就右挪一位。</p>\n<pre><code>//暴力模式匹配\nint 主串位置i；\nint 模式串位置j；\nint 主串长度；\nint 子串长度；\n\n当（主串位置 &lt;= 主串长度 &amp;&amp; 模式串位置&lt;模式串长度）:\n    如果（该主串位置的主串字符 == 该模式串位置的模式串字符）：\n        i++；\n        j++；\n    否则：\n        i后退至上一轮匹配开始位置的后一位；\n        j归零；\n如果（模式串位置 == 模式串长度）：\n    匹配成功，返回出现位置；\n否则\n    匹配失败，返回-1；\n</code></pre>\n<h3 id=\"优化模式匹配KMP\"><a href=\"#优化模式匹配KMP\" class=\"headerlink\" title=\"优化模式匹配KMP\"></a>优化模式匹配<code>KMP</code></h3><p>即利用<strong>已经部分匹配</strong>这个信息，保持<strong>i指针不回溯</strong>，并通过j指针让<strong>模式串</strong>尽可能移动到<strong>更有效的位置</strong>。</p>\n<p>那么有几个要点：</p>\n<ul>\n<li><p><em><strong>前缀(Prefix)和后缀（Suffix）</strong></em><br>举个🌰，给定一个字符串s:<code>“abcab”</code>,那么:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">s的子串</th>\n<th align=\"center\"><strong>前缀</strong></th>\n<th align=\"center\"><strong>后缀</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">ab</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n</tr>\n<tr>\n<td align=\"center\">abc</td>\n<td align=\"center\">a,ab</td>\n<td align=\"center\">c,bc</td>\n</tr>\n<tr>\n<td align=\"center\">abca</td>\n<td align=\"center\">a,ab,abc</td>\n<td align=\"center\">a,ca,bca</td>\n</tr>\n<tr>\n<td align=\"center\">abcab</td>\n<td align=\"center\">a,ab,abc,abca</td>\n<td align=\"center\">b,ab,cab,bcab</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><em><strong>公共前后缀最长长度</strong></em><br>从上面的前后缀不难看出，对于s的子串，存在部分前后缀重复的情况，我们需要的正是重复子串的最大长度。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">s的子串</th>\n<th align=\"center\">前缀</th>\n<th align=\"center\">后缀</th>\n<th align=\"center\"><strong>公共前后缀最长长度</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">ab</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">abc</td>\n<td align=\"center\">a,ab</td>\n<td align=\"center\">c,bc</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">abca</td>\n<td align=\"center\"><code>a</code>,ab,abc</td>\n<td align=\"center\"><code>a</code>,ca,bca</td>\n<td align=\"center\"><code>1</code></td>\n</tr>\n<tr>\n<td align=\"center\">abcab</td>\n<td align=\"center\">a,<code>ab</code>,abc,abca</td>\n<td align=\"center\">b,<code>ab</code>,cab,bcab</td>\n<td align=\"center\"><code>2</code></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><em><strong>next数组（部分匹配表）</strong></em><br>KMP的next数组告诉我们：当模式串中的某个字符跟主串中的某个字符失配时，模式串下一步应该跳到哪个位置。</p>\n</li>\n</ul>\n<p>对于s的<strong>每个字符</strong>而言，当这个字符作为子串的最后一位时，公共前后缀最长长度为：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符（标红部分）</th>\n<th align=\"center\">公共前后缀最长长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>a</code>bcab</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">a<code>b</code>cab</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">ab<code>c</code>ab</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">abc<code>a</code>b</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">abca<code>b</code></td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<p>那么全部右移一位，令next[0]&#x3D;-1：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符</th>\n<th align=\"center\">i</th>\n<th align=\"center\">next[i]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">0</td>\n<td align=\"center\">-1</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"center\">3</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p><strong>实际匹配过程中，j移动到子串p的next[j]位置，p相对s向右移动j-next[j]位置。</strong></p>\n<ul>\n<li><strong>迭代法求p的next数组</strong><br>我们知道：</li>\n</ul>\n<pre><code class=\"language-cpp\">next[0]=-1;\nnext[1]=0;\n</code></pre>\n<p>并且<code>next[j]</code>代表p[0…j-1]的子串公共前后缀最长长度。<br>∴ 变量定义如下：<br><code>j</code>：当前子串指针<br><code>k</code>：当前匹配的前后缀长度（&#x3D;next[j-1]）<br><code>next[j]=k</code>：next[0]&#x3D;-1 即当p[0]都匹配失败时，只能回到j&#x3D;0重新匹配。</p>\n<pre><code class=\"language-cpp\">void GetNext(char p[], int next[])\n&#123;\n    int j = 0, k = -1;\n    next[j] = k;\n    while (p[j] != &#39;\\0&#39;)             //遍历整个子串p\n    &#123;\n        if (k == -1 || p[j] == p[k]) //匹配成功😀或者k=-1（刚匹配到字串的第一个）\n        &#123;\n            j++;                     //j指针后移\n            k++;\n            next[j] = k;             //记录当前前后缀匹配长度\n        &#125; \n        else \n        &#123;\n            k = next[k];             //匹配失败😭，回溯到next[k]寻找更短的前后缀\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>KMP主算法<br>得到next数组的方法<code>GetNext()</code>，就可以完整的写出KMP函数。这里写成一个函数：</li>\n</ul>\n<pre><code class=\"language-cpp\">int KMP(string s,string p)&#123;\n    int m=s.size();\n    int n=p.size();\n    if(m==0)&#123;\n        return 0;\n    &#125;\n    //⬇️计算next数组\n    vector&lt;int&gt;next;\n    int j=0;\n    for(int i=0;i&lt;n;i++)&#123;\n        while(j&gt;0 &amp;&amp; p[i]!=p[j])&#123;\n            j=next[j-1];\n        &#125;\n        if(p[i]==p[j])&#123;\n            j++;\n        &#125;\n        next[i]=j;\n    &#125;\n    //⬇️KMP搜索匹配\n    int j=0;\n    for(int i=0;i&lt;m;i++)&#123;\n        while(j&gt;0 &amp;&amp; s[i]!=p[j])&#123;\n            j=next[j-1];\n        &#125;\n        if(s[i]==p[j])&#123;\n            j++;\n        &#125;\n        if(j==n)&#123;\n            return i-n+1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n</code></pre>\n<p>说实话，后半部分现在不能完全理解，让我再多磕几天。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        int len=s.length();\n        int m=0,n=0;\n        for(int i=len-1;i&gt;0;i--)&#123;\n            if(s[i]!=&#39; &#39; &amp;&amp; (s[i+1]==&#39; &#39; || s[i+1]==&#39;\\0&#39;))&#123;\n                m=i;\n            &#125;\n            if((s[i-1]==&#39; &#39; || s[i-1]==&#39;\\0&#39;) &amp;&amp; s[i]!=&#39; &#39;)&#123;\n                n=i;\n                break;\n            &#125;\n        &#125;\n        return m-n+1;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"1021-删除最外层的括号\"><a href=\"#1021-删除最外层的括号\" class=\"headerlink\" title=\"1021.删除最外层的括号\"></a>1021.删除最外层的括号</h1><blockquote>\n<p>有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。<br>例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。<br>如果有效字符串 s 非空，且不存在将其拆分为 s &#x3D; A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。<br>给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s &#x3D; P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。<br>对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length &lt;&#x3D; 105</li>\n<li>s[i] 为 ‘(‘ 或 ‘)’</li>\n<li>s 是一个有效括号字符串</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>引用<strong>官方题解</strong>的话：<br>遍历 s，并用一个栈来表示括号的深度。遇到 ‘(’ 则将字符入栈，遇到 ‘)’ 则将栈顶字符出栈。栈从空到下一次空的过程，则是扫描了一个原语的过程。</p>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string removeOuterParentheses(string s) &#123;\n        string res;\n        int cnt=0;\n        for(char ch:s)&#123;\n            if(ch==&#39;)&#39;)&#123;\n                cnt--;\n            &#125;\n            if(cnt&gt;0)&#123;\n                res.push_back(ch);\n            &#125;\n            if(ch==&#39;(&#39;)&#123;\n                cnt++;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"859-亲密字符串\"><a href=\"#859-亲密字符串\" class=\"headerlink\" title=\"859.亲密字符串\"></a>859.亲密字符串</h1><blockquote>\n<p>给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。<br>交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i !&#x3D; j ，接着交换 s[i] 和 s[j] 处的字符。</p>\n<ul>\n<li>例如，在 “abcd” 中交换下标 0 和下标 2 的元素可以生成 “cbad” 。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length, goal.length &lt;&#x3D; 2 * 104</li>\n<li>s 和 goal 由小写英文字母组成</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>都去给我关注<a href=\"https://leetcode.cn/u/ac_oier/\">三叶大佬</a>！<br>既然交换s中的两个字母&#x3D;&#x3D;goal，即为亲密。那么：</p>\n<ol>\n<li>不亲密<br><code>s</code>与<code>goal</code>长度不同 <strong>或</strong> 词频不同</li>\n<li>亲密</li>\n</ol>\n<ul>\n<li><code>s</code>与<code>goal</code>不同的的字符串数量为2<br><strong>或</strong></li>\n<li><code>s</code>与<code>goal</code>不同的字符串数量为0 并且 <code>s</code>中存在出现次数&gt;2的字符</li>\n</ul>\n<blockquote>\n<p>PS: 这里<a href=\"https://leetcode.cn/u/MiracleSNeko/\">评论区</a>特好玩😂“我真傻，真的，”我抬起我没有神采的眼睛来，接着说。“我单知道两个不同的字符互相交换，会生成一个亲密字符串；我不知道相同的字符也会互相换着玩。……” 我接着但是呜咽，说不出成句的话来。（</p>\n</blockquote>\n<blockquote>\n<p>所以注意：即使一开始s&#x3D;&#x3D;goal，但是s怎么交换2字符都不能再&#x3D;&#x3D;goal，也<strong>不算亲密</strong>。</p>\n</blockquote>\n<ol start=\"3\">\n<li>还有一个代码小细节：<strong>为什么是26？</strong><br>字符<code>&#39;a&#39;</code> - <code>&#39;z&#39;</code>共26个。因为题目限定了输入字符串只包含小写字母，所以最多只需要存储26个字符的频次。</li>\n</ol>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-CPP\">class Solution &#123;\npublic:\n    bool buddyStrings(string s, string goal) &#123;\n        if(s.size()!=goal.size())&#123;\n            return false;\n        &#125;\n        if(s==goal)&#123;\n            vector&lt;int&gt; cnt(26);\n            for(int i=0;i&lt;s.size();i++)&#123;\n                cnt[s[i]-&#39;a&#39;]++;\n                if(cnt[s[i]-&#39;a&#39;]&gt;1)&#123;\n                    return true;\n                &#125;\n            &#125;\n            return false;\n        &#125;\n        else&#123;//记录s和goal不相同的字符位置\n            int first,second;\n            first=-1;\n            second=-1;\n            for(int i=0;i&lt;s.size();i++)&#123;\n                if(s[i]!=goal[i])&#123;\n                    if(first==-1)&#123;\n                        first=i;\n                    &#125;\n                    else if(second==-1)&#123;\n                        second=i;\n                    &#125;\n                    else&#123;\n                        return false;\n                    &#125;\n                &#125;\n            &#125;\n        //检查是否可以交换\n        return (second!=-1 &amp;&amp; s[first]==goal[second] &amp;&amp; s[second]==goal[first]);\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3304-找出第K个字符Ⅰ\"><a href=\"#3304-找出第K个字符Ⅰ\" class=\"headerlink\" title=\"3304.找出第K个字符Ⅰ\"></a>3304.找出第K个字符Ⅰ</h1><blockquote>\n<p>Alice 和 Bob 正在玩一个游戏。最初，Alice 有一个字符串 word &#x3D; “a”。<br>给定一个正整数 k。<br>现在 Bob 会要求 Alice 执行以下操作 无限次 :</p>\n<ul>\n<li>将 word 中的每个字符 更改 为英文字母表中的 下一个 字符来生成一个新字符串，并将其 追加 到原始的 word。<br>例如，对 “c” 进行操作生成 “cd”，对 “zb” 进行操作生成 “zbac”。<br>在执行足够多的操作后， word 中 至少 存在 k 个字符，此时返回 word 中第 k 个字符的值。<br>注意，在操作中字符 ‘z’ 可以变成 ‘a’。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; k &lt;&#x3D; 500</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>主打一个模拟：</p>\n<ol>\n<li>构造字符串<code>s</code></li>\n</ol>\n<ul>\n<li>初始值为<code>&quot;a&quot;</code></li>\n<li>每轮迭代，生成s的副本t，然后每个字符变成它的下一个字母：<code>((word[i]-&#39;a&#39;+1)%26+&#39;a&#39;)</code><blockquote>\n<p>这里用ASCII码运算，因为’a’<del>‘z’为98</del>233,所以<code>word[i]-&#39;a&#39;</code>计算word[i]相对与a的偏移量，即字符word[i]是字母表中的<strong>第<code>word[i]-&#39;a&#39;</code>个字母</strong>，<code>+1</code>即为后一个字符；<br><code>%26+&#39;a&#39;</code>的原因是：当word[i]为<code>&#39;z&#39;</code>时,让26变回0，所以%26取模。</p>\n</blockquote>\n</li>\n<li>将<code>t</code>拼接回<code>s</code></li>\n</ul>\n<ol start=\"2\">\n<li>终止条件</li>\n</ol>\n<ul>\n<li>当<code>s.size()&gt;=k</code>时，直接返回s[k-1]</li>\n</ul>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>c&#x3D;word[i]</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    char kthCharacter(int k) &#123;\n        string word=&quot;a&quot;;\n        while(word.size()&lt;k)&#123;\n            string t;\n            for(char c:word)&#123;\n                t.push_back((c-&#39;a&#39;+1)%26+&#39;a&#39;);\n            &#125;\n            word+=t;\n        &#125;\n        return word[k-1];\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"1544-整理字符串\"><a href=\"#1544-整理字符串\" class=\"headerlink\" title=\"1544.整理字符串\"></a>1544.整理字符串</h1><blockquote>\n<p>给你一个由大小写英文字母组成的字符串 s 。<br>一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0&lt;&#x3D; i &lt;&#x3D; s.length-2 ，要满足如下条件:</p>\n<ul>\n<li>若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。</li>\n<li>若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。<br>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li>\n<li>s 只包含小写和大写英文字母</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>一开始直接用erase删符合条件的字符，而且删除后索引没有回退，报错显示 <code>std::out_of_range</code>。<br>后来用<strong>栈</strong>来解决：</p>\n<ol>\n<li>迭代字符串s，删除互为大小写的字符，其他的正常压栈</li>\n<li><code>abs(stk.back() - ch) == 32</code> 栈顶字符和当前字符互为大小写（用abs确保大小写前后顺序都可）</li>\n</ol>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string makeGood(string s) &#123;\n        string stk;\n        for(char ch:s)&#123;\n            if(!stk.empty() &amp;&amp; abs(stk.back()-ch)==32)&#123;\n                stk.pop_back();\n            &#125;\n            else&#123;\n                stk.push_back(ch);\n            &#125;\n        &#125;\n        return stk;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2116-判断一个括号字符串是否有效\"><a href=\"#2116-判断一个括号字符串是否有效\" class=\"headerlink\" title=\"2116.判断一个括号字符串是否有效\"></a>2116.判断一个括号字符串是否有效</h1><blockquote>\n<p>一个括号字符串是只由 ‘(‘ 和 ‘)’ 组成的 非空 字符串。如果一个字符串满足下面 任意一个条件，那么它就是有效的：</p>\n<ul>\n<li>字符串为 ().</li>\n<li>它可以表示为 AB（A 与 B 连接），其中A 和 B 都是有效括号字符串。</li>\n<li>它可以表示为 (A) ，其中 A 是一个有效括号字符串。<br>给你一个括号字符串 s 和一个字符串 locked ，两者长度都为 n 。locked &gt;是一个二进制字符串，只包含 ‘0’ 和 ‘1’ 。对于 locked 中 每一个 下标 i ：</li>\n<li>如果 locked[i] 是 ‘1’ ，你 不能 改变 s[i] 。</li>\n<li>如果 locked[i] 是 ‘0’ ，你 可以 将 s[i] 变为 ‘(‘ 或者 ‘)’ 。<br>如果你可以将s变为有效括号字符串，请你返回true，否则返回false。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>n &#x3D;&#x3D; s.length &#x3D;&#x3D; locked.length</li>\n<li>1 &lt;&#x3D; n &lt;&#x3D; 105</li>\n<li>s[i] 要么是 ‘(‘ 要么是 ‘)’ 。</li>\n<li>locked[i] 要么是 ‘0’ 要么是 ‘1’ 。</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>做到好几个括号匹配问题了，浅总结一下：</p>\n<p><em><strong>👉️括号平衡的核心规则</strong></em><br>任何前缀都不能有多余的右括号 &amp; 任何后缀都不能有多余的左括号</p>\n<p><em><strong>❔️为什么要检查前&#x2F;后缀而不是整个括号字符串？</strong></em><br>因为括号是从左到右依次匹配的。一旦前面某个位置出现错误，后面就绝对无法补救。</p>\n<p><em><strong>✅️关键思路</strong></em></p>\n<ul>\n<li>前缀遍历判断防止提前失配；后缀遍历防止无法闭合</li>\n<li>两边遍历保证整体匹配</li>\n<li>最终判断是否可以调整<code>（locked[i])</code>使其符合匹配规则</li>\n<li>注意locked也是字符串不是int</li>\n</ul>\n<h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>用时21ms，还有优化空间。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool canBeValid(string s, string locked) &#123;\n        if(s.size()%2!=0)&#123;\n            return false;\n        &#125;\n        int left,right;\n        left=right=0;\n        for(int i=0;i&lt;s.size();i++)&#123;\n            if(s[i]==&#39;(&#39; || locked[i]==&#39;0&#39;)&#123;\n                left++;\n            &#125;\n            else&#123;\n                right++;\n            &#125;\n            if(right&gt;left)&#123;\n                return false;\n            &#125;\n        &#125;\n        left=right=0;\n        for(int i=s.size()-1;i&gt;=0;i--)&#123;\n            if(s[i]==&#39;)&#39; || locked[i]==&#39;0&#39;)&#123;\n                right++;\n            &#125;\n            else&#123;\n                left++;\n            &#125;\n            if(left&gt;right)&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2255-统计是给定字符串前缀的字符串数目\"><a href=\"#2255-统计是给定字符串前缀的字符串数目\" class=\"headerlink\" title=\"2255.统计是给定字符串前缀的字符串数目\"></a>2255.统计是给定字符串前缀的字符串数目</h1><blockquote>\n<p>给你一个字符串数组 words 和一个字符串 s ，其中 words[i] 和 s 只包含 小写英文字母 。<br>请你返回 words 中是字符串 s 前缀 的 字符串数目 。<br>一个字符串的 前缀 是出现在字符串开头的子字符串。子字符串 是一个字符串中的连续一段字符序列。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; words.length &lt;&#x3D; 1000</li>\n<li>1 &lt;&#x3D; words[i].length, s.length &lt;&#x3D; 10</li>\n<li>words[i] 和 s 只 包含小写英文字母。</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>暴力双循环嵌套，第一个substr得子串，第二个判断子串是否与words[i]相等。</p>\n<h2 id=\"完整代码-6\"><a href=\"#完整代码-6\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123;\n        string ch;\n        int cnt=0;\n        for(int i=0;i&lt;=s.length();i++)&#123;\n            ch=s.substr(0,i);\n            for(int j=0;j&lt;words.size();j++)&#123;\n                if(words[j]==ch)&#123;\n                    cnt++;\n                &#125;\n            &#125;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2716-最小化字符串长度\"><a href=\"#2716-最小化字符串长度\" class=\"headerlink\" title=\"2716.最小化字符串长度\"></a>2716.最小化字符串长度</h1><blockquote>\n<p>给你一个下标从 0 开始的字符串 s ，重复执行下述操作 任意 次：<br>给你一个下标从 0 开始的字符串 s ，重复执行下述操作 任意 次：</p>\n<ul>\n<li>在字符串中选出一个下标 i ，并使 c 为字符串下标 i 处的字符。并在 i 左侧（如果有）和 右侧（如果有）各 删除 一个距离 i 最近 的字符 c 。<br>请你通过执行上述操作任意次，使 s 的长度 最小化 。<br>返回一个表示 最小化 字符串的长度的整数。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li>\n<li>s 仅由小写英文字母组成</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>题目这么长，其实就是字符串<strong>去重</strong>😂</p>\n<h2 id=\"完整代码-7\"><a href=\"#完整代码-7\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><ol>\n<li>我的方法</li>\n</ol>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minimizedStringLength(string s) &#123;\n        unordered_set&lt;int&gt; num;\n        for(char ch:s)&#123;\n            if(num.find(ch)==num.end())&#123;\n                num.insert(ch);\n            &#125;\n        &#125;\n        return num.size();\n    &#125;\n&#125;;\n</code></pre>\n<ol start=\"2\">\n<li>更简洁的方法<br>看到<a href=\"https://leetcode.cn/problems/minimize-string-length/solutions/2296066/o1-kong-jian-wei-yun-suan-xie-fa-pythonj-7t4p/?envType=daily-question&envId=2025-03-28\">题解</a>，发现也可以直接写成一行：</li>\n</ol>\n<ul>\n<li><code>unordered_set&lt;char&gt;(s.begin(), s.end())</code><br>直接用s.begin()和s.end()构造一个unordered_set<char>，会自动去重字符串中的字符</li>\n<li><code>.size()</code><br>计算去重后的字符个数</li>\n</ul>\n<pre><code class=\"language-cpp\">return unoredered_set(s.begin(),s.end().size());\n</code></pre>\n<h1 id=\"2109-最小化字符串长度\"><a href=\"#2109-最小化字符串长度\" class=\"headerlink\" title=\"2109.最小化字符串长度\"></a>2109.最小化字符串长度</h1><blockquote>\n<p>给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。<br>数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。</p>\n<ul>\n<li>例如，s &#x3D; “EnjoyYourCoffee” 且 spaces &#x3D; [5, 9] ，那么我们需要在 ‘Y’ 和 ‘C’ 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 “Enjoy Your Coffee” 。<br>请你添加空格，并返回修改后的字符串。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105</li>\n<li>s 仅由大小写英文字母组成</li>\n<li>1 &lt;&#x3D; spaces.length &lt;&#x3D; 3 * 105</li>\n<li>0 &lt;&#x3D; spaces[i] &lt;&#x3D; s.length - 1</li>\n<li>spaces 中的所有值严格递增</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-8\"><a href=\"#解题思路-8\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>咳咳，虽然用时击败5%，但是自己写出来中等题而且没超时已经很棒了！夸夸自己😂</p>\n<h2 id=\"完整代码-8\"><a href=\"#完整代码-8\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string addSpaces(string s, vector&lt;int&gt;&amp; spaces) &#123;\n        int idx=0,cnt=0;\n        for(int i=0;i&lt;s.size();i++)&#123;\n            while(idx&lt;spaces.size())&#123;\n                s.insert(spaces[idx]+cnt,&quot; &quot;);\n                idx++;\n                cnt++;\n            &#125;\n        &#125;\n        return s;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2278-字母在字符串中的百分比\"><a href=\"#2278-字母在字符串中的百分比\" class=\"headerlink\" title=\"2278.字母在字符串中的百分比\"></a>2278.字母在字符串中的百分比</h1><blockquote>\n<p>给你一个字符串s和一个字符 letter，返回在s中等于letter字符所占的百分比，向下取整到最接近的百分比。</p>\n</blockquote>\n<h2 id=\"解题思路-9\"><a href=\"#解题思路-9\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我写的时候还很疑惑为什么返回的全是0😅然后意识到：<br><code>return (cnt/s.size())*100</code>这样合乎逻辑的写法实际上在这里是错误的。因为cnt&#x2F;s.size()是整数除法（会直接去掉小数部分），那就必&#x3D;0，然后0*100还是0，返回的也是0😂</p>\n<h2 id=\"完整代码-9\"><a href=\"#完整代码-9\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int percentageLetter(string s, char letter) &#123;\n        int cnt = 0;\n        for (char ch : s) &#123;\n            if (ch == letter) &#123;\n                cnt++;\n            &#125;\n        &#125;\n        return (cnt * 100) / s.size();  // 先乘 100 再除，确保整数除法不会丢失精度\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"168-Execl表列名称\"><a href=\"#168-Execl表列名称\" class=\"headerlink\" title=\"168.Execl表列名称\"></a>168.Execl表列名称</h1><blockquote>\n<p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p>\n</blockquote>\n<h2 id=\"解题思路-10\"><a href=\"#解题思路-10\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>上来看不明白这题，于是跑去看<a href=\"https://leetcode.cn/problems/excel-sheet-column-title/solutions/849680/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/\">题解</a>。</p>\n<p>这道题其实是一道类似于<strong>26进制</strong>的数字系统模拟。</p>\n<ol>\n<li><p>列名的构成<br>每个列名由字母组成，并且字母的排列规则类似于进制。比如 A 对应 1，B 对应 2，…，Z 对应 26。接着，列名会继续循环，例如 AA 对应 27，AB 对应 28，…</p>\n</li>\n<li><p>对应关系</p>\n</li>\n</ol>\n<ul>\n<li>第 1 列是 A（即 1）</li>\n<li>第 2 列是 B（即 2）</li>\n<li>…</li>\n<li>第 26 列是 Z（即 26）</li>\n<li>第 27 列是 AA（即 27），可以看做是从 A（1）到 Z（26）循环一次</li>\n</ul>\n<ol start=\"3\">\n<li>解题思路</li>\n</ol>\n<ul>\n<li>每次从最右边的字符开始计算</li>\n<li><strong>注意</strong> Excel 列名从A开始（1），而不是从0开始。所以每次取余的时-1。<br>1️⃣模拟进制转换</li>\n<li>每次对26取余，然后将结果映射到 A-Z</li>\n<li>然后columnNumber-1，类似于进制中的进位操作<br>2️⃣构建列名</li>\n<li>每次获得一个字符，将其加入列名的最前面，直到 columnNumber&#x3D;0</li>\n</ul>\n<h2 id=\"完整代码-10\"><a href=\"#完整代码-10\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string convertToTitle(int columnNumber) &#123;\n        string res=&quot;&quot;;\n        while(columnNumber&gt;0)&#123;\n            columnNumber--;\n            res=char(columnNumber%26+&#39;A&#39;)+res;\n            columnNumber/=26;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3396-使数组元素互不相同所需的最少操作次数\"><a href=\"#3396-使数组元素互不相同所需的最少操作次数\" class=\"headerlink\" title=\"3396.使数组元素互不相同所需的最少操作次数\"></a>3396.使数组元素互不相同所需的最少操作次数</h1><blockquote>\n<p>给你一个整数数组 nums，你需要确保数组中的元素 互不相同 。为此，你可以执行以下操作任意次：<br>从数组的开头移除 3 个元素。如果数组中元素少于 3 个，则移除所有剩余元素。<br>注意：空数组也视作为数组元素互不相同。返回使数组元素互不相同所需的 最少操作次数 。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-11\"><a href=\"#解题思路-11\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>说实话这道题真难到我了，虽然是道简单题。</p>\n<p>1️⃣<del>错误解法注意</del>一开始for循环遍历的同时修改容器：<br><code>for(int num:nums)</code>是range-based for loop（基于拷贝值的遍历），是基于nums的快照。但是我在遍历里用了<code>nums.erase(nums.begin(),nums.begin()+3)</code>会导致迭代器失效😂</p>\n<p>2️⃣修改方案：</p>\n<ol>\n<li><p>使用无限循环<br>直到剩下的数组已经互不相同（flag&#x3D;false）时跳出。</p>\n</li>\n<li><p>bool flag<br>表示当前数组是否有重复元素，初始值为false。</p>\n</li>\n<li><p>遍历nums<br>unordered_set<int>一个arr用来判断重复元素。这部分老操作了，上面有几道也是类似的做法。</p>\n<blockquote>\n<p>额外的就是要记得有重复元素时flag置为true</p>\n</blockquote>\n</li>\n<li><p>进行一次移除操作，计数器加一</p>\n</li>\n</ol>\n<ul>\n<li>剩余元素不足三个，直接清空nums</li>\n<li>否则删除begin()~begin()+3</li>\n</ul>\n<ol start=\"5\">\n<li>返回cnt</li>\n</ol>\n<h2 id=\"完整代码-11\"><a href=\"#完整代码-11\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minimumOperations(vector&lt;int&gt;&amp; nums) &#123;\n        int cnt=0;\n        while(true)&#123;\n            unordered_set&lt;int&gt; arr;\n            bool flag=false;\n            for(int num:nums)&#123;\n                if(arr.find(num)!=arr.end())&#123;\n                    flag=true;\n                    break;\n                &#125;\n                arr.insert(num);\n            &#125;\n            if(flag==false)&#123;\n                break;\n            &#125;\n            if(nums.size()&lt;=3)&#123;\n                nums.clear();\n            &#125;\n            else&#123;\n                nums.erase(nums.begin(),nums.begin()+3);\n            &#125;\n            cnt++;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"594-最长和谐子序列\"><a href=\"#594-最长和谐子序列\" class=\"headerlink\" title=\"594.最长和谐子序列\"></a>594.最长和谐子序列</h1><blockquote>\n<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。<br>给你一个整数数组nums，请你在所有可能的子序列中找到最长的和谐子序列的长度。<br>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104</li>\n<li>109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-12\"><a href=\"#解题思路-12\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>思路非原创。因为我一开始不知道子序列怎么得，所以跑去看<a href=\"https://leetcode.cn/problems/longest-harmonious-subsequence/solutions/1110137/zui-chang-he-xie-zi-xu-lie-by-leetcode-s-8cyr/\">题解</a>了，官方这里讲的很明了👍</p>\n<ol>\n<li>从小到大排序（直接sort即可）</li>\n<li>begin&#x2F;end控制头尾元素下标（我这里用的head&#x2F;tail）</li>\n<li>子序列长度end-begin+1</li>\n</ol>\n<h2 id=\"完整代码-12\"><a href=\"#完整代码-12\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        int head=0,tail=0,ans=0;\n        while(tail&lt;nums.size())&#123;\n            while(nums[tail]-nums[head]&gt;1)&#123;\n                head++;\n            &#125;\n            if(nums[tail]-nums[head]==1)&#123;\n                ans=max(ans,tail-head+1);\n            &#125;\n            tail++;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "算法",
                "字符串",
                "滑动窗口"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "url": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "title": "Leetcode数组",
            "date_published": "2025-03-04T11:15:05.000Z",
            "content_html": "<h1 id=\"912-排序数组\"><a href=\"#912-排序数组\" class=\"headerlink\" title=\"912.排序数组\"></a>912.排序数组</h1><blockquote>\n<p>给你一个整数数组 nums，请你将该数组升序排列。<br>你必须在 不使用任何内置函数 的情况下解决问题，时间复杂度为 O(nlog(n))，并且空间复杂度尽可能小。</p>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先来总结一下</p>\n<h3 id=\"十大排序算法\"><a href=\"#十大排序算法\" class=\"headerlink\" title=\"十大排序算法~\"></a><a href=\"https://www.runoob.com/w3cnote/ten-sorting-algorithm.html\">十大排序算法</a>~</h3><table>\n<thead>\n<tr>\n<th align=\"center\">排序算法</th>\n<th align=\"center\">「平均」时间复杂度</th>\n<th align=\"center\">「最坏」时间复杂度</th>\n<th align=\"center\">「最好」时间复杂度</th>\n<th align=\"center\">空间复杂度</th>\n<th align=\"center\">稳定性</th>\n<th align=\"center\">适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>冒泡排序</strong></td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据量小、基本有序</td>\n</tr>\n<tr>\n<td align=\"center\">选择排序</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">数据量小</td>\n</tr>\n<tr>\n<td align=\"center\">插入排序</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据量小、基本有序</td>\n</tr>\n<tr>\n<td align=\"center\">希尔排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlog^2n)</td>\n<td align=\"center\">O(nlog^2n)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">大数据</td>\n</tr>\n<tr>\n<td align=\"center\">归并排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">链表排序</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>快速排序</strong></td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">处理大数据最常用</td>\n</tr>\n<tr>\n<td align=\"center\">堆排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">优先队列</td>\n</tr>\n<tr>\n<td align=\"center\">计数排序</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(k)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据范围较小、整数分布集中</td>\n</tr>\n<tr>\n<td align=\"center\">桶排序</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据分布均匀</td>\n</tr>\n<tr>\n<td align=\"center\">基数排序</td>\n<td align=\"center\">O(n×k)</td>\n<td align=\"center\">O(n×k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">非比较排序</td>\n</tr>\n</tbody></table>\n<h3 id=\"其他总结\"><a href=\"#其他总结\" class=\"headerlink\" title=\"其他总结\"></a>其他总结</h3><p>1️⃣按稳定性分类<br>在排序前后，相等元素的相对顺序是否保持不变，如果相对顺序不变，则该排序算法是稳定的，否则是不稳定的。</p>\n<ul>\n<li><strong>稳定排序</strong>：冒泡&#x2F;插入&#x2F;归并&#x2F;基数</li>\n<li><strong>不稳定排序</strong>：选择&#x2F;快速&#x2F;堆</li>\n</ul>\n<p>2️⃣排序算法优劣的<a href=\"https://blog.csdn.net/2203_75646004/article/details/135172906\">衡量标准</a>：<br>🔹 <strong>时间复杂度</strong> 排序速度（比较&amp;移动次数）<br>🔹 <strong>空间复杂度</strong> 占内存辅助空间的大小<br>🔹 <strong>稳定性</strong> A与B的关键字相等，排序后A、B的先后次序保持不变</p>\n<p>3️⃣按排序类别分类</p>\n<ul>\n<li><strong>插入</strong>：插入&#x2F;希尔</li>\n<li><strong>选择</strong>：选择&#x2F;堆</li>\n<li><strong>交换</strong>：冒泡&#x2F;快速</li>\n<li><strong>归并</strong>：归并</li>\n<li><strong>基数</strong>：基数</li>\n</ul>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"1232-缀点成线\"><a href=\"#1232-缀点成线\" class=\"headerlink\" title=\"1232.缀点成线\"></a>1232.缀点成线</h1><blockquote>\n<p>给定一个数组 coordinates ，其中 coordinates[i] &#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n<ul>\n<li>2 &lt;&#x3D; coordinates.length &lt;&#x3D; 1000</li>\n<li>coordinates[i].length &#x3D;&#x3D; 2</li>\n<li>-10^4 &lt;&#x3D; coordinates[i][0], coordinates[i][1] &lt;&#x3D; 10^4</li>\n<li>coordinates 中不含重复的点</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我本来是想着soeasy，用y&#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…</p>\n<p>那么就不使用斜率，而是使用<strong>斜率交叉乘法</strong>：如果所有点都在同一条直线上，那么<strong>对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等</strong>。也就是<code>(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)</code>。为避免除法带来的浮点误差，用<strong>交叉相乘</strong>验证更好。<br><em><strong>并且注意！</strong></em><br>因为我的验证方法需要三个点，但是这道题有可<code>coordinates,length=2</code>的情况，那就直接返回true，因为<strong>两点确定一条直线</strong>。</p>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;\n        int x1,y1,x2,y2;\n        x1=coordinates[0][0];\n        y1=coordinates[0][1];\n        x2=coordinates[1][0];\n        y2=coordinates[1][1];\n        if(coordinates.size()==2)&#123;\n            return true;\n        &#125;\n        for(int i=2;i&lt;coordinates.size();i++)&#123;\n            int x3=coordinates[i][0];\n            int y3=coordinates[i][1];\n            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2597-美丽子集的数目\"><a href=\"#2597-美丽子集的数目\" class=\"headerlink\" title=\"2597.美丽子集的数目\"></a>2597.美丽子集的数目</h1><blockquote>\n<p>给你一个由正整数组成的数组 nums 和一个 正 整数 k 。<br>如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。<br>返回数组 nums 中 非空 且 美丽 的子集数目。<br>nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 18</li>\n<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>涉及<strong>子集</strong>相关问题，一般有两种方法：</p>\n<ul>\n<li>回溯</li>\n<li>位运算<br>本题选择<strong>回溯</strong>算法。因为该方法可在生成子集时<strong>剪枝</strong>。</li>\n</ul>\n<p>假设 nums &#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：</p>\n<pre><code>          dfs(0)\n        /        \\\n    不选2        选2\n     / \\         /  \\\n  不选4  选4   不选4  选4\n  ...\n</code></pre>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int ans=0;\n    void dfs(int index,vector&lt;int&gt;&amp; nums,unordered_map&lt;int,int&gt;&amp; freq,int k)&#123;\n        if(index==nums.size())&#123;\n            ans++;\n            return;\n        &#125;\n        dfs(index+1,nums,freq,k);\n        if(freq[nums[index]-k]==0 &amp;&amp; freq[nums[index]+k]==0)&#123;\n            freq[nums[index]]++;\n            dfs(index+1,nums,freq,k);\n            freq[nums[index]]--;\n        &#125;\n    &#125;\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int,int&gt; freq;\n        dfs(0,nums,freq,k);\n        return ans-1;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2070-每一个查询的最大美丽值\"><a href=\"#2070-每一个查询的最大美丽值\" class=\"headerlink\" title=\"2070.每一个查询的最大美丽值\"></a>2070.每一个查询的最大美丽值</h1><p>又美丽了家人们🤣</p>\n<blockquote>\n<p>给你一个二维整数数组 items ，其中 items[i] &#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。<br>同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。<br>请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>-1 &lt;&#x3D; items.length, queries.length &lt;&#x3D; 105<br>-items[i].length &#x3D;&#x3D; 2<br>-1 &lt;&#x3D; pricei, beautyi, queries[j] &lt;&#x3D; 109</p>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>首先复习一下二分查找，我又忘了咋写。<a href=\"https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/\">另一篇</a>copy来的</p>\n<blockquote>\n<ul>\n<li>要查找的目标<code>target</code></li>\n<li>索引<code>index</code></li>\n<li>左、右指示符<code>left</code>、<code>right</code></li>\n<li>中间指示符<code>mid</code><br>主要思路就是计算<code>mid</code>的位置：<br>1️⃣<code>nums[mid] == target</code> 🤭找到了<br>2️⃣<code>nums[mid] &lt; target</code> → target在left的右边 → left右移 👉️left&#x3D;mid+1;<br>3️⃣<code>nums[mid] &gt; target</code> → target在right的左边 → right左移 👉️right&#x3D;mid-1;</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-cpp\">//形参：vector&lt;int&gt;nums,int target\nint left=0;\nint right=nums.size()-1;\nwhile(left&lt;=right)&#123;\n    int mid=left+(right-left)/2;\n    if(nums[mid]=target)&#123;\n        return mid;\n    &#125;\n    else if(nums[mid]&lt;target)&#123;\n        left=mid+1;\n    &#125;\n    else&#123;\n        right=mid-1;\n    &#125;\n    return index;\n&#125;\n</code></pre>\n<h3 id=\"本题思路\"><a href=\"#本题思路\" class=\"headerlink\" title=\"本题思路\"></a>本题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a><em><strong>方法一</strong></em></h4><p>完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        vector&lt;int&gt; answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int maxnum=0;\n            for(int i=0;i&lt;items.size();i++)&#123;\n                if(items[i][0]&lt;=target)&#123;\n                    maxnum=max(maxnum,items[i][1]);\n                &#125;\n            &#125;\n            answer[j]=maxnum;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a><em><strong>方法二</strong></em></h4><p>老老实实用二分。注意：二分查找的前提是<strong>有序</strong>。</p>\n<ul>\n<li>先按照price递增排序;</li>\n<li>定义美丽数组;</li>\n<li>遍历items:<strong>存储当前遍历到的最大美丽值</strong>;</li>\n<li>定义答案数组;</li>\n<li>遍历querties：<strong>二分查找</strong></li>\n</ul>\n<p>二分查找目标🤟<code>items[i][0] &lt;= queries[j]</code> 的最大 i<br>有点绕了，兄弟兄弟…</p>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        sort(items.begin(),items.end());\n        vector&lt;int&gt;maxbeauty(items.size());\n        maxbeauty[0]=items[0][1];\n        for(int i=1;i&lt;items.size();i++)&#123;\n            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);\n        &#125;\n        vector&lt;int&gt;answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int left=0;\n            int right=items.size()-1;\n            int index=-1;\n            while(left&lt;=right)&#123;\n                int mid=left+(right-left)/2;\n                if(items[mid][0]&lt;=target)&#123;\n                    index=mid;\n                    left=mid+1;\n                &#125;\n                else&#123;\n                    right=mid-1;\n                &#125;\n            &#125;\n            if(index!=-1)&#123;\n                answer[j]=maxbeauty[index];\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><blockquote>\n<p>给你一个下标从0开始的整数数组nums。对于每个下标i（1 &lt;&#x3D; i &lt;&#x3D; nums.length - 2），nums[i] 的美丽值等于：<br>2，对于所有 0 &lt;&#x3D; j &lt; i 且 i &lt; k &lt;&#x3D; nums.length - 1 ，满足 nums[j] &lt; nums[i] &lt; nums[k]<br>1，如果满足 nums[i - 1] &lt; nums[i] &lt; nums[i + 1] ，且不满足前面的条件<br>0，如果上述条件全部不满足<br>返回符合 1 &lt;&#x3D; i &lt;&#x3D; nums.length - 2 的所有 nums[i] 的美丽值的总和。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>3 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>难点在于nums[i]的美丽值为2的情况：</strong><br>突然想起来高中数学老师的口头禅：“大于大的，小于小的”。<br>nums[i]需要满足：比其左侧所有的nums[j]更大，以及<em>比其右侧所有的nums</em>[k]更小。<br>即<strong>大于左侧最大值，小于右侧最小值</strong>。</p>\n<ul>\n<li><code>*max_element(arr.begin(),arr.end())</code>求数组最大值</li>\n<li><code>*min_element(arr.begin(),arr.end())</code>求数组最小值</li>\n</ul>\n<p>？超时了😇我还说想清楚了不难呢…</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int sumOfBeauties(vector&lt;int&gt;&amp; nums) &#123;\n        int maxval,minval,ans=0;\n        for(int i=1;i&lt;nums.size()-1;i++)&#123;\n            maxval=*max_element(nums.begin(),nums.begin()+i);\n            minval=*min_element(nums.begin()+i+1,nums.end());\n            if(maxval&lt;nums[i] &amp;&amp; minval&gt;nums[i])&#123;\n                ans+=2;\n            &#125;\n            else if(nums[i-1]&lt;nums[i] &amp;&amp; nums[i+1]&gt;nums[i])&#123;\n                ans+=1;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>改进方法就是：左侧最大值和右侧最小值各自都用一个数组存起来所有i的情况，再进行条件判断。同时可以存一个，另一个随每次判断进行更新就好。</p>\n<pre><code>定义左侧最大int数组leftMax;\n遍历i从1到nums.size()：\n    leftMax[i]=max(左侧最大数组[i-1],原数组[i-1]);\nint 美丽值;\n定义右侧最小int变量rightMin并初始化为原数组[length()-1];\n遍历i从length()-2到0:\n    如果（条件一）：\n        美丽值+=2;\n    否则如果（条件2）：\n        美丽值+=1;\n    更新右侧最小值=min（右侧最小值，原数组[i]）;\n返回美丽值\n</code></pre>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int sumOfBeauties(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; leftMax(nums.size(),0);\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            leftMax[i]=max(leftMax[i-1],nums[i-1]);\n        &#125;\n        int ans=0;\n        int rightMin=nums[nums.size()-1];\n        for(int i=nums.size()-2;i&gt;0;i--)&#123;\n            if(leftMax[i]&lt;nums[i] &amp;&amp; nums[i]&lt;rightMin)&#123;\n                ans+=2;\n            &#125;\n            else if(nums[i-1]&lt;nums[i] &amp;&amp; nums[i]&lt;nums[i+1])&#123;\n                ans+=1;\n            &#125;\n            rightMin=min(rightMin,nums[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"杨辉三角（一维数组版）\"><a href=\"#杨辉三角（一维数组版）\" class=\"headerlink\" title=\"杨辉三角（一维数组版）\"></a>杨辉三角（一维数组版）</h1><h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-c\">void Print_TR(int n)&#123;\n    int arr[n]=&#123;1&#125;;\n    for(int i=0;i&lt;n;i++)&#123;\n        for(int j=i;j&gt;0;j--)&#123;\n            arr[j]+=arr[j-1];\n        &#125;\n        //打印\n        for(int j=0;j&lt;=i;j++)&#123;\n            printf(&quot;%d &quot;,arr[j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"2610-转换二维数组\"><a href=\"#2610-转换二维数组\" class=\"headerlink\" title=\"2610.转换二维数组\"></a>2610.转换二维数组</h1><blockquote>\n<p>给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组：</p>\n<ul>\n<li>二维数组应该 只 包含数组 nums 中的元素。</li>\n<li>二维数组中的每一行都包含 不同 的整数。</li>\n<li>二维数组的行数应尽可能 少 。<br>返回结果数组。如果存在多种答案，则返回其中任何一种。<br>请注意，二维数组的每一行上可以存在不同数量的元素。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums.length</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>用<strong>哈希表</strong>！😎统计元素出现次数，定义一个一维数组存每行元素。每用一个元素。哈希表中该元素次数–（当次数为0时）从表中删除该元素。</p>\n<p>这里看题解 涉及到stl<strong>迭代器</strong><code>it</code>的用法：对于定义一个哈希表:<code>unordered_map&lt;int,int&gt;cnt</code></p>\n<ul>\n<li>当用<code>auto:it</code>遍历<code>cnt.begin()</code>到<code>!=cnt.end()</code>时</li>\n<li><code>it-&gt;first</code>即为哈希表键值对(key,value)中的<code>key</code>。本题中即为<strong>元素本身</strong></li>\n<li><code>it-&gt;second</code>即为哈希表键值对(key,value)中的<code>value</code>。本题中即为元素的<strong>出现次数</strong></li>\n</ul>\n<h2 id=\"完整代码-6\"><a href=\"#完整代码-6\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>感谢<a href=\"https://leetcode.cn/u/endlesscheng/\">灵神</a>题解，教会我很多</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findMatrix(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_map&lt;int,int&gt; cnt;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        for(int x:nums)&#123;\n            cnt[x]++;\n        &#125;\n        while(!cnt.empty())&#123;\n            vector&lt;int&gt;row;\n            for(auto it=cnt.begin();it!=cnt.end();)&#123;\n                row.push_back(it-&gt;first);\n                if(--it-&gt;second==0)&#123;\n                    it=cnt.erase(it);\n                &#125;\n                else&#123;\n                    it++;\n                &#125;\n            &#125;\n            ans.push_back(row);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2643-一最多的行\"><a href=\"#2643-一最多的行\" class=\"headerlink\" title=\"2643.一最多的行\"></a>2643.一最多的行</h1><blockquote>\n<p>给你一个大小为 m x n 的二进制矩阵 mat ，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。<br>如果有多行包含最多的 1 ，只需要选择 行下标最小 的那一行。<br>返回一个由行下标和该行中 1 的数量组成的数组。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>m &#x3D;&#x3D; mat.length </li>\n<li>n &#x3D;&#x3D; mat[i].length </li>\n<li>1 &lt;&#x3D; m, n &lt;&#x3D; 100 </li>\n<li>mat[i][j] 为 0 或 1</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>最轻松的一集😂但是我写的代码略史山，还有优化空间。</p>\n<h2 id=\"完整代码-7\"><a href=\"#完整代码-7\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>这里直接用<code>int ones = count(mat[i].begin(), mat[i].end(), 1); </code>统计1的个数可以减少一次遍历。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; rowAndMaximumOnes(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;\n        vector&lt;int&gt; cnt(100,0),ans;\n        int index=0;\n        for(int i=0;i&lt;mat.size();i++)&#123;\n            for(int j=0;j&lt;mat[i].size();j++)&#123;\n                if(mat[i][j]==1)&#123;\n                    cnt[i]++;\n                &#125;\n            &#125;\n        &#125;\n        int maxnum=cnt[0];\n        for(int i=0;i&lt;cnt.size();i++)&#123;\n            if(cnt[i]&gt;maxnum)&#123;\n                maxnum=cnt[i];\n                index=i;\n            &#125;\n        &#125;\n        ans.push_back(index);\n        ans.push_back(cnt[index]);\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"661-图片平滑器\"><a href=\"#661-图片平滑器\" class=\"headerlink\" title=\"661.图片平滑器\"></a>661.图片平滑器</h1><blockquote>\n<p><strong>图像平滑器</strong>是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。<br>每个单元格的<strong>平均灰度</strong>定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。<br>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。<br>给你一个表示图像灰度的<code>m x n</code>整数矩阵<code>img</code>，返回对图像的每个单元格平滑处理后的图像 。</p>\n</blockquote>\n<blockquote>\n<p>提示:</p>\n<ul>\n<li>m &#x3D;&#x3D; img.length</li>\n<li>n &#x3D;&#x3D; img[i].length</li>\n<li>1 &lt;&#x3D; m, n &lt;&#x3D; 200</li>\n<li>0 &lt;&#x3D; img[i][j] &lt;&#x3D; 255</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>关键知道矩阵边界，也就是不全加9个数的情况怎么算。我一开始还想着一个个情况穷举😂其实3*3区域安心两层遍历就行，对于这道题不会超时。<br>***刷题以来第一次碰到四层循环能通过的。。。***不看题解都不敢想像这个方法。</p>\n<h2 id=\"完整代码-8\"><a href=\"#完整代码-8\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; img) &#123;\n        int m,n;\n        m=img.size();\n        n=img[0].size();\n        vector&lt;vector&lt;int&gt;&gt;ans(m,vector&lt;int&gt;(n,0));\n        for(int i=0;i&lt;m;i++)&#123;\n            for(int j=0;j&lt;n;j++)&#123;\n                int sum,cnt;\n                sum=cnt=0;\n                for(int r=i-1;r&lt;=i+1;r++)&#123;\n                    for(int c=j-1;c&lt;=j+1;c++)&#123;\n                        if(0&lt;=r &amp;&amp; r&lt;m &amp;&amp; 0&lt;=c &amp;&amp; c&lt;n)&#123;\n                            sum+=img[r][c];\n                            cnt++;\n                        &#125;\n                    &#125;\n                &#125;\n                ans[i][j]=cnt&gt;0?sum/cnt:img[i][j];\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"27171-对角线上不同值的数量差\"><a href=\"#27171-对角线上不同值的数量差\" class=\"headerlink\" title=\"27171.对角线上不同值的数量差\"></a>27171.对角线上不同值的数量差</h1><blockquote>\n<p>给你一个下标从 0 开始、大小为 m x n 的二维矩阵 grid ，请你求解大小同样为 m x n 的答案矩阵 answer 。<br>矩阵 answer 中每个单元格 (r, c) 的值可以按下述方式进行计算：<br>令 topLeft[r][c] 为矩阵 grid 中单元格 (r, c) 左上角对角线上 不同值 的数量。<br>令 bottomRight[r][c] 为矩阵 grid 中单元格 (r, c) 右下角对角线上 不同值 的数量。<br>然后 answer[r][c] &#x3D; |topLeft[r][c] - bottomRight[r][c]| 。<br>返回矩阵 answer 。<br>矩阵对角线 是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。<br>如果单元格 (r1, c1) 和单元格 (r, c) 属于同一条对角线且 r1 &lt; r ，则单元格 (r1, c1) 属于单元格 (r, c) 的左上对角线。类似地，可以定义右下对角线。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>m &#x3D;&#x3D; grid.length</li>\n<li>n &#x3D;&#x3D; grid[i].length</li>\n<li>1 &lt;&#x3D; m, n, grid[i][j] &lt;&#x3D; 50</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-8\"><a href=\"#解题思路-8\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>几个地方思考的时候容易卡住：</p>\n<p>1️⃣<strong>不同值是什么意思？</strong><br>我一开始理解的是对于grid[i][j]，它的左对角线上和它不同的元素数量叫做topleft，右对角线上和它不同的元素数量叫做bottomright，然后就自以为大彻大悟☝️🤓<del>美美去打代码然后寄了</del>。</p>\n<p>个人理解中，实际上这里的不同值的意思是：对于这半拉对角线上的所有元素而言的<strong>种类</strong>数量。</p>\n<ul>\n<li>比如全是1，那就1种，topleft&#x3D;1；</li>\n<li>如果有1有0，那就是2种，topleft&#x3D;2。<br>右对角线同理.</li>\n</ul>\n<p>2️⃣<strong>如何统计“不同值”？</strong><br>这里选用基于红黑树的std::set而不是之前我们常用的unordered_map。因为对于本题，只需要判断「是否不同」而不需要记录「不同的次数」。<br>对于set<int>myset 而言：</p>\n<ul>\n<li>如果rfind.find(grid[r][c])&#x3D;&#x3D;rfind.end()即为不同值</li>\n<li>新的不同值用myset.insert()添加</li>\n<li>myset.size()获得不同值的数量</li>\n</ul>\n<h2 id=\"完整代码-9\"><a href=\"#完整代码-9\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; differenceOfDistinctValues(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int m,n;\n        m=grid.size();\n        n=grid[0].size();\n        vector&lt;vector&lt;int&gt;&gt; answer(m,vector&lt;int&gt;(n,0));\n        for(int i=0;i&lt;m;i++)&#123;\n            for(int j=0;j&lt;n;j++)&#123;\n                int lcnt,rcnt;\n                lcnt=rcnt=0;\n                set&lt;int&gt; lfind,rfind;\n                //左对角线\n                int r=i-1;\n                int c=j-1;\n                while(r&gt;=0 &amp;&amp; c&gt;=0)&#123;\n                    if(「」)&#123;\n                        lcnt++;\n                    &#125;\n                    lfind.insert(grid[r][c]);\n                    r--;\n                    c--;\n                &#125;\n                //右对角线\n                r=i+1;\n                c=j+1;\n                while(r&lt;m &amp;&amp; c&lt;n)&#123;\n                    if(rfind.find(grid[r][c])==rfind.end())&#123;\n                        rcnt++;\n                    &#125;\n                    rfind.insert(grid[r][c]);\n                    r++;\n                    c++;\n                &#125;\n                answer[i][j]=abs(lcnt-rcnt);\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3375-使数组的值全部为K的最少操作次数\"><a href=\"#3375-使数组的值全部为K的最少操作次数\" class=\"headerlink\" title=\"3375.使数组的值全部为K的最少操作次数\"></a>3375.使数组的值全部为K的最少操作次数</h1><blockquote>\n<p>给你一个整数数组 nums 和一个整数 k 。<br>如果一个数组中所有 严格大于 h 的整数值都 相等 ，那么我们称整数 h 是 合法的 。<br>比方说，如果 nums &#x3D; [10, 8, 10, 8] ，那么 h &#x3D; 9 是一个 合法 整数，因为所有满足 nums[i] &gt; 9 的数都等于 10 ，但是 5 不是 合法 整数。<br>你可以对 nums 执行以下操作：<br>选择一个整数 h ，它对于 当前 nums 中的值是合法的。<br>对于每个下标 i ，如果它满足 nums[i] &gt; h ，那么将 nums[i] 变为 h 。<br>你的目标是将 nums 中的所有元素都变为 k ，请你返回 最少 操作次数。如果无法将所有元素都变 k ，那么返回 -1 。</p>\n</blockquote>\n<h2 id=\"解题思路-9\"><a href=\"#解题思路-9\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>呃(⊙﹏⊙)自认为语文水平还不错，但是这题目着实看不懂…</p>\n<p>看了评论区&amp;题解佬们的耐心讲解，我浅总结一下：</p>\n<ol>\n<li>函数返回<br>返回<strong>将nums所有元素变为k</strong>的最少操作次数，变不了返回-1。</li>\n<li>元素变k的前提<br>nums中&gt;k的所有元素都相等，将这些元素全变为k。</li>\n<li>无法满足返回-1是什么情况<br>如果nums中但凡有元素小于k，那么一定不中。</li>\n<li>最少操作次数<br><del>关键来了</del>数组中所有大于k的元素种类。对，就这样就行😅</li>\n</ol>\n<h2 id=\"完整代码-10\"><a href=\"#完整代码-10\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minOperations(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int cnt=0;\n        unordered_set&lt;int&gt;hashset;\n        for(int num:nums)&#123;\n            if(num&lt;k)&#123;\n                return -1;\n            &#125;\n            else&#123;\n                if(hashset.find(num)==hashset.end() &amp;&amp; num&gt;k)&#123;\n                    hashset.insert(num);\n                    cnt++;\n                &#125;\n            &#125;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2563-统计公平数对的数目\"><a href=\"#2563-统计公平数对的数目\" class=\"headerlink\" title=\"2563.统计公平数对的数目\"></a>2563.统计公平数对的数目</h1><blockquote>\n<p>给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。<br>如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：</p>\n<ul>\n<li>0 &lt;&#x3D; i &lt; j &lt; n，且</li>\n<li>lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>nums.length &#x3D;&#x3D; n</li>\n<li>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>\n<li>-109 &lt;&#x3D; lower &lt;&#x3D; upper &lt;&#x3D; 109</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-10\"><a href=\"#解题思路-10\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>PS：因为实习鸽了五个工作日的我想了想又苟回来日更辣！！！现在是2025年4月19！等做到1000题再停更，主打一个保持编码的思维和手感😼<del>毕竟斥巨资开了力扣年卡不写一年也太亏了</del></p>\n<h2 id=\"完整代码-11\"><a href=\"#完整代码-11\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n",
            "tags": [
                "力扣",
                "数组",
                "哈希表",
                "二分查找"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/04/%E4%B8%93%E9%A2%982-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/",
            "url": "https://232akira.github.io/2025/03/04/%E4%B8%93%E9%A2%982-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/",
            "title": "专题2️⃣ 贪心算法",
            "date_published": "2025-03-04T05:41:46.000Z",
            "content_html": "<p>力扣连着刷到了几个贪心，而且另一篇笔记字数要爆了，决定先按大类慢慢分一下。<br>🤟<a href=\"https://zhuanlan.zhihu.com/p/180104885\">参考链接</a><br>规律特征就是更加注重当前的状态,通常用于组合优化问题。即每一次都做出<strong>当前</strong>看起来<strong>最好的</strong>选择。每次只需要考虑一个问题，并通常是自底向上求解。即<strong>局部最优→全局最优</strong>。</p>\n<h1 id=\"455-分发饼干\"><a href=\"#455-分发饼干\" class=\"headerlink\" title=\"455.分发饼干\"></a>455.分发饼干</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><h1 id=\"976-三角形的最大周长\"><a href=\"#976-三角形的最大周长\" class=\"headerlink\" title=\"976.三角形的最大周长\"></a>976.三角形的最大周长</h1><blockquote>\n<p>给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。</p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 104</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 106</code></li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>因为题目需要的是最大的三角形周长，所以不需要暴力列举所有的情况再一一对比，而是直接奔着“最大”这个目标求解就行:<br>三条边a,b,c（假设从小到大已排好），当a+b&gt;c时满足三角形。<strong>如果不满足，必须换更大的a,b</strong>。<br>贪心优化策略：</p>\n<ul>\n<li>nums排序</li>\n<li>从最大的三个数开始 尝试是否满足</li>\n<li>若无法满足，往前找更小的a,b</li>\n<li>一旦找到符合条件的三边，直接返回</li>\n</ul>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i&gt;=2;i++)&#123;\n            if(nums[i-1]+nums[i-2]&gt;nums[i])\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"860-柠檬水找零\"><a href=\"#860-柠檬水找零\" class=\"headerlink\" title=\"860.柠檬水找零\"></a>860.柠檬水找零</h1><blockquote>\n<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>\n<ul>\n<li><code>1 &lt;= bills.length &lt;= 105</code></li>\n<li><code>bills[i] 不是 5 就是 10 或是 20 </code></li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>**找零时，尽量先用大额。**并且只记录5美元、10美元的数量（因为这题目的情况不可能找20块）那么</p>\n<ul>\n<li>收到5美元  直接收 </li>\n<li>收到10美元 <code>10-5=5</code> 找5美元（如果有）</li>\n<li>收到20美元 <strong>贪心来了~</strong><code>20-5=15</code>优先使用10+5找零，否则用5+5+5（如果有）</li>\n</ul>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;\n        int five=0,ten=0;\n        for(int bill:bills)&#123;\n            if(bill==5)&#123;\n                five++;\n            &#125;\n            else if(bill==10)&#123;\n                if(five!=0)&#123;\n                    five--;\n                    ten++;\n                &#125;\n                else&#123;\n                    return false;\n                &#125;\n            &#125;\n            else if(bill==20)&#123;\n                if(ten&gt;0 &amp;&amp; five&gt;0)&#123;\n                    ten--;\n                    five--;\n                &#125;\n                else if(five&gt;=3)&#123;\n                    five-=3;\n                &#125;\n                else&#123;\n                    return false;\n                &#125;\n                \n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2680-最大或值\"><a href=\"#2680-最大或值\" class=\"headerlink\" title=\"2680.最大或值\"></a>2680.最大或值</h1><blockquote>\n<p>给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 k 。每一次操作中，你可以选择一个数并将它乘 2 。<br>你最多可以进行 k 次操作，请你返回 nums[0] | nums[1] | … | nums[n - 1] 的最大值。<br>a | b 表示两个整数 a 和 b 的 按位或 运算。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>\n<li>1 &lt;&#x3D; k &lt;&#x3D; 15</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>做了这么几道中等题，发现很多难就难在变量大的时候怎么才能不超时的问题上😂</p>\n<p>因此要注意：<br><em><strong>👉️按位或（|）的特性</strong></em>（二进制数）某一位只要有一个是1，按位或的结果该位就是1。<br>题目需要按位或的最大值，那么也就意味着尽量让高位变成1。</p>\n<p><em><strong>👉️不能直接暴力枚举</strong></em>否则会超时。</p>\n<p><em><strong>🔍️按位运算总结</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运算</th>\n<th align=\"center\">运算符</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">按位与</td>\n<td align=\"center\"><code>&amp;</code></td>\n<td align=\"center\">两位都是1，结果才是1</td>\n<td align=\"center\"><code>5 &amp; 3 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">按位或</td>\n<td align=\"center\"><code>一竖杠</code></td>\n<td align=\"center\">只要有一个是1，结果就是1</td>\n<td align=\"center\"><code>5 或 3 = 7</code></td>\n</tr>\n<tr>\n<td align=\"center\">按位异或</td>\n<td align=\"center\"><code>^</code></td>\n<td align=\"center\">相同为0，不同为1</td>\n<td align=\"center\"><code>5 ^ 3 = 6</code></td>\n</tr>\n<tr>\n<td align=\"center\">按位取反</td>\n<td align=\"center\"><code>~</code></td>\n<td align=\"center\">0变1，1变0</td>\n<td align=\"center\"><code>~5 = -6</code>（补码）</td>\n</tr>\n<tr>\n<td align=\"center\">左移</td>\n<td align=\"center\"><code>&lt;&lt;</code></td>\n<td align=\"center\">乘2^k</td>\n<td align=\"center\"><code>5 &lt;&lt; 1 = 10</code></td>\n</tr>\n<tr>\n<td align=\"center\">右移</td>\n<td align=\"center\"><code>&gt;&gt;</code></td>\n<td align=\"center\">除2^k</td>\n<td align=\"center\"><code>5 &gt;&gt; 1 = 2</code></td>\n</tr>\n</tbody></table>\n<p>解决方案：<br><strong>1️⃣预计算最初的或值</strong></p>\n<ul>\n<li><code>orsum|=num</code></li>\n</ul>\n<p><strong>2️⃣按位或最大化</strong></p>\n<ul>\n<li>遍历nums，对每个num[i]进行优化</li>\n<li>假设nums[i]被选中，*2^k，计算新的或值</li>\n<li>对于已经选定的nums[i]，<code>0~i-1</code>的或值设为<code>leftor</code>;<code>i+1~n-1</code>的或值设为<code>rightor</code>。那么新的或值只需要让<code>leftor | nums[i]*2^k | rightor</code>即可。</li>\n<li>nums[i]*2^k用<code>nums[i] * (1LL &lt;&lt; k)</code>。表示位运算中的左移操作，让nums[i]的二进制向左移动k位右侧补零，等价于<code>*2^k</code>（这里可以自己试一试：<code>5&lt;&lt;3</code>等价于<code>40=5*8</code>。）；LL防止溢出。</li>\n</ul>\n<p><strong>🆗其他问题</strong></p>\n<ul>\n<li>为什么 <code>left[i+1] = left[i] | nums[i]</code>，<code>right[i] = right[i+1] | nums[i]</code>？<br>按位或计算有个特点：计算或值具有单调性，也就是a|b|c的结果一定不会比a|b小。<br><code>left[i]</code>存的是nums[0]~nums[1]的或值，又因为left[i+1]相比left[i]需要加入nums[i]进行或值运算，所以<code>left[i+1] = left[i] | nums[i]</code>；<code>right[i]</code>同理。</li>\n</ul>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long maximumOr(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n=nums.size();\n        vector&lt;long long&gt; left(n+1,0),right(n+1,0);\n        for(int i=0;i&lt;n;i++)&#123;\n            left[i+1]=left[i]|nums[i];\n        &#125;\n        for(int i=n-1;i&gt;=0;i--)&#123;\n            right[i]=right[i+1]|nums[i];\n        &#125;\n        long long maxor=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            long long newor;\n            newor=left[i]|(nums[i]*(1LL&lt;&lt;k))|right[i+1];\n            maxor=max(maxor,newor);\n        &#125;\n        return maxor;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2829-k-avoiding数组的最小总和\"><a href=\"#2829-k-avoiding数组的最小总和\" class=\"headerlink\" title=\"2829.k-avoiding数组的最小总和\"></a>2829.k-avoiding数组的最小总和</h1><blockquote>\n<p>给你两个整数 n 和 k 。<br>对于一个由 不同 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 k-avoiding 数组。<br>返回长度为 n 的 k-avoiding 数组的可能的最小总和。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; n, k &lt;&#x3D; 50</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li><strong>数组总和最小</strong><br>从<code>1</code>开始逐步添加符合条件的数字，直到数组长度达到<code>n</code></li>\n<li><strong>避免和为k</strong><br>尝试加入<code>x</code>时，确保数组中不存在<code>k-x</code></li>\n</ol>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minimumSum(int n, int k) &#123;\n        vector&lt;int&gt; ans;\n        unordered_set&lt;int&gt; used;\n        int num=1;\n        while(ans.size()&lt;n)&#123;\n            if(used.find(k-num)==used.end())&#123;\n                ans.push_back(num);\n                used.insert(num);\n            &#125;\n            num++;\n        &#125;\n        return accumulate(ans.begin(),ans.end(),0);\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2712-使所有字符相等的最小成本\"><a href=\"#2712-使所有字符相等的最小成本\" class=\"headerlink\" title=\"2712.使所有字符相等的最小成本\"></a>2712.使所有字符相等的最小成本</h1><blockquote>\n<p>给你一个下标从 0 开始、长度为 n 的二进制字符串 s ，你可以对其执行两种操作：</p>\n<ul>\n<li>选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。</li>\n<li>选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。<br>返回使字符串内所有字符 相等 需要的 最小成本 。<br>反转字符意味着：如果原来的值是 ‘0’ ，则反转后值变为 ‘1’ ，反之亦然。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length &#x3D;&#x3D; n &lt;&#x3D; 105</li>\n<li>s[i] 为 ‘0’ 或 ‘1’</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li><strong>所有字符相等</strong></li>\n</ol>\n<ul>\n<li>全<code>1</code></li>\n<li>全<code>0</code></li>\n</ul>\n<ol start=\"2\">\n<li><strong>对于<code>i</code>，反转的成本</strong></li>\n</ol>\n<ul>\n<li>反转前缀<code>[0,i]</code>，成本<code>i+1</code></li>\n<li>反转后缀<code>[i,n-1]</code>，成本<code>n-i</code></li>\n</ul>\n<ol start=\"3\">\n<li><strong>核心问题</strong><br>对每个i，求出 min（s全1）和min（s全0），再对二者求min。<br>说人话就是：从0开始遍历，如果<code>s[i] ≠ s[i+1]</code>，那么我们此时有两种选择：反转前缀[0,i] 或 反转后缀[i,n-1]。对于每一个这样需要反转的i，我们选择反转前缀还是后缀的原则就是<strong>哪个成本小选哪个</strong>。最后得到的总成本也必然最小。</li>\n</ol>\n<p>👉️难理解的部分：<code>min(i,n-i)</code> 或 <code>min(i+1,n-i-1)</code>。<br>个人理解是因为对于此算法，实际上的分界点在s[i]和s[i+1]之间。也就是说：修正分界点需要做的是</p>\n<ul>\n<li>反转0~i</li>\n<li>反转i+1~n-1<br>这样求得的min才能保证达到我们“最小成本”的目标。</li>\n</ul>\n<p>👉️这里学到一个小知识：s.size()返回的类型为<strong>无符号整数（unsigned int）</strong></p>\n<blockquote>\n<ul>\n<li><code>size_t</code>无符号整型 (unsigned)</li>\n</ul>\n<ol>\n<li>是C++标准库中专门用于表示数组、容器的大小或索引的类型</li>\n<li>不能表示负数</li>\n<li>在 64 位系统上，size_t通常是unsigned long，比int更大，可表示更大的范围。</li>\n</ol>\n<ul>\n<li><code>int</code>有符号整型 (signed)</li>\n</ul>\n<ol>\n<li>是C++默认的整数类型，可以存储正数、负数和 0。</li>\n<li>取值范围一般是 [-2³¹, 2³¹ - 1]（32位系统） 或 [-2⁶³, 2⁶³ - 1]（64位系统）<br><em><strong>更适合存储一般的计数、索引、数学运算，而size_t主要用于数组大小和内存管理。</strong></em></li>\n</ol>\n</blockquote>\n<h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long minimumCost(string s) &#123;\n        long long int sum=0;\n        int n=s.size();\n        for(int i=0;i&lt;n-1;i++)&#123;\n            if(s[i]!=s[i+1])&#123;\n                sum+=min(i+1,n-i-1);\n            &#125;\n        &#125;\n        return sum;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"11-盛最多水的容器\"><a href=\"#11-盛最多水的容器\" class=\"headerlink\" title=\"11.盛最多水的容器\"></a>11.盛最多水的容器</h1><blockquote>\n<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>n &#x3D;&#x3D; height.length</li>\n<li>2 &lt;&#x3D; n &lt;&#x3D; 105</li>\n<li>0 &lt;&#x3D; height[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>莫名想起接雨水（？😅一眼做不出来，上<a href=\"https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/\">题解</a>。</p>\n<ol>\n<li>哪里贪心？<br> <a href=\"https://leetcode.cn/u/teaven/\">评论</a>佬的解释：永远找最高和最远的柱子，局部最优推出全局最优。双指针的解法存在遗漏，但对全局最优解无影响。</li>\n<li>双指针的解法本质：缩减搜索空间。</li>\n<li>排除i&#x2F;j的配对可能性：</li>\n</ol>\n<ul>\n<li>i和j相遇算法结束；</li>\n<li>对于两边指针i、j，如果移动其中一边，那么新的容器h一定 不大于 另一边的柱子高度；</li>\n<li>收缩过程中，配对的h较低一方的柱子必定被舍弃所有可能，该位置指针向中间收缩。</li>\n</ul>\n<h2 id=\"完整代码-6\"><a href=\"#完整代码-6\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>单看代码理解应该也没问题，这道题知道思路后写起来是无压力的。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) &#123;\n        int left,right;\n        left=0;\n        right=height.size()-1;\n        int ans=0;\n        while(left&lt;right)&#123;\n            int h=height[left]&lt;height[right]?height[left]:height[right];\n            ans=max(ans,(right-left)*h);\n            if(height[left]&lt;height[right])&#123;\n                left++;\n            &#125;\n            else&#123;\n                right--;\n            &#125;           \n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "专题",
                "C++"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/",
            "url": "https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/",
            "title": "力扣备忘录",
            "date_published": "2025-03-02T11:55:55.000Z",
            "content_html": "<p>一些问题总结和标签比较杂、没有分类的题目会放到这篇。</p>\n<h1 id=\"基础算法问题\"><a href=\"#基础算法问题\" class=\"headerlink\" title=\"基础算法问题\"></a>基础算法问题</h1><p>这些题听着老熟了，一到写起来就主打一个略有耳闻🫠</p>\n<h2 id=\"题目一览\"><a href=\"#题目一览\" class=\"headerlink\" title=\"题目一览\"></a>题目一览</h2><p>省流表👇️</p>\n<blockquote>\n<p>题目并非只有表中那几个，可在<a href=\"https://leetcode.cn/problemset/\">此页</a>自行筛选。</p>\n</blockquote>\n<h3 id=\"1️⃣数组与数学类\"><a href=\"#1️⃣数组与数学类\" class=\"headerlink\" title=\"1️⃣数组与数学类\"></a><strong>1️⃣数组与数学类</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体 &#x2F; 要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">杨辉三角</td>\n<td align=\"center\"><code>[118/119]</code></td>\n<td align=\"center\">一维数组</td>\n</tr>\n<tr>\n<td align=\"center\">斐波那契数列</td>\n<td align=\"center\"><code>[509]</code></td>\n<td align=\"center\">爬楼梯问题<code>[70]</code>&#x2F;递归&#x2F;迭代&#x2F;动态规划</td>\n</tr>\n<tr>\n<td align=\"center\">两数之和</td>\n<td align=\"center\"><code>[1]</code></td>\n<td align=\"center\">哈希表优化时间复杂度到O(n)</td>\n</tr>\n<tr>\n<td align=\"center\">合并两个有序数组</td>\n<td align=\"center\"><code>[88]</code></td>\n<td align=\"center\">原地合并（从后向前填充）</td>\n</tr>\n<tr>\n<td align=\"center\">最大子数组和</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">动态规划</td>\n</tr>\n</tbody></table>\n<h3 id=\"2️⃣字符串操作类\"><a href=\"#2️⃣字符串操作类\" class=\"headerlink\" title=\"2️⃣字符串操作类\"></a><strong>2️⃣字符串操作类</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">反转字符串</td>\n<td align=\"center\"><code>[344]</code></td>\n<td align=\"center\">原地修改（双指针）</td>\n</tr>\n<tr>\n<td align=\"center\">有效的括号</td>\n<td align=\"center\"><code>[20]</code></td>\n<td align=\"center\">用栈实现括号匹配</td>\n</tr>\n<tr>\n<td align=\"center\">最长公共前缀</td>\n<td align=\"center\"><code>[14]</code></td>\n<td align=\"center\">纵向扫描&#x2F;分治</td>\n</tr>\n<tr>\n<td align=\"center\">字符串转整数</td>\n<td align=\"center\"><code>[8]</code></td>\n<td align=\"center\">处理边界（溢出&#x2F;符号&#x2F;空格）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3️⃣链表类\"><a href=\"#3️⃣链表类\" class=\"headerlink\" title=\"3️⃣链表类\"></a><strong>3️⃣链表类</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">反转链表</td>\n<td align=\"center\"><code>[206]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">环形链表</td>\n<td align=\"center\"><code>[141]</code></td>\n<td align=\"center\">快慢指针判环</td>\n</tr>\n<tr>\n<td align=\"center\">合并两个有序链表</td>\n<td align=\"center\"><code>[21]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">删除链表倒数第N个节点</td>\n<td align=\"center\"><code>[19]</code></td>\n<td align=\"center\">一趟扫描</td>\n</tr>\n</tbody></table>\n<h3 id=\"4️⃣树与递归\"><a href=\"#4️⃣树与递归\" class=\"headerlink\" title=\"4️⃣树与递归\"></a><strong>4️⃣树与递归</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二叉树的最大深度</td>\n<td align=\"center\"><code>[104]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">对称二叉树</td>\n<td align=\"center\"><code>[101]</code></td>\n<td align=\"center\">迭代（队列&#x2F;栈）&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">路径总和</td>\n<td align=\"center\"><code>[112]</code></td>\n<td align=\"center\">动回溯法</td>\n</tr>\n</tbody></table>\n<h3 id=\"5️⃣动态规划\"><a href=\"#5️⃣动态规划\" class=\"headerlink\" title=\"5️⃣动态规划\"></a><strong>5️⃣动态规划</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">打家劫舍</td>\n<td align=\"center\"><code>[198]</code></td>\n<td align=\"center\">状态转移方程推导</td>\n</tr>\n<tr>\n<td align=\"center\">零钱兑换</td>\n<td align=\"center\"><code>[322]</code></td>\n<td align=\"center\">完全背包问题解法</td>\n</tr>\n<tr>\n<td align=\"center\">最长递增子序列</td>\n<td align=\"center\"><code>[300]</code></td>\n<td align=\"center\">O(nlogn)优化解法</td>\n</tr>\n</tbody></table>\n<h3 id=\"6️⃣排序与查找\"><a href=\"#6️⃣排序与查找\" class=\"headerlink\" title=\"6️⃣排序与查找\"></a><strong>6️⃣排序与查找</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\"><code>力扣排序题均可</code></td>\n<td align=\"center\">手写递归和非递归版本</td>\n</tr>\n<tr>\n<td align=\"center\">二分查找</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">处理边界条件（左闭右闭&#x2F;左闭右开）</td>\n</tr>\n<tr>\n<td align=\"center\">寻找峰值</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">二分法的特殊应用</td>\n</tr>\n</tbody></table>\n<h3 id=\"7️⃣其他高频\"><a href=\"#7️⃣其他高频\" class=\"headerlink\" title=\"7️⃣其他高频\"></a><strong>7️⃣其他高频</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">LRU缓存</td>\n<td align=\"center\"><code>[146]</code></td>\n<td align=\"center\">手写递归和非递归版本</td>\n</tr>\n<tr>\n<td align=\"center\">实现队列&#x2F;栈</td>\n<td align=\"center\"><code>[232/225]</code></td>\n<td align=\"center\">处理边界条件（左闭右闭&#x2F;左闭右开）</td>\n</tr>\n<tr>\n<td align=\"center\">汉明距离</td>\n<td align=\"center\"><code>[461]</code></td>\n<td align=\"center\">二分法的特殊应用</td>\n</tr>\n</tbody></table>\n<p>具体题目思路&amp;代码记录见各个专题🤗</p>\n<h1 id=\"简单题\"><a href=\"#简单题\" class=\"headerlink\" title=\"简单题\"></a>简单题</h1><h2 id=\"66-加一\"><a href=\"#66-加一\" class=\"headerlink\" title=\"66.加一\"></a>66.加一</h2><blockquote>\n<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>\n</blockquote>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>判断数组末尾是否有9：\n    无9：末尾数字+1;\n    有9：\n        是否全为9：\n            是全9：\n                构造长度=size+1的数组，首位=1，其余全置0;\n            非全9：\n                找到倒着数第一个不是9的元素,\n                该元素加1,\n                末尾所有的9置0;\n</code></pre>\n<h3 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;\n        int len=digits.size();\n        if(digits[len-1]!=9)&#123;\n            digits[len-1]+=1;\n        &#125;\n        else&#123;\n            int cnt=0;//记录9出现的次数，第一个非9元素的下标即为len-cnt-1\n            for(int i=len-1;i&gt;=0;i--)&#123;\n                if(digits[i]==9)&#123;\n                    cnt++;\n                &#125;\n                else&#123;\n                    break;\n                &#125;\n            &#125;\n            if(cnt==len)&#123;\n                digits.insert(digits.begin(),1);\n                for(int i=1;i&lt;len+1;i++)&#123;\n                    digits[i]=0;\n                &#125;\n            &#125;\n            else&#123;\n                int index=len-cnt-1;\n                digits[index]+=1;\n                for(int i=index+1;i&lt;len;i++)&#123;\n                    digits[i]=0;\n                &#125;\n            &#125;\n        &#125;\n        return digits;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"896-单调数列\"><a href=\"#896-单调数列\" class=\"headerlink\" title=\"896.单调数列\"></a>896.单调数列</h2><blockquote>\n<p>如果数组是单调递增或单调递减的，那么它是<strong>单调</strong>的。<br>如果对于所有 i &lt;&#x3D; j，nums[i] &lt;&#x3D; nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &lt;&#x3D; j，nums[i] &gt;&#x3D; nums[j]，那么数组 nums 是单调递减的。<br>当给定的数组 nums 是单调数组时返回 true，否则返回 false。</p>\n</blockquote>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>bool 递增变量=真，递减变量=真；\n遍历数组：\n    如果该元素+1 大于 该元素：\n        标记递减变量=假；\n    如果该元素+1 小于 该元素：\n        标记递增变量=假；\n如果递增or递减=真，返回真；\n</code></pre>\n<h3 id=\"AC代码-1\"><a href=\"#AC代码-1\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123;\n        bool increase=true,decrease=true;\n        for(int i=0;i&lt;nums.size()-1;i++)&#123;\n            if(nums[i+1] &gt; nums[i])&#123;\n                decrease=false;\n            &#125;\n            if(nums[i+1] &lt; nums[i])&#123;\n                increase=false;\n            &#125;\n        &#125;\n        return decrease || increase;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"896-罗马数字转整数\"><a href=\"#896-罗马数字转整数\" class=\"headerlink\" title=\"896.罗马数字转整数\"></a>896.罗马数字转整数</h2><blockquote>\n<p><strong>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</strong><br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</li>\n<li>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>①I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>②X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>③C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>给定一个罗马数字，将其转换成整数。</strong></p>\n</blockquote>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这题一开始我无从下手，直接跑去翻题解了。</p>\n<p><strong>C++ <a href=\"https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html\">map</a>用法</strong><br>想起来python的字典。同样cpp stl中的map提供的是一种键值对（key-value）容器，其中的数据成对出现。</p>\n<ul>\n<li>初始化：<code>map类型 &lt;数据类型1，数据类型2&gt; 容器名</code></li>\n</ul>\n<p>对于map类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键值对容器</th>\n<th align=\"center\">实现方式</th>\n<th align=\"center\">键值</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">是否有序</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unordered_map</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找键对应的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>map</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要有序键值对</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_set</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找元素是否存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>set</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要排序的集合</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_multimap</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">有重复键且不关心顺序</td>\n</tr>\n</tbody></table>\n<p><strong>对于本题</strong><br>引用评论区<a href=\"https://leetcode.cn/u/hust_wei/\">大佬</a>的解释：当前位置的元素比下个位置的元素小，就减去当前值，否则加上当前值。</p>\n<pre><code>定义键值对容器 &lt;字符，整型&gt; \n    分别对应罗马数字的字符和数值(注意字符变量加单引号);\n\nint 结果变量；\nint 罗马数字长度；\n遍历罗马数字：\n    如果元素 当前位置&lt;下一个位置：（注意使用值时加方括号[]）\n        结果变量-=值变量；\n    否则：\n        结果变量+=值变量；\n返回结果；\n</code></pre>\n<h3 id=\"AC代码-2\"><a href=\"#AC代码-2\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    unordered_map&lt;char,int&gt;mymap=&#123;\n        &#123;&#39;I&#39;,1&#125;,\n        &#123;&#39;V&#39;,5&#125;,\n        &#123;&#39;X&#39;,10&#125;,\n        &#123;&#39;L&#39;,50&#125;,\n        &#123;&#39;C&#39;,100&#125;,\n        &#123;&#39;D&#39;,500&#125;,\n        &#123;&#39;M&#39;,1000&#125;,\n    &#125;;\n    int romanToInt(string s) &#123;\n        int ans=0;\n        int len=s.length();\n        for(int i=0;i&lt;len;i++)&#123;\n            if(mymap[s[i]]&lt;mymap[s[i+1]])&#123;\n                ans-=mymap[s[i]];\n            &#125;\n            else&#123;\n                ans+=mymap[s[i]];\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58.最后一个单词的长度\"></a>58.最后一个单词的长度</h2><blockquote>\n<p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。<br><strong>单词</strong>是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>\n</blockquote>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><strong>【方法一】</strong><br>我的思路是<strong>从后向前</strong>遍历字符串时：如果它的后一个是空格或空，自己不是空格，意味着句尾有空格，该下标是倒着数第一个不为空格的字母；如果前一个是空格或空，自己不是空格，代表这是词的开头，记录下标直接退出循环。最后长度就是二者相减。<br>但是这样写大多数样例不通过（悲</p>\n<p>（二编）卧槽我改对了！！！</p>\n<p><strong>【方法二】</strong><br>不对那就改呗：直接从字符串的尾部开始遍历，<strong>跳过所有尾部空格</strong>，直到遇到<strong>第一个非空格字符</strong>，并计算其长度。能够更好的处理边界情况。</p>\n<pre><code>int 长度=字符串长度;\nint i=长度-1;\nint 结果长度=0\n当i大于等于0并且s的第i个字符为空格时：\n    i--；（倒着循环遍历）\n*本题设定s不为空，若无此条件需在此判断：当i&lt;0时直接返回（s为空）\n当i大于等于0并且s的第i个字符不为空格时：\n    结果长度++；\n    i--；\n返回结果长度;\n</code></pre>\n<h3 id=\"AC代码-3\"><a href=\"#AC代码-3\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p><strong>【方法一】</strong></p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        int len=s.length();\n        int m=0,n=0;\n        for(int i=len-1;i&gt;0;i--)&#123;\n            if(s[i]!=&#39; &#39; &amp;&amp; (s[i+1]==&#39; &#39; || s[i+1]==&#39;\\0&#39;))&#123;\n                m=i;\n            &#125;\n            if((s[i-1]==&#39; &#39; || s[i-1]==&#39;\\0&#39;) &amp;&amp; s[i]!=&#39; &#39;)&#123;\n                n=i;\n                break;\n            &#125;\n        &#125;\n        return m-n+1;\n    &#125;\n&#125;;\n</code></pre>\n<p><strong>【方法二】</strong></p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        int len=s.length();\n        int ans=0;\n        int i=len-1;\n        while(i&gt;=0 &amp;&amp; s[i]==&#39; &#39;)&#123;\n            i--;\n        &#125;\n        while(i&gt;=0 &amp;&amp; s[i]!=&#39; &#39;)&#123;\n            ans++;\n            i--;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9.回文数\"></a>9.回文数</h2><blockquote>\n<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。</p>\n</blockquote>\n<h3 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><strong>关键点</strong></p>\n<ul>\n<li>回文数是正整数</li>\n<li>负数不是回文数</li>\n<li>一个数的最后一位是0且这个数不为0，不是回文数</li>\n</ul>\n<p>将数字的后半部分反转，用<code>反转数字</code>存储。最后的反转数字包含原始x的后半部分，x包含原始x的前半部分。<br>最后返回时：若<strong>原始x是偶数</strong>，那么对于回文数，<strong>x一定&#x3D;反转数字</strong>。若<strong>原始x是奇数</strong>，那么反转数字会比x多一位，这一位是反转数字的个位并且是原始x的中位数，不影响回文数判断。所以<strong>先去掉个位</strong>再与当前的x比较。</p>\n<pre><code>如果（x小于0，或者x的个位不等于0且x不等于0）：\n    不是回文数；\n定义反转数字=0；\n当（x &gt; 反转数字）：\n    反转数字=反转数字*10+x%10；\n    x/=10；\nx = 反转数字\n返回x = 反转数字 或者 x = 去掉个位的反转数字；\n</code></pre>\n<h3 id=\"AC代码-4\"><a href=\"#AC代码-4\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isPalindrome(int x) &#123;\n        if(x&lt;0 || (x%10==0 &amp;&amp; x!=0))&#123;\n            return false;\n        &#125;\n        int num=0;\n        while(x&gt;num)&#123;\n            num=num*10+x%10;\n            x/=10;\n        &#125;\n        return x==num || x==num/10;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14.最长公共前缀\"></a>14.最长公共前缀</h2><blockquote>\n<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>\n</blockquote>\n<h3 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>区区小简单，真是难倒我了。<br>这里总结力扣官方题解的纵向扫描方法。我一开始想的也是类似思路，奈何憋不出来代码。<br><strong>关键点</strong></p>\n<ul>\n<li>最长公共前缀的长度不可能超过任何一个字符串的长度</li>\n<li>数组strs的大小即为字符串的总个数</li>\n<li><strong>二维数组形式</strong>可以直接表示第i个字符的第j位</li>\n<li>如果 <strong><code>i</code>超出某个字符串的长度</strong>或**第<code>j</code>个字符串的第<code>i</code>个字符不等于<code>c</code>**时，直接返回当前的公共前缀。</li>\n<li>循环结束说明所有字符串的所有字符都匹配，那么第一个字符串本身就是最长公共前缀，返回第一个字符串<code>strs[0]</code>。</li>\n</ul>\n<pre><code class=\"language-cpp\">如果数组为空：\n    返回&quot;&quot;；\nint 长度变量=数组第一个字符串元素的长度；\nint 计数变量=数组大小；\n遍历i，从0到长度变量：\n    char 字符变量=第一个字符串的第i个字符；\n    遍历j，从1到计数变量：\n        如果（i==第j个字符串的大小 || 第j个字符串的第i个字符 ！= 字符变量）：\n            返回 第一个字符串的第一个字符~第i个字符；\n返回 第一个字符；\n</code></pre>\n<h3 id=\"AC代码-5\"><a href=\"#AC代码-5\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\n        if(!strs.size())&#123;\n            return &quot;&quot;;\n        &#125;\n        int len=strs[0].size();\n        int cnt=strs.size();\n        for(int i=0;i&lt;len;i++)&#123;\n            char c=strs[0][i];\n            for(int j=1;j&lt;cnt;j++)&#123;\n                if(i==strs[j].size() || strs[j][i]!=c)&#123;\n                    return strs[0].substr(0,i);\n                &#125;\n            &#125;\n        &#125;\n        return strs[0];\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"682-棒球比赛\"><a href=\"#682-棒球比赛\" class=\"headerlink\" title=\"682.棒球比赛\"></a>682.棒球比赛</h2><blockquote>\n<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>\n</blockquote>\n<blockquote>\n<p>比赛开始时，记录是空白的。你会得到一个记录操作的<strong>字符串列表</strong> ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p>\n<ul>\n<li>整数 x - 表示本回合新获得分数 x</li>\n<li>“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>\n<li>“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n<li>“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。<br>请你返回记录中所有得分的总和。</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>用int动态数组ans记录得分，但是不用i做索引来查询，而是用begin、end、size、back等方法来防止发生越界访问。</p>\n<ul>\n<li>注意<code>string</code>类型为字符串，用双引号””括起来，<code>char</code>类型为字符，用单引号’’。</li>\n</ul>\n<pre><code>前两次得分之和：size-1 +size-2\n前一次得分：back\n最近一次得分移除-&gt;出栈-&gt;pop_back\n加入得分：压栈-&gt;push_back\n字符串转整型：stoi\n计算动态数组的和：accumulate\n</code></pre>\n<p>另外，我一开始想用<code>unordered_map</code>，做题做迷了。后来发现动态数组完全可以解决：C++ 标准库中的 vector 支持动态调整大小，可以方便地模拟栈的行为。而unordered_map 是用来存储键值对（key-value pairs）的哈希表。<br>本问题中不需要映射关系，所以并不需要用到 unordered_map。<br>还有，<strong>stack<int><strong>的<code>.push()</code>和<code>.pop()</code>也可，但是</strong>vector</strong>的<code>.push_back()</code>和<code>.pop_back()</code>也同样可以。那就选更常用的vector，何乐而不为呢？</p>\n<h3 id=\"AC代码-6\"><a href=\"#AC代码-6\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p>用时击败7%，悲。之后滚回来优化算法。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int calPoints(vector&lt;string&gt;&amp; operations) &#123;\n        vector&lt;int&gt;ans;\n        for(string ch:operations)&#123;\n            if(ch==&quot;+&quot;)&#123;\n                ans.push_back(ans[ans.size()-1]+ans[ans.size()-2]);\n            &#125;\n            else if(ch==&quot;D&quot;)&#123;\n                ans.push_back(ans.back()*2);\n            &#125;\n            else if(ch==&quot;C&quot;)&#123;\n                ans.pop_back();\n            &#125;\n            else&#123;\n                ans.push_back(stoi(ch));\n            &#125;\n        &#125;\n        return accumulate(ans.begin(),ans.end(),0);\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"26-删除有序数组中的重复项\"><a href=\"#26-删除有序数组中的重复项\" class=\"headerlink\" title=\"26.删除有序数组中的重复项\"></a>26.删除有序数组中的重复项</h2><blockquote>\n<p>给你一个非严格递增排列的数组nums,请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回nums中唯一元素的个数。</p>\n</blockquote>\n<blockquote>\n<p>考虑nums的唯一元素的数量为k，你需要做以下事情确保你的题解可以被通过：</p>\n<ul>\n<li>更改数组nums，使nums的前k个元素包含唯一元素，并按照它们最初在nums中出现的顺序排列。nums的其余元素与nums的大小不重要。</li>\n<li>返回 k 。</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>int 最终数组长度=1;\n遍历nums：\n    如果第i个元素不等于第i-1个元素：\n        nums[最终数组长度]=nums[i]；\n        最终数组长度++；\n返回最终数组长度；\n</code></pre>\n<h3 id=\"AC代码-7\"><a href=\"#AC代码-7\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p>妈呀这题一提交发现每ms都有解法…密密麻麻(ΩДΩ)</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int ans=1;\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            if(nums[i]!=nums[i-1])&#123;\n                nums[ans]=nums[i];\n                ans++;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"1922-统计好数字的数目\"><a href=\"#1922-统计好数字的数目\" class=\"headerlink\" title=\"1922.统计好数字的数目\"></a>1922.统计好数字的数目</h2><blockquote>\n<p>我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。<br>比方说，”2582” 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 “3245” 不是 好数字，因为 3 在偶数下标处但不是偶数。<br>给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 10^9 + 7 取余后返回 。<br>一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; n &lt;&#x3D; 1015</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-8\"><a href=\"#解题思路-8\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>🤔一开始就被范围吓到了，这完全穷举不了啊，悲。<br>这道题不超时的话只能用数学方法了，快来和我一起看<a href=\"https://leetcode.cn/problems/count-good-numbers/solutions/857728/cheng-fa-yuan-li-kuai-su-mi-by-endlessch-btkn/?envType=daily-question&envId=2025-04-13\">题解</a>!<br><strong>总结一下</strong> 对于长度为n的好数字字符串：</p>\n<ol>\n<li>偶数下标个数<code>a=⌈n/2⌉=⌊(n+1)/2⌋</code></li>\n</ol>\n<ul>\n<li>下标有五种可能：0、2、4、6、8</li>\n<li>方案数<code>5^a</code><blockquote>\n<p>*注意这里⌈ ⌉是向上取整，⌊ ⌋是向下取整。我也是最近才学到</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>奇数下标个数<code>b=⌊n/2⌋</code></li>\n</ol>\n<ul>\n<li>下标有四种可能：2、3、5、7</li>\n<li>方案数<code>4^b</code></li>\n</ul>\n<ol start=\"3\">\n<li>可得总方案数为<code>(5^a)*(4^b)</code></li>\n</ol>\n<p>到这里涉及到两个问题：<br><strong>👉️快速幂</strong><br>直接暴力pow必定超时&#x2F;爆栈，所以需要快速幂。<a href=\"https://leetcode.cn/problems/powx-n/solutions/2858114/tu-jie-yi-zhang-tu-miao-dong-kuai-su-mi-ykp3i/\">方法</a>太神了…趁热打铁把<a href=\"https://leetcode.cn/problems/powx-n/description/\">50.Pow(x,n)</a>一起拿下</p>\n<blockquote>\n<p><code>x^n</code>怎么快速算？<br>n转二进制后，从右往左遍历，遇到1就乘对应x的幂次。<br>比如<code>13 = 1101</code>：<br>那么<code>x^13</code> &#x3D; <code>x^(2^0)</code> * <code>x^(2^2)</code> * <code>x^(2^3)</code> &#x3D; <code>x</code> * <code>x^4</code> * <code>x^8</code>。</p>\n</blockquote>\n<p><strong>👉️取模</strong></p>\n<blockquote>\n<p>因为题目要算的答案特别大以至于超出64位整数的范围，所以要求对<code>10^9 + 7</code>取模。<br>这里好多数学公式😫先把代码总结<a href=\"(https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/)\">copy</a>过来</p>\n</blockquote>\n<pre><code class=\"language-cpp\">MOD = 1_000_000_007\n// 加\n(a + b) % MOD\n// 减\n(a - b + MOD) % MOD\n// 把任意整数 a 取模到 [0,MOD-1] 中，无论 a 是正是负\n(a % MOD + MOD) % MOD\n// 乘（注意使用 64 位整数）\na * b % MOD\n// 多个数相乘，要步步取模，防止溢出\na * b % MOD * c % MOD\n// 除（MOD 是质数且 b 不是 MOD 的倍数）\na * qpow(b, MOD - 2, MOD) % MOD\n</code></pre>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    const long long mod=1e9+7;\n    //快速幂：计算base^exp\n    long long ModPow(long long base,long long exp)&#123;\n        long long res=1;\n        while(exp)&#123;\n            if(exp%2==1)&#123;//当前位是1\n                res=(res*base)%mod;\n            &#125;\n            base=(base*base)%mod;//base^2是base的下一步幂\n            exp/=2;\n        &#125;\n        return res;\n    &#125;\n    //主函数\n    int countGoodNumbers(long long n) &#123;\n        long long a,b;\n        a=(n+1)/2;\n        b=n/2;\n        return (ModPow(5,a)*ModPow(4,b))% mod;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"50-Pow-x-n\"><a href=\"#50-Pow-x-n\" class=\"headerlink\" title=\"50.Pow(x,n)\"></a>50.Pow(x,n)</h2><blockquote>\n<p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>-100.0 &lt; x &lt; 100.0</li>\n<li>231 &lt;&#x3D; n &lt;&#x3D; 231-1</li>\n<li>n 是一个整数</li>\n<li>要么 x 不为零，要么 n &gt; 0 。</li>\n<li>-104 &lt;&#x3D; xn &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-9\"><a href=\"#解题思路-9\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>详见上一题~这里还涉及到：</p>\n<ol>\n<li>n为负数<br>把n变成-n，x变为1&#x2F;x。</li>\n<li>n&#x3D;(−2)^31<br>此时n取反会超出int最大值，可以转为64位int。</li>\n</ol>\n<p>另外，关键代码<a href=\"https://leetcode.cn/problems/powx-n/solutions/2858114/tu-jie-yi-zhang-tu-miao-dong-kuai-su-mi-ykp3i/\">灵神</a>的更简洁，放在这里学习一下：</p>\n<pre><code class=\"language-cpp\">        while (n) &#123; // 从低到高枚举 n 的每个比特位\n            if (n &amp; 1) &#123; // 这个比特位是 1\n                ans *= x; // 把 x 乘到 ans 中\n            &#125;\n            x *= x; // x 自身平方\n            n &gt;&gt;= 1; // 继续枚举下一个比特位\n        &#125;\n</code></pre>\n<h3 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    double myPow(double x, int N) &#123;\n        double res=1;\n        long long n=N;\n        while(n)&#123;\n            if(n&lt;0)&#123;\n                n=-n;\n                x=1/x;\n            &#125;\n            if(n%2==1)&#123;\n                res=(res*x);\n            &#125;\n            x=x*x;\n            n/=2;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/",
            "url": "https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/",
            "title": "博客搭建小半年的痛",
            "date_published": "2025-02-20T02:26:39.000Z",
            "content_html": "<p><strong>主打一个备忘</strong><br>断断续续从24年中搞到现在25年初，最磨蹭的一集。</p>\n<blockquote>\n<p><strong>最新问题</strong></p>\n<blockquote>\n<p>提交评论 ×<br>替换部分主题图片 ×<br>文章总访问量显示 ×</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"首先是参考链接\"><a href=\"#首先是参考链接\" class=\"headerlink\" title=\"首先是参考链接\"></a>首先是参考链接</h2><p>非常感谢！</p>\n<h3 id=\"ShokaX\"><a href=\"#ShokaX\" class=\"headerlink\" title=\"ShokaX\"></a>ShokaX</h3><p>github：<a href=\"https://github.com/theme-shoka-x/hexo-theme-shokaX\">https://github.com/theme-shoka-x/hexo-theme-shokaX</a><br>官方文档：<a href=\"https://hexo.docs.shokax.top/\">https://hexo.docs.shokax.top/</a><br>主题指南：<a href=\"https://docs.kaitaku.xyz/\">https://docs.kaitaku.xyz/</a><br>社区资源：<a href=\"https://github.com/theme-shoka-x/awesome-shokaX\">https://github.com/theme-shoka-x/awesome-shokaX</a><br>shoka：<a href=\"https://github.com/amehime/hexo-theme-shoka\">https://github.com/amehime/hexo-theme-shoka</a></p>\n<h3 id=\"其他相关网站-教程\"><a href=\"#其他相关网站-教程\" class=\"headerlink\" title=\"其他相关网站&amp;教程\"></a>其他相关网站&amp;教程</h3><p>Linn’s Shoka：<a href=\"https://linn-ylz.com/Hexo/blog-content-test/\">https://linn-ylz.com/Hexo/blog-content-test/</a><br>waline快速上手：<a href=\"https://waline.js.org/guide/get-started/\">https://waline.js.org/guide/get-started/</a><br>Vercel服务端部署：<a href=\"https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example&teamSlug=232akiras-projects\">https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&amp;teamSlug=232akiras-projects</a><br>leancloud：<a href=\"https://console.leancloud.app/apps\">https://console.leancloud.app/apps</a><br>Gimhoy图床：<a href=\"https://pic.gimhoy.com/\">https://pic.gimhoy.com/</a><br>Google字体：<a href=\"https://fonts.google.com/\">https://fonts.google.com/</a><br>百度统计：<a href=\"https://tongji.baidu.com/main/setting/10000672027/home/site/index\">https://tongji.baidu.com/main/setting/10000672027/home/site/index</a><br>markdown排版：<a href=\"https://markdown.com.cn/editor/\">https://markdown.com.cn/editor/</a></p>\n<h2 id=\"搭建思路\"><a href=\"#搭建思路\" class=\"headerlink\" title=\"搭建思路\"></a>搭建思路</h2><p>这方面毫无实战知识，不停地踩坑踩坑…</p>\n<h3 id=\"Hexo初始化博客\"><a href=\"#Hexo初始化博客\" class=\"headerlink\" title=\"Hexo初始化博客\"></a><a href=\"https://hexo.io/zh-cn/\" title=\"点此跳转Hexo官网\">Hexo</a>初始化博客</h3><p>基于Node.js的博客框架。本博客采用Hexo+Github搭建。<br><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">功能</th>\n<th align=\"center\">命令</th>\n<th align=\"center\">简写</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">清理缓存</td>\n<td align=\"center\">hexo clean</td>\n<td align=\"center\"><code>hexo cl</code></td>\n</tr>\n<tr>\n<td align=\"center\">部署站点</td>\n<td align=\"center\">hexo deploy</td>\n<td align=\"center\"><code>hexo d</code></td>\n</tr>\n<tr>\n<td align=\"center\">生成博客</td>\n<td align=\"center\">hexo generate</td>\n<td align=\"center\"><code>hexo g</code></td>\n</tr>\n<tr>\n<td align=\"center\">启动本地服务</td>\n<td align=\"center\">hexo server</td>\n<td align=\"center\"><code>hexo s</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"Shoka主题配置\"><a href=\"#Shoka主题配置\" class=\"headerlink\" title=\"Shoka主题配置\"></a>Shoka主题配置</h3><p>一开始胡乱配置，后来更新的时候爆出来好多问题。于是这两天从头重做</p>\n<h4 id=\"步骤如下：\"><a href=\"#步骤如下：\" class=\"headerlink\" title=\"步骤如下：\"></a>步骤如下：</h4><pre><code>前置hexo init、Node.js等\npnpm安装shokax\n/_config.landscape.yml重命名为_config.shokax.yml\n</code></pre>\n<h4 id=\"config-yml中的配置项：\"><a href=\"#config-yml中的配置项：\" class=\"headerlink\" title=\"&#x2F;_config.yml中的配置项：\"></a>&#x2F;_config.yml中的配置项：</h4><pre><code>markdown配置\n停用默认代码高亮\n文件压缩\nfeed生成\n站内搜索\n</code></pre>\n<h4 id=\"config-shokax-yml中的配置项：\"><a href=\"#config-shokax-yml中的配置项：\" class=\"headerlink\" title=\"&#x2F;_config.shokax.yml中的配置项：\"></a>&#x2F;_config.shokax.yml中的配置项：</h4><pre><code>静态资源存放目录\nShokaX功能模块\n主页头图\nIconfont图标\n导航栏\n侧边栏\n大标题\n社交链接\n字数和阅读时间统计\n预加载和预解析地址\nSEO优化和访客优化\n夜间模式\n自动定位\n标题自定义\n图片自定义\n首页精选\n分类翻转块\n实验性特性\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/github_blog.jpg\" alt=\"2025&#x2F;3&#x2F;17\" title=\"Insights\"></p>\n<p>突然发现放简历上的的网站二维码扫出来404😇可能当初生成二维码时没事，链接是某个具体的文章路径，后来Hexo更新或者改了文章的permalink，导致原来的链接失效了。</p>\n<p>回到我的主页😼👇️</p>\n<ul>\n<li>site: K’s BLOG<br>url: <a href=\"https://232akira.github.io/\">https://232akira.github.io/</a><br>color: “#adff2f”</li>\n</ul>\n<p>（？渲染器没安装好…</p>\n",
            "tags": [
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2024/11/23/%E5%AD%98%E5%AD%98markdown%E7%9B%B8%E5%85%B3/",
            "url": "https://232akira.github.io/2024/11/23/%E5%AD%98%E5%AD%98markdown%E7%9B%B8%E5%85%B3/",
            "title": "存存markdown相关",
            "date_published": "2024-11-23T10:40:43.000Z",
            "content_html": "<h2 id=\"这是232akira的第一篇博客的二级标题两个井号加空格\"><a href=\"#这是232akira的第一篇博客的二级标题两个井号加空格\" class=\"headerlink\" title=\"这是232akira的第一篇博客的二级标题两个井号加空格\"></a>这是232akira的第一篇博客的二级标题两个井号加空格</h2><h3 id=\"这是232akira的第一篇博客的三级标题三个井号加空格\"><a href=\"#这是232akira的第一篇博客的三级标题三个井号加空格\" class=\"headerlink\" title=\"这是232akira的第一篇博客的三级标题三个井号加空格\"></a>这是232akira的第一篇博客的三级标题三个井号加空格</h3><p>这是232akira的第一篇博客的第一段直接回车</p>\n<p>这是232akira的第一篇博客的第二段</p>\n<p>这是换行尝试两个空格+回车<br><br><br>换行！</p>\n<p>这是字体加粗尝试加粗 <strong>前后各加2个星星号</strong></p>\n<p>这是字体斜体尝试斜体 <em>前后各加1个星星号</em></p>\n<p>这是字体同时加粗斜体尝试 <em><strong>前后各加3个星星号</strong></em></p>\n<p>这是创建块引用</p>\n<blockquote>\n<p>kuaiyinyongkuaiyinyongkkk<br>这是多个段落的块引用<br>kuaiyinyongkkk</p>\n<p>kkk</p>\n</blockquote>\n<p>这是嵌套块引用</p>\n<blockquote>\n<p>kuaiyinyongkkk</p>\n<blockquote>\n<p>qiantaoaaa</p>\n<ul>\n<li>用短横杠（注意两边空格）出来是圆点</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>这是有序列表<br>1.我是1第一项必须数字一加英文句号后面数字无所谓<br>2.我是2<br>    1.我是1<br>    2.我是2<br>3.我是3</p>\n<p>这是无序列表点乘加短横杠都可以变成圆点<br>-111<br>-222<br>    -1111嵌套前面四个空格<br>    -代码在列表里缩进8个空格或者2个tab<br>            print(“hello world~”)<br>-333</p>\n<p>这是代码语法<br>把代码包裹在反引号<code>中 比如我这里是 </code>代码代码代码<code>创建代码块就还是缩进4个空格or1个tab</code>        我是代码块啊啊啊&#96;</p>\n<h2 id=\"这是分隔线单独一行三星或多星-破折号-下划线\"><a href=\"#这是分隔线单独一行三星或多星-破折号-下划线\" class=\"headerlink\" title=\"这是分隔线单独一行三星或多星&#x2F;破折号&#x2F;下划线***\"></a>这是分隔线单独一行三星或多星&#x2F;破折号&#x2F;下划线<br>***</h2><hr>\n<p>出来的效果一样的</p>\n<p>这是链接链接的文本放中括号地址放后面圆括号<a href=\"https://www.xuexi.cn/\" title=\"我是title\">快来学习</a><br>或者直接尖括号链接跳转<a href=\"https://www.xuexi.cn/\">https://www.xuexi.cn/</a></p>\n<p>强调链接就在尖括号前后增加星号，表示为代码就加反引号<br>I love <strong><a href=\"https://www.xuexi.cn/\" title=\"我是title\">学习</a></strong></p>\n<p>这是引用型链接，两个方括号前一个写文本后一个指向其他位置的链接<br>[跳转跳转啊啊啊] <a href=\"https://www.xuexi.cn/\">1</a></p>\n<p>这是添加图像使用感叹号+方括号+圆括号。方括号里写替代文本，圆括号里写图片链接，也可以后接图片标题文本。跳转链接写在最外面并再套一层方括号。<br><img loading=\"lazy\" data-src=\"/images/kabi.jpg\" alt=\"这是图片\" title=\"我是title\"></p>\n",
            "tags": [
                "记录",
                "Markdown"
            ]
        }
    ]
}
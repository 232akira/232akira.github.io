<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Per aspera ad astra</title>
        <link>https://232akira.github.io</link>
        <description>欢迎交流学习!</description>
        <language>zh-CN</language>
        <pubDate>Fri, 14 Mar 2025 16:00:53 +0800</pubDate>
        <lastBuildDate>Fri, 14 Mar 2025 16:00:53 +0800</lastBuildDate>
        <category>算法</category>
        <category>字符串</category>
        <category>滑动窗口</category>
        <category>C++</category>
        <category>力扣</category>
        <category>数组</category>
        <category>哈希表</category>
        <category>动态规划</category>
        <category>二分查找</category>
        <category>链表</category>
        <category>记录</category>
        <category>Markdown</category>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/14/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BA%9B%E7%AE%80%E5%8E%86%E4%B8%8A%E6%B2%A1%E5%86%99%E7%9A%84%E6%95%85%E4%BA%8B/</guid>
            <title>🔝这里有些简历上没写的故事</title>
            <link>https://232akira.github.io/2025/03/14/%E8%BF%99%E9%87%8C%E6%9C%89%E4%BA%9B%E7%AE%80%E5%8E%86%E4%B8%8A%E6%B2%A1%E5%86%99%E7%9A%84%E6%95%85%E4%BA%8B/</link>
            <category>记录</category>
            <pubDate>Fri, 14 Mar 2025 16:00:53 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;无论最后是否有结果，感谢您愿意抽出时间。&lt;/p&gt;
&lt;h1 id=&#34;🎯-我是谁？&#34;&gt;&lt;a href=&#34;#🎯-我是谁？&#34; class=&#34;headerlink&#34; title=&#34;🎯 我是谁？&#34;&gt;&lt;/a&gt;🎯 &lt;strong&gt;我是谁？&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主业&lt;/strong&gt;：相信您已经从简历里了解到了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;副业&lt;/strong&gt;：GitHub折腾者 &amp;#x2F; 深夜Debug战士 &amp;#x2F; 奶茶续命选手（在控制了）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;最近在干什么？&#34;&gt;&lt;a href=&#34;#最近在干什么？&#34; class=&#34;headerlink&#34; title=&#34;最近在干什么？&#34;&gt;&lt;/a&gt;最近在干什么？&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;找暑期实习&lt;/strong&gt;&lt;/em&gt;。对的，主要干这个。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;死磕算法基础，感觉自己还不够扎实，正在找补&lt;/li&gt;
&lt;li&gt;梳理之前做过的项目内容&lt;/li&gt;
&lt;li&gt;顺便修修本博客，结果越修坑越多&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;💻-关于这个博客&#34;&gt;&lt;a href=&#34;#💻-关于这个博客&#34; class=&#34;headerlink&#34; title=&#34;💻 关于这个博客&#34;&gt;&lt;/a&gt;💻 &lt;strong&gt;关于这个博客&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&#34;为什么建？&#34;&gt;&lt;a href=&#34;#为什么建？&#34; class=&#34;headerlink&#34; title=&#34;为什么建？&#34;&gt;&lt;/a&gt;&lt;strong&gt;为什么建？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;作为学计算机的，最开始是想至少有个地方记录技术笔记，后来上头了啥都放进来。&lt;/p&gt;
&lt;h2 id=&#34;目前配置：&#34;&gt;&lt;a href=&#34;#目前配置：&#34; class=&#34;headerlink&#34; title=&#34;目前配置：&#34;&gt;&lt;/a&gt;&lt;strong&gt;目前配置：&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hexo + ShokaX 主题&lt;/strong&gt; 踩坑无数，终于稳定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waline + Vercel&lt;/strong&gt; 没成。您会发现评论提交不了😂想联系我直接+v没问题的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub Actions 自动部署&lt;/strong&gt; 避免手动push折腾&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;未来要做的&#34;&gt;&lt;a href=&#34;#未来要做的&#34; class=&#34;headerlink&#34; title=&#34;未来要做的&#34;&gt;&lt;/a&gt;&lt;strong&gt;未来要做的&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集成评论系统&lt;/li&gt;
&lt;li&gt;代码渲染器&lt;/li&gt;
&lt;li&gt;添加不蒜子访问量统计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;踩过的坑：博客运维现场实录&#34;&gt;&lt;a href=&#34;#踩过的坑：博客运维现场实录&#34; class=&#34;headerlink&#34; title=&#34;踩过的坑：博客运维现场实录&#34;&gt;&lt;/a&gt;&lt;strong&gt;踩过的坑：博客运维现场实录&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;早期 GitHub Actions一直自动部署失败，巨崩溃，排查半天才发现是Node.js版本问题，最后升级+重装插件才修好。&lt;br&gt;具体搭载方式可以看&lt;a href=&#34;https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/&#34;&gt;另一篇&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;🔧技术探索碎片&#34;&gt;&lt;a href=&#34;#🔧技术探索碎片&#34; class=&#34;headerlink&#34; title=&#34;🔧技术探索碎片&#34;&gt;&lt;/a&gt;🔧技术探索碎片&lt;/h1&gt;&lt;p&gt;除了简历上的项目，这里还有些更零散但值得一提的东西：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您完全可以批评我没有特别专精某一部分，我觉得事实的确如此。早点确定方向磨练技术一定不错，但是奈何哪部分我都有点兴趣而且懒懒的😤所以就拖到现在啦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1️⃣-后端开发&#34;&gt;&lt;a href=&#34;#1️⃣-后端开发&#34; class=&#34;headerlink&#34; title=&#34;1️⃣ 后端开发&#34;&gt;&lt;/a&gt;1️⃣ &lt;strong&gt;后端开发&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C++&lt;/code&gt;和&lt;code&gt;Python&lt;/code&gt;是主力。但是主要是语法和算法方面，开发这一块经验少。Java课上做过一点项目。&lt;/li&gt;
&lt;li&gt;习惯关注代码工程化，做项目时会尽量保证清晰的模块划分（命名强迫症在此）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2️⃣-人工智能-深度学习&#34;&gt;&lt;a href=&#34;#2️⃣-人工智能-深度学习&#34; class=&#34;headerlink&#34; title=&#34;2️⃣ 人工智能 &amp;amp; 深度学习&#34;&gt;&lt;/a&gt;2️⃣ &lt;strong&gt;人工智能 &amp;amp; 深度学习&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VGG16&lt;/code&gt;进行花卉识别，也做过&lt;code&gt;DO（溶解氧）预测实验&lt;/code&gt;等等，不过由于个人设备和资源限制，没法深入优化模型（数据量但凡大一点我的笔记本就超烫），只能在已有框架上调整参数、跑实验、对比结果。&lt;/li&gt;
&lt;li&gt;之前了解过&lt;code&gt;YOLOv8&lt;/code&gt;，尝试过跑一些示例代码和&lt;code&gt;labelimg打标&lt;/code&gt;，但目前还没深入应用，更多是出于兴趣在学习。&lt;/li&gt;
&lt;li&gt;AI方面的&lt;code&gt;理论知识&lt;/code&gt;课上是学过，什么卷积层全连接层、什么池化归一化…浅尝辄止，说实话难以理解，我的水平确实有所欠缺。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3️⃣-游戏开发&#34;&gt;&lt;a href=&#34;#3️⃣-游戏开发&#34; class=&#34;headerlink&#34; title=&#34;3️⃣ 游戏开发&#34;&gt;&lt;/a&gt;3️⃣ &lt;strong&gt;游戏开发&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;Unity&lt;/code&gt;+&lt;code&gt;C#&lt;/code&gt;做过一些小demo，尝试为部分元素添加材质、物理碰撞体，并进行脚本控制。记得当时特别想试试做人物交互，但是事情一多起来就抛在脑后了。&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;shader&lt;/code&gt;有兴趣，之前没事就在blender上玩弄模型的渲染😂之前也试图做了点mmd和Ae的pv&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;玩游戏&lt;/code&gt;的经验：手机端游大多玩过点，PC上的steam趁史低入库然后吃灰，switch主玩塞尔达和文字冒险。最近忙起来玩的都少了，反倒b站刷视频多一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4️⃣-GIS-课程相关&#34;&gt;&lt;a href=&#34;#4️⃣-GIS-课程相关&#34; class=&#34;headerlink&#34; title=&#34;4️⃣ GIS &amp;amp; 课程相关&#34;&gt;&lt;/a&gt;4️⃣ &lt;strong&gt;GIS &amp;amp; 课程相关&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;GIS&lt;/code&gt;课程里做过空间分析实验，包括Kriging插值、网络分析等，还有IDW、Kriging、Spline等空间插值算法的参数影响分析。软件包括ArcGIS&amp;#x2F;ENVI&amp;#x2F;SNAP等。&lt;/li&gt;
&lt;li&gt;matlab&lt;code&gt;数字信号处理&lt;/code&gt;，有音频倒放、图片去噪之类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;🎨-非技术面面观：&#34;&gt;&lt;a href=&#34;#🎨-非技术面面观：&#34; class=&#34;headerlink&#34; title=&#34;🎨 非技术面面观：&#34;&gt;&lt;/a&gt;🎨 &lt;strong&gt;非技术面面观：&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我认为展示自己的&lt;code&gt;其他技能&lt;/code&gt;也同样重要，但是因为这些对技术岗而言并非硬性需求，所以简历上就没有放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;性格方面&#34;&gt;&lt;a href=&#34;#性格方面&#34; class=&#34;headerlink&#34; title=&#34;性格方面&#34;&gt;&lt;/a&gt;性格方面&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按现在年轻人的认知，e还是i？那我必是个&lt;code&gt;i人&lt;/code&gt;。&lt;br&gt;关于具体mbti我实在记不住什么abcd，而且有时候每次测结果都不一样…所以问了就是不知道。&lt;br&gt;说实话，性格比较&lt;code&gt;倔&lt;/code&gt;。如果有什么事情没完成，我就那个如鲠在喉啊，睡不着受不了。&lt;/li&gt;
&lt;li&gt;另，我还是那种&lt;code&gt;又菜又倔&lt;/code&gt;，如果你想了解我先前的教育经历：&lt;br&gt;坐标22河南理科，排名两万六来的海大计算机专业。经历多年衡水式教育+疫情封校，午睡都是掐着分钟睡（当然现在来上海发现中午睡都不用睡了）。入学时编程基础几乎为0，装个C语言的IDE不会，问一圈舍友和百度才装好，输出helloworld好几天理解不了，笨吧？真的学起来很吃力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;一眨眼明年就要毕业了，感慨啊...&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好方面&#34;&gt;&lt;a href=&#34;#兴趣爱好方面&#34; class=&#34;headerlink&#34; title=&#34;兴趣爱好方面&#34;&gt;&lt;/a&gt;兴趣爱好方面&lt;/h2&gt;&lt;p&gt;基本都是小学练的，这点感谢父母。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跟班学了&lt;code&gt;电子琴/钢琴&lt;/code&gt;6~7年，现在怎么弹琴快忘光，手速全用在打字上了😂&lt;/li&gt;
&lt;li&gt;&lt;code&gt;画画&lt;/code&gt;跟班+自学到现在也有15年了，业余水平画着玩，主打解闷儿&lt;/li&gt;
&lt;li&gt;&lt;code&gt;写字&lt;/code&gt;还不错&lt;/li&gt;
&lt;li&gt;乱七八糟的&lt;code&gt;手工&lt;/code&gt;都沾点边&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;📬-来唠个五毛钱的？&#34;&gt;&lt;a href=&#34;#📬-来唠个五毛钱的？&#34; class=&#34;headerlink&#34; title=&#34;📬 来唠个五毛钱的？&#34;&gt;&lt;/a&gt;📬 &lt;strong&gt;来唠个五毛钱的？&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;如果你看到这里…&lt;code&gt;非常感谢🥰祝你今天好心情！！！&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;是 HR →&lt;/strong&gt; 欢迎随时联系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是同行 →&lt;/strong&gt; 求分享防脱发秘籍，长时间写代码头发真的越来越秃了。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是校友 →&lt;/strong&gt; 相逢即是缘。来二餐一，请你喝我老家蜜雪。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
            <title>专题1️⃣ 滑动窗口</title>
            <link>https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
            <category>算法</category>
            <category>字符串</category>
            <category>滑动窗口</category>
            <category>力扣</category>
            <category>哈希表</category>
            <pubDate>Wed, 12 Mar 2025 18:20:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;今天照例每日一题，然后麻溜的看题解，发现又是一道滑动窗口题。所以开个专题归类一下。&lt;/p&gt;
&lt;h1 id=&#34;2269-找到一个数字的-K-美丽值&#34;&gt;&lt;a href=&#34;#2269-找到一个数字的-K-美丽值&#34; class=&#34;headerlink&#34; title=&#34;2269.找到一个数字的 K 美丽值&#34;&gt;&lt;/a&gt;2269.找到一个数字的 K 美丽值&lt;/h1&gt;&lt;p&gt;今天字符串也要美丽了🆘&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个整数num的k美丽值定义为num中符合以下条件的子字符串数目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子字符串长度为k。&lt;/li&gt;
&lt;li&gt;子字符串能整除num。&lt;br&gt;给你整数num和k，请你返回num的k美丽值。&lt;br&gt;注意：&lt;br&gt;允许有前缀0。&lt;br&gt;0不能整除任何值。&lt;br&gt;一个子字符串是一个字符串里的连续一段字符序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= num &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= num.length&lt;/code&gt; （将 num 视为字符串）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;我觉得这道的要点就是子串怎么得，剩下的就好判断了。偏偏我就栽在这儿了😅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;int转string&lt;/strong&gt; &lt;code&gt;to_string()&lt;/code&gt;注意此函数需要赋给个string变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;string转int&lt;/strong&gt; &lt;code&gt;stoi()&lt;/code&gt;同样，需要赋给个int变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取长度为k的字符串&lt;/strong&gt; &lt;code&gt;substr(i,k)&lt;/code&gt;距离c++学这个函数已经过了一两年了，忘的一干二净，趁此好机会来总结一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;获取子串&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;substr(pos,len)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;从pos开始，提取长度为len的子串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;查找字符串&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;find(str,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在pos之后查找str的位置，找不到返回string::pos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;rfind(str,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;逆向查找str,从pos开始向前找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;find_first_of(chars,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;查找chars中的任意字符的第一次出现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;find_last_of(chars,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;查找chars中的任意字符的最后一次出现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;替换字符串&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;replace(pos,len,str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;从pos开始，用str替换len个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;erase(pos,len)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;删除从pos开始的len个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;insert(pos,str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在pos位置插入str&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;大小写转换&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;toupper(c)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;将字符c转换为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;tolower(c)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;将字符c转换为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;数字与字符串转换&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;to_string(num)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把num转换为字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;stoi(str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把str转换为int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;stol(str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把str转换为long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;stod(str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把str转换为double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int divisorSubstrings(int num, int k) &amp;#123;
        int cnt=0;
        string str=to_string(num);
        for(int i=0;i&amp;lt;=str.size()-k;i++)&amp;#123;
            string ans=str.substr(i,k);
            int answer=stoi(ans);
            if(answer!=0 &amp;amp;&amp;amp; num%answer==0)&amp;#123;
                cnt++;
            &amp;#125;
        &amp;#125;
        return cnt;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3305-元音辅音字符串计数Ⅰ&#34;&gt;&lt;a href=&#34;#3305-元音辅音字符串计数Ⅰ&#34; class=&#34;headerlink&#34; title=&#34;3305.元音辅音字符串计数Ⅰ&#34;&gt;&lt;/a&gt;3305.元音辅音字符串计数Ⅰ&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串word和一个非负整数 k。&lt;br&gt;返回word的子字符串中，每个元音字母（’a’、’e’、’i’、’o’、’u’）至少出现一次，并且恰好包含k个辅音字母的子字符串的总数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5 &amp;lt;&amp;#x3D; word.length &amp;lt;&amp;#x3D; 250&lt;/li&gt;
&lt;li&gt;word 仅由小写英文字母组成。&lt;/li&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; word.length - 5&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;先试了试暴力😤循环套三层观感太差，不放上来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正经解法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口代替暴力循环&lt;/li&gt;
&lt;li&gt;哈希表统计元音出现次数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意几个用法&lt;/strong&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;1️⃣ 几个键值对容器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;键值对容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;实现方式&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;键值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是否有序&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找键对应的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要有序键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找元素是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要排序的集合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2️⃣ 键值对容器+函数求的是什么？&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unordered_map.size()&lt;/code&gt;返回unordered_map中&lt;strong&gt;键值对的数量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unordered_set.count(x)&lt;/code&gt;unordered_set中&lt;strong&gt;某个元素是否存在&lt;/strong&gt;，返回1表示在，0表示不在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码思路如下。这个方法时间空间上并非最优，后续需要调整思路。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;定义n：word长度;
定义unordered_map类型的vowel_cnt:元音出现次数;
定义consonant_cnt:辅音个数;
定义ans：统计最终答案;
定义unordered_set类型的vowels:所有元音字母;
定义左指针j=0;
遍历word从下标0~word.size():
    定义右元素right=word[i];
    统计元音出现次数：
        进行元/辅音计数;
    当辅音数量超过k://收缩窗口左边界
        定义左元素left=word[左指针];//取左边界字符
        如果left是元音：
            该元音出现次数--;
            当元音的计数减少到0时：
                将它从vowel_cnt中删除；
        否则：
            辅音个数--;
        左指针右移;
    如果包含所有元音且辅音个数为k:
        //避免修改原窗口状态,思路整体与上半部分相同☝️
        定义临时变量temp_vowel=vowel_cnt;
        定义临时变量temp_consonant=consonant_cnt;
        定义临时变量temp_j=j;
        定义计数cnt=0;
        当临时左下标&amp;lt;=右下标:
            如果包含所有临时元音且临时辅音个数为k:
                cnt++;
            否则:
                退出该层循环;
            定义c:word[临时左指针];
            如果c是元音：
                临时该元音出现次数--;
                当临时元音的计数减少到0时：
                    将它从临时vowel_cnt中删除;
            否则:
                临时辅音个数--;
            临时左指针j右移;
        ans+=cnt;
返回ans;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int countOfSubstrings(string word, int k) &amp;#123;
        int len=word.size();
        unordered_map&amp;lt;char,int&amp;gt;vowel_cnt;
        int consonant_cnt=0;
        int ans=0;
        unordered_set&amp;lt;int&amp;gt;vowels=&amp;#123;&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;u&amp;#39;&amp;#125;;
        int j=0;
        for(int i=0;i&amp;lt;len;i++)&amp;#123;
            char right=word[i];
            if(vowels.count(right))&amp;#123;
                vowel_cnt[right]++;
            &amp;#125;
            else&amp;#123;
                consonant_cnt++;
            &amp;#125;
            while(consonant_cnt&amp;gt;k)&amp;#123;
                char left=word[j];
                if(vowels.count(left))&amp;#123;
                    vowel_cnt[left]--;
                    if(vowel_cnt[left]==0)&amp;#123;
                        vowel_cnt.erase(left);
                    &amp;#125;
                &amp;#125;
                else&amp;#123;
                    consonant_cnt--;
                &amp;#125;
                j++;
            &amp;#125;
            if(vowel_cnt.size()==5 &amp;amp;&amp;amp; consonant_cnt==k)&amp;#123;
                unordered_map&amp;lt;char,int&amp;gt;temp_vowel=vowel_cnt;
                int temp_consonant=consonant_cnt;
                int temp_j=j;
                int cnt=0;
                while(temp_j&amp;lt;=i)&amp;#123;
                    if(temp_vowel.size()==5 &amp;amp;&amp;amp; temp_consonant==k)&amp;#123;
                        cnt++;
                    &amp;#125;
                    else&amp;#123;
                        break;
                    &amp;#125;
                    int c=word[temp_j];
                    if(vowels.count(c))&amp;#123;
                        temp_vowel[c]--;
                        if(temp_vowel[c]==0)&amp;#123;
                            temp_vowel.erase(c);
                        &amp;#125;
                    &amp;#125;
                    else&amp;#123;
                        temp_consonant--;
                    &amp;#125;
                    temp_j++;
                &amp;#125;
                ans+=cnt;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3306-元音辅音字符串计数Ⅱ&#34;&gt;&lt;a href=&#34;#3306-元音辅音字符串计数Ⅱ&#34; class=&#34;headerlink&#34; title=&#34;3306.元音辅音字符串计数Ⅱ&#34;&gt;&lt;/a&gt;3306.元音辅音字符串计数Ⅱ&lt;/h1&gt;&lt;p&gt;不行，彻底懵了脑子转不动做梦都是元辅音😫先把copy的官方题解放这，过两天我再苟回来看。&lt;/p&gt;
&lt;h2 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h2 id=&#34;完整代码-2&#34;&gt;&lt;a href=&#34;#完整代码-2&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    long long countOfSubstrings(string word, int k) &amp;#123;
        set&amp;lt;char&amp;gt; vowels = &amp;#123;&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;&amp;#125;;
        auto count = [&amp;amp;](int m) -&amp;gt; long long &amp;#123;
            int n = word.size(), consonants = 0;
            long long res = 0;
            map&amp;lt;char, int&amp;gt; occur;
            for (int i = 0, j = 0; i &amp;lt; n; i++) &amp;#123;
                while (j &amp;lt; n &amp;amp;&amp;amp; (consonants &amp;lt; m || occur.size() &amp;lt; vowels.size())) &amp;#123;
                    if (vowels.count(word[j])) &amp;#123;
                        occur[word[j]]++;
                    &amp;#125; else &amp;#123;
                        consonants++;
                    &amp;#125;
                    j++;
                &amp;#125;
                if (consonants &amp;gt;= m &amp;amp;&amp;amp; occur.size() == vowels.size()) &amp;#123;
                    res += n - j + 1;
                &amp;#125;
                if (vowels.count(word[i])) &amp;#123;
                    occur[word[i]]--;
                    if (occur[word[i]] == 0) &amp;#123;
                        occur.erase(word[i]);
                    &amp;#125;
                &amp;#125; else &amp;#123;
                    consonants--;
                &amp;#125;
            &amp;#125;
            return res;
        &amp;#125;;
        return count(k) - count(k + 1);
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/</guid>
            <title>Leetcode链表</title>
            <link>https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/</link>
            <category>算法</category>
            <category>力扣</category>
            <category>链表</category>
            <pubDate>Thu, 06 Mar 2025 10:25:28 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;链表这东西真的学一阵忘一阵😂&lt;/p&gt;
&lt;h1 id=&#34;单向链表&#34;&gt;&lt;a href=&#34;#单向链表&#34; class=&#34;headerlink&#34; title=&#34;单向链表&#34;&gt;&lt;/a&gt;单向链表&lt;/h1&gt;&lt;h2 id=&#34;结构定义&#34;&gt;&lt;a href=&#34;#结构定义&#34; class=&#34;headerlink&#34; title=&#34;结构定义&#34;&gt;&lt;/a&gt;结构定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;节点结构 &lt;code&gt;ListNode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指向下一个节点的指针 &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct ListNode&amp;#123;
    int data;
    ListNode* next;
    ListNode(int x):data(x),next(nullptr)&amp;#123;&amp;#125;
&amp;#125;Node;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;&lt;a href=&#34;#基本操作&#34; class=&#34;headerlink&#34; title=&#34;基本操作&#34;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&#34;创建链表&#34;&gt;&lt;a href=&#34;#创建链表&#34; class=&#34;headerlink&#34; title=&#34;创建链表&#34;&gt;&lt;/a&gt;创建链表&lt;/h3&gt;&lt;p&gt;定义单链表类，封装基本操作。下面的几个操作都在public里~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class LinkedList&amp;#123;
public:
    ListNode* head;
    LinkedList():head(nullptr);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;插入节点&#34;&gt;&lt;a href=&#34;#插入节点&#34; class=&#34;headerlink&#34; title=&#34;插入节点&#34;&gt;&lt;/a&gt;插入节点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;头插法:新节点加到链表头部&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void insertAtHead(int data)&amp;#123;
    ListNode* newNode=new ListNode(data);
    newNode-&amp;gt;next=head;
    head=newNode;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;尾插法：:新节点加到链表尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;void insertAtTail(int data)&amp;#123;
    ListNode* newNode=new ListNode(data);
    if(!head)&amp;#123;
        head=newNode;
        return;
    &amp;#125;
    ListNode* temp=head;
    while(temp-&amp;gt;next)&amp;#123;
        temp=temp-&amp;gt;next;
    &amp;#125;
    temp-&amp;gt;next=newNode;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除节点&#34;&gt;&lt;a href=&#34;#删除节点&#34; class=&#34;headerlink&#34; title=&#34;删除节点&#34;&gt;&lt;/a&gt;删除节点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;void deleteNode(int data)&amp;#123;
    if(!head)&amp;#123;
        return;
    &amp;#125;
    if(head-&amp;gt;data==data)&amp;#123;
        ListNode* temp=head;
        head=head-&amp;gt;next;
        delete temp;
        return;
    &amp;#125;
    ListNode* temp=head;
    while(temp-&amp;gt;next &amp;amp;&amp;amp; temp-&amp;gt;next-&amp;gt;val !=val)&amp;#123;
        temp=temp-&amp;gt;next;
    &amp;#125;
    if(temp-&amp;gt;next)&amp;#123;
        ListNode* delNode=temp-&amp;gt;next;
        temp-&amp;gt;next=temp-&amp;gt;next-&amp;gt;next;
        delete delNode;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改节点&#34;&gt;&lt;a href=&#34;#修改节点&#34; class=&#34;headerlink&#34; title=&#34;修改节点&#34;&gt;&lt;/a&gt;修改节点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;void updateNode(int oldData,newData)&amp;#123;
    ListNode* temp=head;
    while(temp)&amp;#123;
        if(temp-data==oldData)&amp;#123;
            temp-&amp;gt;data==oldData;
            return;
        &amp;#125;
        temp=temp-&amp;gt;next;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查找节点&#34;&gt;&lt;a href=&#34;#查找节点&#34; class=&#34;headerlink&#34; title=&#34;查找节点&#34;&gt;&lt;/a&gt;查找节点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;bool searchNode(int data)&amp;#123;
    ListNode* temp=head;
    while(temp)&amp;#123;
        if(temp-&amp;gt;data==data)&amp;#123;
            return true;
        &amp;#125;
    &amp;#125;
    return false;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打印链表&#34;&gt;&lt;a href=&#34;#打印链表&#34; class=&#34;headerlink&#34; title=&#34;打印链表&#34;&gt;&lt;/a&gt;打印链表&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;void printList()&amp;#123;
    ListNode* temp=head;
    while(temp)&amp;#123;
        cout&amp;lt;&amp;lt;temp-&amp;gt;val&amp;lt;&amp;lt;&amp;quot;-&amp;gt;&amp;quot;;
        temp=temp-&amp;gt;next;
    &amp;#125;
    cout&amp;lt;&amp;lt;&amp;quot;NULL&amp;quot;&amp;lt;&amp;lt;endl;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;释放链表内存&#34;&gt;&lt;a href=&#34;#释放链表内存&#34; class=&#34;headerlink&#34; title=&#34;释放链表内存&#34;&gt;&lt;/a&gt;释放链表内存&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;~LinkedList()&amp;#123;
    while(head)&amp;#123;
        ListNode* temp=head;
        head=head-&amp;gt;next;
        delete temp;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-合并两个有序链表&#34;&gt;&lt;a href=&#34;#21-合并两个有序链表&#34; class=&#34;headerlink&#34; title=&#34;21.合并两个有序链表&#34;&gt;&lt;/a&gt;21.合并两个有序链表&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;br&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个链表的节点数目范围是 [0, 50]&lt;/li&gt;
&lt;li&gt;-100 &amp;lt;&amp;#x3D; Node.val &amp;lt;&amp;#x3D; 100&lt;/li&gt;
&lt;li&gt;l1和l2均按非递减顺序排列&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;👉️ &lt;em&gt;&lt;strong&gt;终止条件&lt;/strong&gt;&lt;/em&gt;：有链表为空&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list1为空，合并结果直接为list2&lt;/li&gt;
&lt;li&gt;list2为空，合并结果直接为list1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👉️ &lt;em&gt;&lt;strong&gt;递归调用&lt;/strong&gt;&lt;/em&gt;：小的打头，每一步递归后返回的值链接到链表末尾&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;list1节点的值 &amp;lt; list2&lt;/code&gt;：寻找list1后面节点还有没有也比list2小的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;让list1-&amp;gt;next接上递归后合并的结果；
返回当前较小的节点list1;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;else：寻找list2后面节点还有没有也比list1小的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;让list2-&amp;gt;next接上递归后合并的结果；
返回当前较小的节点list2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode &amp;#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &amp;#123;&amp;#125;
 *     ListNode(int x) : val(x), next(nullptr) &amp;#123;&amp;#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &amp;#123;&amp;#125;
 * &amp;#125;;
 */
class Solution &amp;#123;
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &amp;#123;
        if(list1==NULL || list2==NULL)&amp;#123;
            return list1==NULL ? list2:list1;
        &amp;#125;
        if(list1-&amp;gt;val &amp;lt; list2-&amp;gt;val)&amp;#123;
            list1-&amp;gt;next = mergeTwoLists(list1-&amp;gt;next,list2);
            return list1;
        &amp;#125;
        else&amp;#123;
            list2-&amp;gt;next = mergeTwoLists(list1,list2-&amp;gt;next);
            return list2;
        &amp;#125;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/05/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
            <title>Leetcode字符串</title>
            <link>https://232akira.github.io/2025/03/05/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
            <category>算法</category>
            <category>字符串</category>
            <category>滑动窗口</category>
            <pubDate>Wed, 05 Mar 2025 15:22:48 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;58-最后一个单词的长度&#34;&gt;&lt;a href=&#34;#58-最后一个单词的长度&#34; class=&#34;headerlink&#34; title=&#34;58.最后一个单词的长度&#34;&gt;&lt;/a&gt;58.最后一个单词的长度&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;KMP有点难理解了对我而言…看不懂就放两天继续钻，再多看看大佬博客的不同理解，效果会更好。&lt;/p&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;参考链接：&lt;br&gt;&lt;a href=&#34;https://www.cnblogs.com/dusf/p/kmp.html&#34;&gt;1️⃣&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://blog.csdn.net/yyzsir/article/details/89462339?ops_request_misc=%257B%2522request%255Fid%2522%253A%252292dce769a412320e26ef79eb85ca18cd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=92dce769a412320e26ef79eb85ca18cd&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-89462339-null-null.142%5Ev101%5Epc_search_result_base5&amp;utm_term=yyzsir%20kmp&amp;spm=1018.2226.3001.4187&#34;&gt;2️⃣&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;朴素模式匹配BF&#34;&gt;&lt;a href=&#34;#朴素模式匹配BF&#34; class=&#34;headerlink&#34; title=&#34;朴素模式匹配BF&#34;&gt;&lt;/a&gt;朴素模式匹配&lt;code&gt;BF&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;首先来个&lt;strong&gt;暴力&lt;/strong&gt;方法：不匹配模式串就右挪一位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//暴力模式匹配
int 主串位置i；
int 模式串位置j；
int 主串长度；
int 子串长度；

当（主串位置 &amp;lt;= 主串长度 &amp;amp;&amp;amp; 模式串位置&amp;lt;模式串长度）:
    如果（该主串位置的主串字符 == 该模式串位置的模式串字符）：
        i++；
        j++；
    否则：
        i后退至上一轮匹配开始位置的后一位；
        j归零；
如果（模式串位置 == 模式串长度）：
    匹配成功，返回出现位置；
否则
    匹配失败，返回-1；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;优化模式匹配KMP&#34;&gt;&lt;a href=&#34;#优化模式匹配KMP&#34; class=&#34;headerlink&#34; title=&#34;优化模式匹配KMP&#34;&gt;&lt;/a&gt;优化模式匹配&lt;code&gt;KMP&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;即利用&lt;strong&gt;已经部分匹配&lt;/strong&gt;这个信息，保持&lt;strong&gt;i指针不回溯&lt;/strong&gt;，并通过j指针让&lt;strong&gt;模式串&lt;/strong&gt;尽可能移动到&lt;strong&gt;更有效的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么有几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;前缀(Prefix)和后缀（Suffix）&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;举个🌰，给定一个字符串s:&lt;code&gt;“abcab”&lt;/code&gt;,那么:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;s的子串&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;strong&gt;前缀&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;strong&gt;后缀&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a,ab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;c,bc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abca&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a,ab,abc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a,ca,bca&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abcab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a,ab,abc,abca&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b,ab,cab,bcab&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;公共前后缀最长长度&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;从上面的前后缀不难看出，对于s的子串，存在部分前后缀重复的情况，我们需要的正是重复子串的最大长度。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;s的子串&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;前缀&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;后缀&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;strong&gt;公共前后缀最长长度&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a,ab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;c,bc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abca&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;a&lt;/code&gt;,ab,abc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;a&lt;/code&gt;,ca,bca&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abcab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a,&lt;code&gt;ab&lt;/code&gt;,abc,abca&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b,&lt;code&gt;ab&lt;/code&gt;,cab,bcab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;next数组（部分匹配表）&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;KMP的next数组告诉我们：当模式串中的某个字符跟主串中的某个字符失配时，模式串下一步应该跳到哪个位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于s的&lt;strong&gt;每个字符&lt;/strong&gt;而言，当这个字符作为子串的最后一位时，公共前后缀最长长度为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;字符（标红部分）&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;公共前后缀最长长度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;a&lt;/code&gt;bcab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;code&gt;b&lt;/code&gt;cab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ab&lt;code&gt;c&lt;/code&gt;ab&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abc&lt;code&gt;a&lt;/code&gt;b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;abca&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;那么全部右移一位，令next[0]&amp;#x3D;-1：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;字符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;i&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;next[i]&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;c&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;a&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;b&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;实际匹配过程中，j移动到子串p的next[j]位置，p相对s向右移动j-next[j]位置。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;迭代法求p的next数组&lt;/strong&gt;&lt;br&gt;我们知道：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;next[0]=-1;
next[1]=0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并且&lt;code&gt;next[j]&lt;/code&gt;代表p[0…j-1]的子串公共前后缀最长长度。&lt;br&gt;∴ 变量定义如下：&lt;br&gt;&lt;code&gt;j&lt;/code&gt;：当前子串指针&lt;br&gt;&lt;code&gt;k&lt;/code&gt;：当前匹配的前后缀长度（&amp;#x3D;next[j-1]）&lt;br&gt;&lt;code&gt;next[j]=k&lt;/code&gt;：next[0]&amp;#x3D;-1 即当p[0]都匹配失败时，只能回到j&amp;#x3D;0重新匹配。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void GetNext(char p[], int next[])
&amp;#123;
    int j = 0, k = -1;
    next[j] = k;
    while (p[j] != &amp;#39;\0&amp;#39;)             //遍历整个子串p
    &amp;#123;
        if (k == -1 || p[j] == p[k]) //匹配成功😀或者k=-1（刚匹配到字串的第一个）
        &amp;#123;
            j++;                     //j指针后移
            k++;
            next[j] = k;             //记录当前前后缀匹配长度
        &amp;#125; 
        else 
        &amp;#123;
            k = next[k];             //匹配失败😭，回溯到next[k]寻找更短的前后缀
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;KMP主算法&lt;br&gt;得到next数组的方法&lt;code&gt;GetNext()&lt;/code&gt;，就可以完整的写出KMP函数。这里写成一个函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int KMP(string s,string p)&amp;#123;
    int m=s.size();
    int n=p.size();
    if(m==0)&amp;#123;
        return 0;
    &amp;#125;
    //⬇️计算next数组
    vector&amp;lt;int&amp;gt;next;
    int j=0;
    for(int i=0;i&amp;lt;n;i++)&amp;#123;
        while(j&amp;gt;0 &amp;amp;&amp;amp; p[i]!=p[j])&amp;#123;
            j=next[j-1];
        &amp;#125;
        if(p[i]==p[j])&amp;#123;
            j++;
        &amp;#125;
        next[i]=j;
    &amp;#125;
    //⬇️KMP搜索匹配
    int j=0;
    for(int i=0;i&amp;lt;m;i++)&amp;#123;
        while(j&amp;gt;0 &amp;amp;&amp;amp; s[i]!=p[j])&amp;#123;
            j=next[j-1];
        &amp;#125;
        if(s[i]==p[j])&amp;#123;
            j++;
        &amp;#125;
        if(j==n)&amp;#123;
            return i-n+1;
        &amp;#125;
    &amp;#125;
    return -1;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说实话，后半部分现在不能完全理解，让我再多磕几天。&lt;/p&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int lengthOfLastWord(string s) &amp;#123;
        int len=s.length();
        int m=0,n=0;
        for(int i=len-1;i&amp;gt;0;i--)&amp;#123;
            if(s[i]!=&amp;#39; &amp;#39; &amp;amp;&amp;amp; (s[i+1]==&amp;#39; &amp;#39; || s[i+1]==&amp;#39;\0&amp;#39;))&amp;#123;
                m=i;
            &amp;#125;
            if((s[i-1]==&amp;#39; &amp;#39; || s[i-1]==&amp;#39;\0&amp;#39;) &amp;amp;&amp;amp; s[i]!=&amp;#39; &amp;#39;)&amp;#123;
                n=i;
                break;
            &amp;#125;
        &amp;#125;
        return m-n+1;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1021-删除最外层的括号&#34;&gt;&lt;a href=&#34;#1021-删除最外层的括号&#34; class=&#34;headerlink&#34; title=&#34;1021.删除最外层的括号&#34;&gt;&lt;/a&gt;1021.删除最外层的括号&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。&lt;br&gt;例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。&lt;br&gt;如果有效字符串 s 非空，且不存在将其拆分为 s &amp;#x3D; A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。&lt;br&gt;给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s &amp;#x3D; P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。&lt;br&gt;对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; s.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;s[i] 为 ‘(‘ 或 ‘)’&lt;/li&gt;
&lt;li&gt;s 是一个有效括号字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/</guid>
            <title>Leetcode数组</title>
            <link>https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/</link>
            <category>C++</category>
            <category>力扣</category>
            <category>数组</category>
            <category>哈希表</category>
            <category>动态规划</category>
            <category>二分查找</category>
            <pubDate>Tue, 04 Mar 2025 19:15:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;本来想一道题一篇文，但是做的大多是简单题所以按模块归类好复习一点。&lt;/p&gt;
&lt;h1 id=&#34;1232-缀点成线&#34;&gt;&lt;a href=&#34;#1232-缀点成线&#34; class=&#34;headerlink&#34; title=&#34;1232.缀点成线&#34;&gt;&lt;/a&gt;1232.缀点成线&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 coordinates ，其中 coordinates[i] &amp;#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 &amp;lt;&amp;#x3D; coordinates.length &amp;lt;&amp;#x3D; 1000&lt;/li&gt;
&lt;li&gt;coordinates[i].length &amp;#x3D;&amp;#x3D; 2&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt;&amp;#x3D; coordinates[i][0], coordinates[i][1] &amp;lt;&amp;#x3D; 10^4&lt;/li&gt;
&lt;li&gt;coordinates 中不含重复的点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;我本来是想着soeasy，用y&amp;#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…&lt;/p&gt;
&lt;p&gt;那么就不使用斜率，而是使用&lt;strong&gt;斜率交叉乘法&lt;/strong&gt;：如果所有点都在同一条直线上，那么&lt;strong&gt;对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等&lt;/strong&gt;。也就是&lt;code&gt;(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)&lt;/code&gt;。为避免除法带来的浮点误差，用&lt;strong&gt;交叉相乘&lt;/strong&gt;验证更好。&lt;br&gt;&lt;em&gt;&lt;strong&gt;并且注意！&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;因为我的验证方法需要三个点，但是这道题有可&lt;code&gt;coordinates,length=2&lt;/code&gt;的情况，那就直接返回true，因为&lt;strong&gt;两点确定一条直线&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    bool checkStraightLine(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; coordinates) &amp;#123;
        int x1,y1,x2,y2;
        x1=coordinates[0][0];
        y1=coordinates[0][1];
        x2=coordinates[1][0];
        y2=coordinates[1][1];
        if(coordinates.size()==2)&amp;#123;
            return true;
        &amp;#125;
        for(int i=2;i&amp;lt;coordinates.size();i++)&amp;#123;
            int x3=coordinates[i][0];
            int y3=coordinates[i][1];
            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&amp;#123;
                return false;
            &amp;#125;
        &amp;#125;
        return true;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2597-美丽子集的数目&#34;&gt;&lt;a href=&#34;#2597-美丽子集的数目&#34; class=&#34;headerlink&#34; title=&#34;2597.美丽子集的数目&#34;&gt;&lt;/a&gt;2597.美丽子集的数目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个由正整数组成的数组 nums 和一个 正 整数 k 。&lt;br&gt;如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。&lt;br&gt;返回数组 nums 中 非空 且 美丽 的子集数目。&lt;br&gt;nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 18&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i], k &amp;lt;&amp;#x3D; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;涉及&lt;strong&gt;子集&lt;/strong&gt;相关问题，一般有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回溯&lt;/li&gt;
&lt;li&gt;位运算&lt;br&gt;本题选择&lt;strong&gt;回溯&lt;/strong&gt;算法。因为该方法可在生成子集时&lt;strong&gt;剪枝&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设 nums &amp;#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;          dfs(0)
        /        \
    不选2        选2
     / \         /  \
  不选4  选4   不选4  选4
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int ans=0;
    void dfs(int index,vector&amp;lt;int&amp;gt;&amp;amp; nums,unordered_map&amp;lt;int,int&amp;gt;&amp;amp; freq,int k)&amp;#123;
        if(index==nums.size())&amp;#123;
            ans++;
            return;
        &amp;#125;
        dfs(index+1,nums,freq,k);
        if(freq[nums[index]-k]==0 &amp;amp;&amp;amp; freq[nums[index]+k]==0)&amp;#123;
            freq[nums[index]]++;
            dfs(index+1,nums,freq,k);
            freq[nums[index]]--;
        &amp;#125;
    &amp;#125;
    int beautifulSubsets(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) &amp;#123;
        unordered_map&amp;lt;int,int&amp;gt; freq;
        dfs(0,nums,freq,k);
        return ans-1;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2070-每一个查询的最大美丽值&#34;&gt;&lt;a href=&#34;#2070-每一个查询的最大美丽值&#34; class=&#34;headerlink&#34; title=&#34;2070.每一个查询的最大美丽值&#34;&gt;&lt;/a&gt;2070.每一个查询的最大美丽值&lt;/h1&gt;&lt;p&gt;又美丽了家人们🤣&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个二维整数数组 items ，其中 items[i] &amp;#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。&lt;br&gt;同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。&lt;br&gt;请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;br&gt;-1 &amp;lt;&amp;#x3D; items.length, queries.length &amp;lt;&amp;#x3D; 105&lt;br&gt;-items[i].length &amp;#x3D;&amp;#x3D; 2&lt;br&gt;-1 &amp;lt;&amp;#x3D; pricei, beautyi, queries[j] &amp;lt;&amp;#x3D; 109&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h3 id=&#34;二分查找&#34;&gt;&lt;a href=&#34;#二分查找&#34; class=&#34;headerlink&#34; title=&#34;二分查找&#34;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;p&gt;首先复习一下二分查找，我又忘了咋写。&lt;a href=&#34;https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/&#34;&gt;另一篇&lt;/a&gt;copy来的&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;要查找的目标&lt;code&gt;target&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;索引&lt;code&gt;index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左、右指示符&lt;code&gt;left&lt;/code&gt;、&lt;code&gt;right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中间指示符&lt;code&gt;mid&lt;/code&gt;&lt;br&gt;主要思路就是计算&lt;code&gt;mid&lt;/code&gt;的位置：&lt;br&gt;1️⃣&lt;code&gt;nums[mid] == target&lt;/code&gt; 🤭找到了&lt;br&gt;2️⃣&lt;code&gt;nums[mid] &amp;lt; target&lt;/code&gt; → target在left的右边 → left右移 👉️left&amp;#x3D;mid+1;&lt;br&gt;3️⃣&lt;code&gt;nums[mid] &amp;gt; target&lt;/code&gt; → target在right的左边 → right左移 👉️right&amp;#x3D;mid-1;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//形参：vector&amp;lt;int&amp;gt;nums,int target
int left=0;
int right=nums.size()-1;
while(left&amp;lt;=right)&amp;#123;
    int mid=left+(right-left)/2;
    if(nums[mid]=target)&amp;#123;
        return mid;
    &amp;#125;
    else if(nums[mid]&amp;lt;target)&amp;#123;
        left=mid+1;
    &amp;#125;
    else&amp;#123;
        right=mid-1;
    &amp;#125;
    return index;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;本题思路&#34;&gt;&lt;a href=&#34;#本题思路&#34; class=&#34;headerlink&#34; title=&#34;本题思路&#34;&gt;&lt;/a&gt;本题思路&lt;/h3&gt;&lt;h4 id=&#34;方法一&#34;&gt;&lt;a href=&#34;#方法一&#34; class=&#34;headerlink&#34; title=&#34;方法一&#34;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; maximumBeauty(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; items, vector&amp;lt;int&amp;gt;&amp;amp; queries) &amp;#123;
        vector&amp;lt;int&amp;gt; answer(queries.size(),0);
        for(int j=0;j&amp;lt;queries.size();j++)&amp;#123;
            int target=queries[j];
            int maxnum=0;
            for(int i=0;i&amp;lt;items.size();i++)&amp;#123;
                if(items[i][0]&amp;lt;=target)&amp;#123;
                    maxnum=max(maxnum,items[i][1]);
                &amp;#125;
            &amp;#125;
            answer[j]=maxnum;
        &amp;#125;
        return answer;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法二&#34;&gt;&lt;a href=&#34;#方法二&#34; class=&#34;headerlink&#34; title=&#34;方法二&#34;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;老老实实用二分。注意：二分查找的前提是&lt;strong&gt;有序&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先按照price递增排序;&lt;/li&gt;
&lt;li&gt;定义美丽数组;&lt;/li&gt;
&lt;li&gt;遍历items:&lt;strong&gt;存储当前遍历到的最大美丽值&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;定义答案数组;&lt;/li&gt;
&lt;li&gt;遍历querties：&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二分查找目标🤟&lt;code&gt;items[i][0] &amp;lt;= queries[j]&lt;/code&gt; 的最大 i&lt;br&gt;有点绕了，兄弟兄弟…&lt;/p&gt;
&lt;h2 id=&#34;完整代码-2&#34;&gt;&lt;a href=&#34;#完整代码-2&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; maximumBeauty(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; items, vector&amp;lt;int&amp;gt;&amp;amp; queries) &amp;#123;
        sort(items.begin(),items.end());
        vector&amp;lt;int&amp;gt;maxbeauty(items.size());
        maxbeauty[0]=items[0][1];
        for(int i=1;i&amp;lt;items.size();i++)&amp;#123;
            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);
        &amp;#125;
        vector&amp;lt;int&amp;gt;answer(queries.size(),0);
        for(int j=0;j&amp;lt;queries.size();j++)&amp;#123;
            int target=queries[j];
            int left=0;
            int right=items.size()-1;
            int index=-1;
            while(left&amp;lt;=right)&amp;#123;
                int mid=left+(right-left)/2;
                if(items[mid][0]&amp;lt;=target)&amp;#123;
                    index=mid;
                    left=mid+1;
                &amp;#125;
                else&amp;#123;
                    right=mid-1;
                &amp;#125;
            &amp;#125;
            if(index!=-1)&amp;#123;
                answer[j]=maxbeauty[index];
            &amp;#125;
        &amp;#125;
        return answer;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2269-找到一个数字的-K-美丽值&#34;&gt;&lt;a href=&#34;#2269-找到一个数字的-K-美丽值&#34; class=&#34;headerlink&#34; title=&#34;2269.找到一个数字的 K 美丽值&#34;&gt;&lt;/a&gt;2269.找到一个数字的 K 美丽值&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从0开始的整数数组nums。对于每个下标i（1 &amp;lt;&amp;#x3D; i &amp;lt;&amp;#x3D; nums.length - 2），nums[i] 的美丽值等于：&lt;br&gt;2，对于所有 0 &amp;lt;&amp;#x3D; j &amp;lt; i 且 i &amp;lt; k &amp;lt;&amp;#x3D; nums.length - 1 ，满足 nums[j] &amp;lt; nums[i] &amp;lt; nums[k]&lt;br&gt;1，如果满足 nums[i - 1] &amp;lt; nums[i] &amp;lt; nums[i + 1] ，且不满足前面的条件&lt;br&gt;0，如果上述条件全部不满足&lt;br&gt;返回符合 1 &amp;lt;&amp;#x3D; i &amp;lt;&amp;#x3D; nums.length - 2 的所有 nums[i] 的美丽值的总和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-3&#34;&gt;&lt;a href=&#34;#解题思路-3&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;难点在于nums[i]的美丽值为2的情况：&lt;/strong&gt;&lt;br&gt;突然想起来高中数学老师的口头禅：“大于大的，小于小的”。&lt;br&gt;nums[i]需要满足：比其左侧所有的nums[j]更大，以及&lt;em&gt;比其右侧所有的nums&lt;/em&gt;[k]更小。&lt;br&gt;即&lt;strong&gt;大于左侧最大值，小于右侧最小值&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*max_element(arr.begin(),arr.end())&lt;/code&gt;求数组最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*min_element(arr.begin(),arr.end())&lt;/code&gt;求数组最小值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;？超时了😇我还说想清楚了不难呢…&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int sumOfBeauties(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int maxval,minval,ans=0;
        for(int i=1;i&amp;lt;nums.size()-1;i++)&amp;#123;
            maxval=*max_element(nums.begin(),nums.begin()+i);
            minval=*min_element(nums.begin()+i+1,nums.end());
            if(maxval&amp;lt;nums[i] &amp;amp;&amp;amp; minval&amp;gt;nums[i])&amp;#123;
                ans+=2;
            &amp;#125;
            else if(nums[i-1]&amp;lt;nums[i] &amp;amp;&amp;amp; nums[i+1]&amp;gt;nums[i])&amp;#123;
                ans+=1;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进方法就是：左侧最大值和右侧最小值各自都用一个数组存起来所有i的情况，再进行条件判断。同时可以存一个，另一个随每次判断进行更新就好。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义左侧最大int数组leftMax;
遍历i从1到nums.size()：
    leftMax[i]=max(左侧最大数组[i-1],原数组[i-1]);
int 美丽值;
定义右侧最小int变量rightMin并初始化为原数组[length()-1];
遍历i从length()-2到0:
    如果（条件一）：
        美丽值+=2;
    否则如果（条件2）：
        美丽值+=1;
    更新右侧最小值=min（右侧最小值，原数组[i]）;
返回美丽值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码-3&#34;&gt;&lt;a href=&#34;#完整代码-3&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int sumOfBeauties(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        vector&amp;lt;int&amp;gt; leftMax(nums.size(),0);
        for(int i=1;i&amp;lt;nums.size();i++)&amp;#123;
            leftMax[i]=max(leftMax[i-1],nums[i-1]);
        &amp;#125;
        int ans=0;
        int rightMin=nums[nums.size()-1];
        for(int i=nums.size()-2;i&amp;gt;0;i--)&amp;#123;
            if(leftMax[i]&amp;lt;nums[i] &amp;amp;&amp;amp; nums[i]&amp;lt;rightMin)&amp;#123;
                ans+=2;
            &amp;#125;
            else if(nums[i-1]&amp;lt;nums[i] &amp;amp;&amp;amp; nums[i]&amp;lt;nums[i+1])&amp;#123;
                ans+=1;
            &amp;#125;
            rightMin=min(rightMin,nums[i]);
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/04/Leetcode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
            <title>Leetcode贪心算法</title>
            <link>https://232akira.github.io/2025/03/04/Leetcode%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
            <category>算法</category>
            <category>C++</category>
            <pubDate>Tue, 04 Mar 2025 13:41:46 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;力扣连着刷到了几个贪心，而且另一篇笔记字数要爆了，决定先按大类慢慢分一下。&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/180104885&#34;&gt;https://zhuanlan.zhihu.com/p/180104885&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;贪心算法&#34;&gt;&lt;a href=&#34;#贪心算法&#34; class=&#34;headerlink&#34; title=&#34;贪心算法&#34;&gt;&lt;/a&gt;贪心算法&lt;/h2&gt;&lt;p&gt;规律特征就是更加注重当前的状态,通常用于组合优化问题。即每一次都做出&lt;strong&gt;当前&lt;/strong&gt;看起来&lt;strong&gt;最好的&lt;/strong&gt;选择。每次只需要考虑一个问题，并通常是自底向上求解。即&lt;strong&gt;局部最优→全局最优&lt;/strong&gt;。&lt;br&gt;下面上题：&lt;/p&gt;
&lt;h3 id=&#34;Leetcode-No-455-分发饼干&#34;&gt;&lt;a href=&#34;#Leetcode-No-455-分发饼干&#34; class=&#34;headerlink&#34; title=&#34;Leetcode No.455 分发饼干&#34;&gt;&lt;/a&gt;Leetcode No.455 分发饼干&lt;/h3&gt;&lt;p&gt;待续~&lt;/p&gt;
&lt;h3 id=&#34;Leetcode-No-976-三角形的最大周长&#34;&gt;&lt;a href=&#34;#Leetcode-No-976-三角形的最大周长&#34; class=&#34;headerlink&#34; title=&#34;Leetcode No.976 三角形的最大周长&#34;&gt;&lt;/a&gt;Leetcode No.976 三角形的最大周长&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;3 &amp;lt;= nums.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 106&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h4&gt;&lt;p&gt;因为题目需要的是最大的三角形周长，所以不需要暴力列举所有的情况再一一对比，而是直接奔着“最大”这个目标求解就行:&lt;br&gt;三条边a,b,c（假设从小到大已排好），当a+b&amp;gt;c时满足三角形。&lt;strong&gt;如果不满足，必须换更大的a,b&lt;/strong&gt;。&lt;br&gt;贪心优化策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nums排序&lt;/li&gt;
&lt;li&gt;从最大的三个数开始 尝试是否满足&lt;/li&gt;
&lt;li&gt;若无法满足，往前找更小的a,b&lt;/li&gt;
&lt;li&gt;一旦找到符合条件的三边，直接返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    int largestPerimeter(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        sort(nums.begin(),nums.end());
        for(int i=nums.size()-1;i&amp;gt;=2;i++)&amp;#123;
            if(nums[i-1]+nums[i-2]&amp;gt;nums[i])
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;Leetcode-No-860-柠檬水找零&#34;&gt;&lt;a href=&#34;#Leetcode-No-860-柠檬水找零&#34; class=&#34;headerlink&#34; title=&#34;Leetcode No.860 柠檬水找零&#34;&gt;&lt;/a&gt;Leetcode No.860 柠檬水找零&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;br&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;br&gt;注意，一开始你手头没有任何零钱。&lt;br&gt;给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= bills.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bills[i] 不是 5 就是 10 或是 20 &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h4&gt;&lt;p&gt;**找零时，尽量先用大额。**并且只记录5美元、10美元的数量（因为这题目的情况不可能找20块）那么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到5美元  直接收 &lt;/li&gt;
&lt;li&gt;收到10美元 &lt;code&gt;10-5=5&lt;/code&gt; 找5美元（如果有）&lt;/li&gt;
&lt;li&gt;收到20美元 &lt;strong&gt;贪心来了~&lt;/strong&gt;&lt;code&gt;20-5=15&lt;/code&gt;优先使用10+5找零，否则用5+5+5（如果有）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    bool lemonadeChange(vector&amp;lt;int&amp;gt;&amp;amp; bills) &amp;#123;
        int five=0,ten=0;
        for(int bill:bills)&amp;#123;
            if(bill==5)&amp;#123;
                five++;
            &amp;#125;
            else if(bill==10)&amp;#123;
                if(five!=0)&amp;#123;
                    five--;
                    ten++;
                &amp;#125;
                else&amp;#123;
                    return false;
                &amp;#125;
            &amp;#125;
            else if(bill==20)&amp;#123;
                if(ten&amp;gt;0 &amp;amp;&amp;amp; five&amp;gt;0)&amp;#123;
                    ten--;
                    five--;
                &amp;#125;
                else if(five&amp;gt;=3)&amp;#123;
                    five-=3;
                &amp;#125;
                else&amp;#123;
                    return false;
                &amp;#125;
                
            &amp;#125;
        &amp;#125;
        return true;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
            <title>力扣备忘录</title>
            <link>https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/</link>
            <category>算法</category>
            <category>C++</category>
            <category>记录</category>
            <pubDate>Sun, 02 Mar 2025 19:55:55 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;简单题&#34;&gt;&lt;a href=&#34;#简单题&#34; class=&#34;headerlink&#34; title=&#34;简单题&#34;&gt;&lt;/a&gt;简单题&lt;/h1&gt;&lt;h2 id=&#34;283-移动零&#34;&gt;&lt;a href=&#34;#283-移动零&#34; class=&#34;headerlink&#34; title=&#34;283.移动零&#34;&gt;&lt;/a&gt;283.移动零&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;strong&gt;请注意&lt;/strong&gt;，必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;一开始看到这道题就觉得不就是交换嘛。但是发现题目中的：“保持非零元素的相对顺序”我就懵了。于是开始暴力穷举循环一层套一层…后来被拉回正道。&lt;br&gt;核心思想不变，仍是“交换”。&lt;br&gt;但是交换的条件是&lt;strong&gt;将非零元素全部移到数组头部&lt;/strong&gt;，虽然直观看来与题目所引导的“0全部移到末尾”完全反着来，但是我发现这样做比把0移到末尾再对非零元素进行某种交换排序要来的简单得多。题目作者居心叵测啊（不是&lt;/p&gt;
&lt;h3 id=&#34;AC代码&#34;&gt;&lt;a href=&#34;#AC代码&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    void swap(vector&amp;lt;int&amp;gt;&amp;amp; nums,int i,int j)&amp;#123;
        int t;
        t=nums[i];
        nums[i]=nums[j];
        nums[j]=t;
        
    &amp;#125;
    void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int i=0; 
        for(int j=0;j&amp;lt;nums.size();j++)&amp;#123;
            if(nums[j]!=0)&amp;#123;
                swap(nums,i,j);
                i++;
            &amp;#125;
        &amp;#125;

    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;66-加一&#34;&gt;&lt;a href=&#34;#66-加一&#34; class=&#34;headerlink&#34; title=&#34;66.加一&#34;&gt;&lt;/a&gt;66.加一&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。&lt;br&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。&lt;br&gt;你可以假设除了整数 0 之外，这个整数不会以零开头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;判断数组末尾是否有9：
    无9：末尾数字+1;
    有9：
        是否全为9：
            是全9：
                构造长度=size+1的数组，首位=1，其余全置0;
            非全9：
                找到倒着数第一个不是9的元素,
                该元素加1,
                末尾所有的9置0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-1&#34;&gt;&lt;a href=&#34;#AC代码-1&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) &amp;#123;
        int len=digits.size();
        if(digits[len-1]!=9)&amp;#123;
            digits[len-1]+=1;
        &amp;#125;
        else&amp;#123;
            int cnt=0;//记录9出现的次数，第一个非9元素的下标即为len-cnt-1
            for(int i=len-1;i&amp;gt;=0;i--)&amp;#123;
                if(digits[i]==9)&amp;#123;
                    cnt++;
                &amp;#125;
                else&amp;#123;
                    break;
                &amp;#125;
            &amp;#125;
            if(cnt==len)&amp;#123;
                digits.insert(digits.begin(),1);
                for(int i=1;i&amp;lt;len+1;i++)&amp;#123;
                    digits[i]=0;
                &amp;#125;
            &amp;#125;
            else&amp;#123;
                int index=len-cnt-1;
                digits[index]+=1;
                for(int i=index+1;i&amp;lt;len;i++)&amp;#123;
                    digits[i]=0;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return digits;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;896-单调数列&#34;&gt;&lt;a href=&#34;#896-单调数列&#34; class=&#34;headerlink&#34; title=&#34;896.单调数列&#34;&gt;&lt;/a&gt;896.单调数列&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果数组是单调递增或单调递减的，那么它是&lt;strong&gt;单调&lt;/strong&gt;的。&lt;br&gt;如果对于所有 i &amp;lt;&amp;#x3D; j，nums[i] &amp;lt;&amp;#x3D; nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &amp;lt;&amp;#x3D; j，nums[i] &amp;gt;&amp;#x3D; nums[j]，那么数组 nums 是单调递减的。&lt;br&gt;当给定的数组 nums 是单调数组时返回 true，否则返回 false。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;bool 递增变量=真，递减变量=真；
遍历数组：
    如果该元素+1 大于 该元素：
        标记递减变量=假；
    如果该元素+1 小于 该元素：
        标记递增变量=假；
如果递增or递减=真，返回真；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-2&#34;&gt;&lt;a href=&#34;#AC代码-2&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    bool isMonotonic(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        bool increase=true,decrease=true;
        for(int i=0;i&amp;lt;nums.size()-1;i++)&amp;#123;
            if(nums[i+1] &amp;gt; nums[i])&amp;#123;
                decrease=false;
            &amp;#125;
            if(nums[i+1] &amp;lt; nums[i])&amp;#123;
                increase=false;
            &amp;#125;
        &amp;#125;
        return decrease || increase;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;896-罗马数字转整数&#34;&gt;&lt;a href=&#34;#896-罗马数字转整数&#34; class=&#34;headerlink&#34; title=&#34;896.罗马数字转整数&#34;&gt;&lt;/a&gt;896.罗马数字转整数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/strong&gt;&lt;br&gt;字符          数值&lt;br&gt;I             1&lt;br&gt;V             5&lt;br&gt;X             10&lt;br&gt;L             50&lt;br&gt;C             100&lt;br&gt;D             500&lt;br&gt;M             1000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/li&gt;
&lt;li&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;br&gt;①I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;br&gt;②X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。&lt;br&gt;③C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;给定一个罗马数字，将其转换成整数。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-3&#34;&gt;&lt;a href=&#34;#解题思路-3&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;这题一开始我无从下手，直接跑去翻题解了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ &lt;a href=&#34;https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html&#34;&gt;map&lt;/a&gt;用法&lt;/strong&gt;&lt;br&gt;想起来python的字典。同样cpp stl中的map提供的是一种键值对（key-value）容器，其中的数据成对出现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化：&lt;code&gt;map类型 &amp;lt;数据类型1，数据类型2&amp;gt; 容器名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于map类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;键值对容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;实现方式&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;键值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是否有序&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找键对应的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要有序键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找元素是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要排序的集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_multimap&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有重复键且不关心顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;对于本题&lt;/strong&gt;&lt;br&gt;引用评论区&lt;a href=&#34;https://leetcode.cn/u/hust_wei/&#34;&gt;大佬&lt;/a&gt;的解释：当前位置的元素比下个位置的元素小，就减去当前值，否则加上当前值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义键值对容器 &amp;lt;字符，整型&amp;gt; 
    分别对应罗马数字的字符和数值(注意字符变量加单引号);

int 结果变量；
int 罗马数字长度；
遍历罗马数字：
    如果元素 当前位置&amp;lt;下一个位置：（注意使用值时加方括号[]）
        结果变量-=值变量；
    否则：
        结果变量+=值变量；
返回结果；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-3&#34;&gt;&lt;a href=&#34;#AC代码-3&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    unordered_map&amp;lt;char,int&amp;gt;mymap=&amp;#123;
        &amp;#123;&amp;#39;I&amp;#39;,1&amp;#125;,
        &amp;#123;&amp;#39;V&amp;#39;,5&amp;#125;,
        &amp;#123;&amp;#39;X&amp;#39;,10&amp;#125;,
        &amp;#123;&amp;#39;L&amp;#39;,50&amp;#125;,
        &amp;#123;&amp;#39;C&amp;#39;,100&amp;#125;,
        &amp;#123;&amp;#39;D&amp;#39;,500&amp;#125;,
        &amp;#123;&amp;#39;M&amp;#39;,1000&amp;#125;,
    &amp;#125;;
    int romanToInt(string s) &amp;#123;
        int ans=0;
        int len=s.length();
        for(int i=0;i&amp;lt;len;i++)&amp;#123;
            if(mymap[s[i]]&amp;lt;mymap[s[i+1]])&amp;#123;
                ans-=mymap[s[i]];
            &amp;#125;
            else&amp;#123;
                ans+=mymap[s[i]];
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;58-最后一个单词的长度&#34;&gt;&lt;a href=&#34;#58-最后一个单词的长度&#34; class=&#34;headerlink&#34; title=&#34;58.最后一个单词的长度&#34;&gt;&lt;/a&gt;58.最后一个单词的长度&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。&lt;br&gt;&lt;strong&gt;单词&lt;/strong&gt;是指仅由字母组成、不包含任何空格字符的最大子字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-4&#34;&gt;&lt;a href=&#34;#解题思路-4&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;【方法一】&lt;/strong&gt;&lt;br&gt;我的思路是&lt;strong&gt;从后向前&lt;/strong&gt;遍历字符串时：如果它的后一个是空格或空，自己不是空格，意味着句尾有空格，该下标是倒着数第一个不为空格的字母；如果前一个是空格或空，自己不是空格，代表这是词的开头，记录下标直接退出循环。最后长度就是二者相减。&lt;br&gt;但是这样写大多数样例不通过（悲&lt;/p&gt;
&lt;p&gt;（二编）卧槽我改对了！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【方法二】&lt;/strong&gt;&lt;br&gt;不对那就改呗：直接从字符串的尾部开始遍历，&lt;strong&gt;跳过所有尾部空格&lt;/strong&gt;，直到遇到&lt;strong&gt;第一个非空格字符&lt;/strong&gt;，并计算其长度。能够更好的处理边界情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int 长度=字符串长度;
int i=长度-1;
int 结果长度=0
当i大于等于0并且s的第i个字符为空格时：
    i--；（倒着循环遍历）
*本题设定s不为空，若无此条件需在此判断：当i&amp;lt;0时直接返回（s为空）
当i大于等于0并且s的第i个字符不为空格时：
    结果长度++；
    i--；
返回结果长度;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-4&#34;&gt;&lt;a href=&#34;#AC代码-4&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;【方法一】&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    int lengthOfLastWord(string s) &amp;#123;
        int len=s.length();
        int m=0,n=0;
        for(int i=len-1;i&amp;gt;0;i--)&amp;#123;
            if(s[i]!=&amp;#39; &amp;#39; &amp;amp;&amp;amp; (s[i+1]==&amp;#39; &amp;#39; || s[i+1]==&amp;#39;\0&amp;#39;))&amp;#123;
                m=i;
            &amp;#125;
            if((s[i-1]==&amp;#39; &amp;#39; || s[i-1]==&amp;#39;\0&amp;#39;) &amp;amp;&amp;amp; s[i]!=&amp;#39; &amp;#39;)&amp;#123;
                n=i;
                break;
            &amp;#125;
        &amp;#125;
        return m-n+1;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;【方法二】&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int lengthOfLastWord(string s) &amp;#123;
        int len=s.length();
        int ans=0;
        int i=len-1;
        while(i&amp;gt;=0 &amp;amp;&amp;amp; s[i]==&amp;#39; &amp;#39;)&amp;#123;
            i--;
        &amp;#125;
        while(i&amp;gt;=0 &amp;amp;&amp;amp; s[i]!=&amp;#39; &amp;#39;)&amp;#123;
            ans++;
            i--;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-回文数&#34;&gt;&lt;a href=&#34;#9-回文数&#34; class=&#34;headerlink&#34; title=&#34;9.回文数&#34;&gt;&lt;/a&gt;9.回文数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;br&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;br&gt;例如，121 是回文，而 123 不是。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-5&#34;&gt;&lt;a href=&#34;#解题思路-5&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回文数是正整数&lt;/li&gt;
&lt;li&gt;负数不是回文数&lt;/li&gt;
&lt;li&gt;一个数的最后一位是0且这个数不为0，不是回文数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将数字的后半部分反转，用&lt;code&gt;反转数字&lt;/code&gt;存储。最后的反转数字包含原始x的后半部分，x包含原始x的前半部分。&lt;br&gt;最后返回时：若&lt;strong&gt;原始x是偶数&lt;/strong&gt;，那么对于回文数，&lt;strong&gt;x一定&amp;#x3D;反转数字&lt;/strong&gt;。若&lt;strong&gt;原始x是奇数&lt;/strong&gt;，那么反转数字会比x多一位，这一位是反转数字的个位并且是原始x的中位数，不影响回文数判断。所以&lt;strong&gt;先去掉个位&lt;/strong&gt;再与当前的x比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果（x小于0，或者x的个位不等于0且x不等于0）：
    不是回文数；
定义反转数字=0；
当（x &amp;gt; 反转数字）：
    反转数字=反转数字*10+x%10；
    x/=10；
x = 反转数字
返回x = 反转数字 或者 x = 去掉个位的反转数字；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-5&#34;&gt;&lt;a href=&#34;#AC代码-5&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    bool isPalindrome(int x) &amp;#123;
        if(x&amp;lt;0 || (x%10==0 &amp;amp;&amp;amp; x!=0))&amp;#123;
            return false;
        &amp;#125;
        int num=0;
        while(x&amp;gt;num)&amp;#123;
            num=num*10+x%10;
            x/=10;
        &amp;#125;
        return x==num || x==num/10;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-最长公共前缀&#34;&gt;&lt;a href=&#34;#14-最长公共前缀&#34; class=&#34;headerlink&#34; title=&#34;14.最长公共前缀&#34;&gt;&lt;/a&gt;14.最长公共前缀&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-6&#34;&gt;&lt;a href=&#34;#解题思路-6&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;区区小简单，真是难倒我了。&lt;br&gt;这里总结力扣官方题解的纵向扫描方法。我一开始想的也是类似思路，奈何憋不出来代码。&lt;br&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最长公共前缀的长度不可能超过任何一个字符串的长度&lt;/li&gt;
&lt;li&gt;数组strs的大小即为字符串的总个数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二维数组形式&lt;/strong&gt;可以直接表示第i个字符的第j位&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;&lt;code&gt;i&lt;/code&gt;超出某个字符串的长度&lt;/strong&gt;或**第&lt;code&gt;j&lt;/code&gt;个字符串的第&lt;code&gt;i&lt;/code&gt;个字符不等于&lt;code&gt;c&lt;/code&gt;**时，直接返回当前的公共前缀。&lt;/li&gt;
&lt;li&gt;循环结束说明所有字符串的所有字符都匹配，那么第一个字符串本身就是最长公共前缀，返回第一个字符串&lt;code&gt;strs[0]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;如果数组为空：
    返回&amp;quot;&amp;quot;；
int 长度变量=数组第一个字符串元素的长度；
int 计数变量=数组大小；
遍历i，从0到长度变量：
    char 字符变量=第一个字符串的第i个字符；
    遍历j，从1到计数变量：
        如果（i==第j个字符串的大小 || 第j个字符串的第i个字符 ！= 字符变量）：
            返回 第一个字符串的第一个字符~第i个字符；
返回 第一个字符；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-6&#34;&gt;&lt;a href=&#34;#AC代码-6&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) &amp;#123;
        if(!strs.size())&amp;#123;
            return &amp;quot;&amp;quot;;
        &amp;#125;
        int len=strs[0].size();
        int cnt=strs.size();
        for(int i=0;i&amp;lt;len;i++)&amp;#123;
            char c=strs[0][i];
            for(int j=1;j&amp;lt;cnt;j++)&amp;#123;
                if(i==strs[j].size() || strs[j][i]!=c)&amp;#123;
                    return strs[0].substr(0,i);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return strs[0];
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;20-有效的括号&#34;&gt;&lt;a href=&#34;#20-有效的括号&#34; class=&#34;headerlink&#34; title=&#34;20.有效的括号&#34;&gt;&lt;/a&gt;20.有效的括号&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;有效字符串需满足：&lt;br&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;左括号必须以正确的顺序闭合。&lt;br&gt;每个右括号都有一个对应的相同类型的左括号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-7&#34;&gt;&lt;a href=&#34;#解题思路-7&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;定义栈的括号匹配规则；() [] &amp;#123;&amp;#125;

初始化一个栈;
当遇到左括号时：
    左括号压栈；
当遇到右括号时:
    如果（栈空）:
        ×；
    否则：
        char 栈顶元素；
        弹出栈顶元素；
        如果栈顶元素与当前右括号不匹配：
            ×；
字符串遍历完后：
    如果（栈空）：
        √；
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这里的for循环可以直接用for(char ch:s)，表示&lt;strong&gt;对于字符串&lt;code&gt;s&lt;/code&gt;中的每一个字符&lt;code&gt;ch&lt;/code&gt;,执行循环内容&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;AC代码-7&#34;&gt;&lt;a href=&#34;#AC代码-7&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;682-棒球比赛&#34;&gt;&lt;a href=&#34;#682-棒球比赛&#34; class=&#34;headerlink&#34; title=&#34;682.棒球比赛&#34;&gt;&lt;/a&gt;682.棒球比赛&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;比赛开始时，记录是空白的。你会得到一个记录操作的&lt;strong&gt;字符串列表&lt;/strong&gt; ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数 x - 表示本回合新获得分数 x&lt;/li&gt;
&lt;li&gt;“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。&lt;/li&gt;
&lt;li&gt;“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。&lt;/li&gt;
&lt;li&gt;“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。&lt;br&gt;请你返回记录中所有得分的总和。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-8&#34;&gt;&lt;a href=&#34;#解题思路-8&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;用int动态数组ans记录得分，但是不用i做索引来查询，而是用begin、end、size、back等方法来防止发生越界访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意&lt;code&gt;string&lt;/code&gt;类型为字符串，用双引号””括起来，&lt;code&gt;char&lt;/code&gt;类型为字符，用单引号’’。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;前两次得分之和：size-1 +size-2
前一次得分：back
最近一次得分移除-&amp;gt;出栈-&amp;gt;pop_back
加入得分：压栈-&amp;gt;push_back
字符串转整型：stoi
计算动态数组的和：accumulate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，我一开始想用&lt;code&gt;unordered_map&lt;/code&gt;，做题做迷了。后来发现动态数组完全可以解决：C++ 标准库中的 vector 支持动态调整大小，可以方便地模拟栈的行为。而unordered_map 是用来存储键值对（key-value pairs）的哈希表。&lt;br&gt;本问题中不需要映射关系，所以并不需要用到 unordered_map。&lt;br&gt;还有，&lt;strong&gt;stack&lt;int&gt;&lt;strong&gt;的&lt;code&gt;.push()&lt;/code&gt;和&lt;code&gt;.pop()&lt;/code&gt;也可，但是&lt;/strong&gt;vector&lt;/strong&gt;的&lt;code&gt;.push_back()&lt;/code&gt;和&lt;code&gt;.pop_back()&lt;/code&gt;也同样可以。那就选更常用的vector，何乐而不为呢？&lt;/p&gt;
&lt;h3 id=&#34;AC代码-8&#34;&gt;&lt;a href=&#34;#AC代码-8&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;用时击败7%，悲。之后滚回来优化算法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    int calPoints(vector&amp;lt;string&amp;gt;&amp;amp; operations) &amp;#123;
        vector&amp;lt;int&amp;gt;ans;
        for(string ch:operations)&amp;#123;
            if(ch==&amp;quot;+&amp;quot;)&amp;#123;
                ans.push_back(ans[ans.size()-1]+ans[ans.size()-2]);
            &amp;#125;
            else if(ch==&amp;quot;D&amp;quot;)&amp;#123;
                ans.push_back(ans.back()*2);
            &amp;#125;
            else if(ch==&amp;quot;C&amp;quot;)&amp;#123;
                ans.pop_back();
            &amp;#125;
            else&amp;#123;
                ans.push_back(stoi(ch));
            &amp;#125;
        &amp;#125;
        return accumulate(ans.begin(),ans.end(),0);
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;26-删除有序数组中的重复项&#34;&gt;&lt;a href=&#34;#26-删除有序数组中的重复项&#34; class=&#34;headerlink&#34; title=&#34;26.删除有序数组中的重复项&#34;&gt;&lt;/a&gt;26.删除有序数组中的重复项&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个非严格递增排列的数组nums,请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回nums中唯一元素的个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑nums的唯一元素的数量为k，你需要做以下事情确保你的题解可以被通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改数组nums，使nums的前k个元素包含唯一元素，并按照它们最初在nums中出现的顺序排列。nums的其余元素与nums的大小不重要。&lt;/li&gt;
&lt;li&gt;返回 k 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-9&#34;&gt;&lt;a href=&#34;#解题思路-9&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int 最终数组长度=1;
遍历nums：
    如果第i个元素不等于第i-1个元素：
        nums[最终数组长度]=nums[i]；
        最终数组长度++；
返回最终数组长度；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-9&#34;&gt;&lt;a href=&#34;#AC代码-9&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;妈呀这题一提交发现每ms都有解法…密密麻麻(ΩДΩ)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int ans=1;
        for(int i=1;i&amp;lt;nums.size();i++)&amp;#123;
            if(nums[i]!=nums[i-1])&amp;#123;
                nums[ans]=nums[i];
                ans++;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;35-搜索插入位置&#34;&gt;&lt;a href=&#34;#35-搜索插入位置&#34; class=&#34;headerlink&#34; title=&#34;35.搜索插入位置&#34;&gt;&lt;/a&gt;35.搜索插入位置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;br&gt;&lt;strong&gt;请必须使用时间复杂度为&lt;code&gt;O(logn)&lt;/code&gt;的算法。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-10&#34;&gt;&lt;a href=&#34;#解题思路-10&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;我一开始用的暴力穷举，如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) &amp;#123;
        while(nums.size()!=1)&amp;#123;
            if(target&amp;lt;nums[0])&amp;#123;
                return 0;
            &amp;#125;
            for(int i=0;i&amp;lt;nums.size()-1;i++)&amp;#123;
                if(nums[i]==target)&amp;#123;
                    return i;
                &amp;#125;
                else if(nums[i]&amp;lt;target &amp;amp;&amp;amp; nums[i+1]&amp;gt;=target)&amp;#123;
                    return i+1;
                &amp;#125;
            &amp;#125;
            return nums.size();
        &amp;#125;
        return (target&amp;lt;=nums[0])? 0:1;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后提交之后意识到不符合题意，于是再来换个思路：&lt;strong&gt;二分查找&lt;/strong&gt;&lt;br&gt;我前几天刚记的二分查找笔记 今天竟然没意识到这道题有多直白地明示我要用!!!∑(ﾟДﾟノ)ノ&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;二分查找&lt;/strong&gt;：在有序集合中搜索特定值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用术语&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标 &lt;code&gt;target&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;索引 &lt;code&gt;index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左、右指示符 &lt;code&gt;left&lt;/code&gt;、&lt;code&gt;right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中间指示符 &lt;code&gt;mid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;计算 &lt;code&gt;mid&lt;/code&gt; 位置&lt;/strong&gt;：&lt;br&gt;如果 &lt;code&gt;nums[mid] == target&lt;/code&gt;，直接返回索引。&lt;br&gt;如果 &lt;code&gt;nums[mid] &amp;lt; target&lt;/code&gt;，说明 target 应该在右半部分，所以left向右移动（left &amp;#x3D; mid + 1）。&lt;br&gt;如果 &lt;code&gt;nums[mid] &amp;gt; target&lt;/code&gt;，说明 target 应该在左半部分，所以right向左移动（ right &amp;#x3D; mid - 1）。&lt;/p&gt;
&lt;p&gt;循环结束后，left 就是 target 应该插入的位置。&lt;/p&gt;
&lt;h3 id=&#34;AC代码-10&#34;&gt;&lt;a href=&#34;#AC代码-10&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;二分查找最基础的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution &amp;#123;
public:
    int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) &amp;#123;
        int left,right;
        left=0;
        right=nums.size()-1;
        while(left&amp;lt;=right)&amp;#123;
            int mid=left+(right-left)/2;
            if(nums[mid]==target)&amp;#123;
                return mid;
            &amp;#125;
            else if(nums[mid]&amp;lt;target)&amp;#123;
                left=mid+1;
            &amp;#125;
            else&amp;#123;
                right=mid-1;
            &amp;#125;
        &amp;#125;
        return left;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;35-搜索插入位置-1&#34;&gt;&lt;a href=&#34;#35-搜索插入位置-1&#34; class=&#34;headerlink&#34; title=&#34;35.搜索插入位置&#34;&gt;&lt;/a&gt;35.搜索插入位置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;br&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-11&#34;&gt;&lt;a href=&#34;#解题思路-11&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;试图暴力然后失败。然后查看题解：竟然是&lt;strong&gt;动态规划&lt;/strong&gt;~&lt;/p&gt;
&lt;p&gt;重点理解部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逆向思维&lt;/strong&gt;：如果要到第&lt;code&gt;n&lt;/code&gt;个台阶，就必须从第&lt;code&gt;n-1&lt;/code&gt;阶走1步，或者从第&lt;code&gt;n-2&lt;/code&gt;阶走2步。&lt;/li&gt;
&lt;li&gt;dp[n]&amp;#x3D;dp[n-1]+dp[n-2]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;为什么这样递推？&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;动态规划的核心是&lt;strong&gt;拆分子问题,然后找到递推关系&lt;/strong&gt;。本质根据题目限制条件，建立递推关系，然后用代码实现。&lt;br&gt;👉 因为你每次只能走 1 级或 2 级，所以你到 n 级的方式只能来自 n-1 和 n-2，而不能来自 n-3、n-4 等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//先处理边界情况
如果n&amp;lt;=2：返回n；
//动规
定义a=1,b=2；（对应能上的楼梯阶数）和当前阶梯的方案数量temp;
遍历n（从3开始）：
    temp=a+b； //dp[i]=dp[i-2]+dp[i-1]
    a=b;      //a=dp[i-1]
    b=temp;   //b=dp[i];
返回 b;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/</guid>
            <title>博客搭建小半年的痛</title>
            <link>https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/</link>
            <category>记录</category>
            <pubDate>Thu, 20 Feb 2025 10:26:39 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;strong&gt;主打一个备忘&lt;/strong&gt;&lt;br&gt;断断续续从24年中搞到现在25年初，最磨蹭的一集。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最新问题&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提交评论 ×&lt;br&gt;替换部分主题图片 ×&lt;br&gt;文章总访问量显示 ×&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;首先是参考链接&#34;&gt;&lt;a href=&#34;#首先是参考链接&#34; class=&#34;headerlink&#34; title=&#34;首先是参考链接&#34;&gt;&lt;/a&gt;首先是参考链接&lt;/h2&gt;&lt;p&gt;非常感谢！&lt;/p&gt;
&lt;h3 id=&#34;ShokaX&#34;&gt;&lt;a href=&#34;#ShokaX&#34; class=&#34;headerlink&#34; title=&#34;ShokaX&#34;&gt;&lt;/a&gt;ShokaX&lt;/h3&gt;&lt;p&gt;github：&lt;a href=&#34;https://github.com/theme-shoka-x/hexo-theme-shokaX&#34;&gt;https://github.com/theme-shoka-x/hexo-theme-shokaX&lt;/a&gt;&lt;br&gt;官方文档：&lt;a href=&#34;https://hexo.docs.shokax.top/&#34;&gt;https://hexo.docs.shokax.top/&lt;/a&gt;&lt;br&gt;主题指南：&lt;a href=&#34;https://docs.kaitaku.xyz/&#34;&gt;https://docs.kaitaku.xyz/&lt;/a&gt;&lt;br&gt;社区资源：&lt;a href=&#34;https://github.com/theme-shoka-x/awesome-shokaX&#34;&gt;https://github.com/theme-shoka-x/awesome-shokaX&lt;/a&gt;&lt;br&gt;shoka：&lt;a href=&#34;https://github.com/amehime/hexo-theme-shoka&#34;&gt;https://github.com/amehime/hexo-theme-shoka&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他相关网站-教程&#34;&gt;&lt;a href=&#34;#其他相关网站-教程&#34; class=&#34;headerlink&#34; title=&#34;其他相关网站&amp;amp;教程&#34;&gt;&lt;/a&gt;其他相关网站&amp;amp;教程&lt;/h3&gt;&lt;p&gt;Linn’s Shoka：&lt;a href=&#34;https://linn-ylz.com/Hexo/blog-content-test/&#34;&gt;https://linn-ylz.com/Hexo/blog-content-test/&lt;/a&gt;&lt;br&gt;waline快速上手：&lt;a href=&#34;https://waline.js.org/guide/get-started/&#34;&gt;https://waline.js.org/guide/get-started/&lt;/a&gt;&lt;br&gt;Vercel服务端部署：&lt;a href=&#34;https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example&amp;teamSlug=232akiras-projects&#34;&gt;https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&amp;amp;teamSlug=232akiras-projects&lt;/a&gt;&lt;br&gt;leancloud：&lt;a href=&#34;https://console.leancloud.app/apps&#34;&gt;https://console.leancloud.app/apps&lt;/a&gt;&lt;br&gt;Gimhoy图床：&lt;a href=&#34;https://pic.gimhoy.com/&#34;&gt;https://pic.gimhoy.com/&lt;/a&gt;&lt;br&gt;Google字体：&lt;a href=&#34;https://fonts.google.com/&#34;&gt;https://fonts.google.com/&lt;/a&gt;&lt;br&gt;百度统计：&lt;a href=&#34;https://tongji.baidu.com/main/setting/10000672027/home/site/index&#34;&gt;https://tongji.baidu.com/main/setting/10000672027/home/site/index&lt;/a&gt;&lt;br&gt;markdown排版：&lt;a href=&#34;https://markdown.com.cn/editor/&#34;&gt;https://markdown.com.cn/editor/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;搭建思路&#34;&gt;&lt;a href=&#34;#搭建思路&#34; class=&#34;headerlink&#34; title=&#34;搭建思路&#34;&gt;&lt;/a&gt;搭建思路&lt;/h2&gt;&lt;p&gt;这方面毫无实战知识，不停地踩坑踩坑…&lt;/p&gt;
&lt;h3 id=&#34;Hexo初始化博客&#34;&gt;&lt;a href=&#34;#Hexo初始化博客&#34; class=&#34;headerlink&#34; title=&#34;Hexo初始化博客&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://hexo.io/zh-cn/&#34; title=&#34;点此跳转Hexo官网&#34;&gt;Hexo&lt;/a&gt;初始化博客&lt;/h3&gt;&lt;p&gt;基于Node.js的博客框架。本博客采用Hexo+Github搭建。&lt;br&gt;&lt;strong&gt;常用命令&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;功能&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;命令&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;简写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;清理缓存&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;hexo clean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;hexo cl&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;部署站点&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;hexo deploy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;hexo d&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;生成博客&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;hexo generate&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;hexo g&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;启动本地服务&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;hexo server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;hexo s&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;Shoka主题配置&#34;&gt;&lt;a href=&#34;#Shoka主题配置&#34; class=&#34;headerlink&#34; title=&#34;Shoka主题配置&#34;&gt;&lt;/a&gt;Shoka主题配置&lt;/h3&gt;&lt;p&gt;一开始胡乱配置，后来更新的时候爆出来好多问题。于是这两天从头重做&lt;/p&gt;
&lt;h4 id=&#34;步骤如下：&#34;&gt;&lt;a href=&#34;#步骤如下：&#34; class=&#34;headerlink&#34; title=&#34;步骤如下：&#34;&gt;&lt;/a&gt;步骤如下：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;前置hexo init、Node.js等
pnpm安装shokax
/_config.landscape.yml重命名为_config.shokax.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;config-yml中的配置项：&#34;&gt;&lt;a href=&#34;#config-yml中的配置项：&#34; class=&#34;headerlink&#34; title=&#34;&amp;#x2F;_config.yml中的配置项：&#34;&gt;&lt;/a&gt;&amp;#x2F;_config.yml中的配置项：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;markdown配置
停用默认代码高亮
文件压缩
feed生成
站内搜索
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;config-shokax-yml中的配置项：&#34;&gt;&lt;a href=&#34;#config-shokax-yml中的配置项：&#34; class=&#34;headerlink&#34; title=&#34;&amp;#x2F;_config.shokax.yml中的配置项：&#34;&gt;&lt;/a&gt;&amp;#x2F;_config.shokax.yml中的配置项：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;静态资源存放目录
ShokaX功能模块
主页头图
Iconfont图标
导航栏
侧边栏
大标题
社交链接
字数和阅读时间统计
预加载和预解析地址
SEO优化和访客优化
夜间模式
自动定位
标题自定义
图片自定义
首页精选
分类翻转块
实验性特性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回到我的主页😼👇️&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;site: K’s BLOG&lt;br&gt;url: &lt;a href=&#34;https://232akira.github.io/&#34;&gt;https://232akira.github.io/&lt;/a&gt;&lt;br&gt;color: “#adff2f”&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2024/11/23/%E5%AD%98%E5%AD%98markdown%E7%9B%B8%E5%85%B3/</guid>
            <title>存存markdown相关</title>
            <link>https://232akira.github.io/2024/11/23/%E5%AD%98%E5%AD%98markdown%E7%9B%B8%E5%85%B3/</link>
            <category>记录</category>
            <category>Markdown</category>
            <pubDate>Sat, 23 Nov 2024 18:40:43 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;这是232akira的第一篇博客的二级标题两个井号加空格&#34;&gt;&lt;a href=&#34;#这是232akira的第一篇博客的二级标题两个井号加空格&#34; class=&#34;headerlink&#34; title=&#34;这是232akira的第一篇博客的二级标题两个井号加空格&#34;&gt;&lt;/a&gt;这是232akira的第一篇博客的二级标题两个井号加空格&lt;/h2&gt;&lt;h3 id=&#34;这是232akira的第一篇博客的三级标题三个井号加空格&#34;&gt;&lt;a href=&#34;#这是232akira的第一篇博客的三级标题三个井号加空格&#34; class=&#34;headerlink&#34; title=&#34;这是232akira的第一篇博客的三级标题三个井号加空格&#34;&gt;&lt;/a&gt;这是232akira的第一篇博客的三级标题三个井号加空格&lt;/h3&gt;&lt;p&gt;这是232akira的第一篇博客的第一段直接回车&lt;/p&gt;
&lt;p&gt;这是232akira的第一篇博客的第二段&lt;/p&gt;
&lt;p&gt;这是换行尝试两个空格+回车&lt;br&gt;&lt;br&gt;&lt;br&gt;换行！&lt;/p&gt;
&lt;p&gt;这是字体加粗尝试加粗 &lt;strong&gt;前后各加2个星星号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是字体斜体尝试斜体 &lt;em&gt;前后各加1个星星号&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是字体同时加粗斜体尝试 &lt;em&gt;&lt;strong&gt;前后各加3个星星号&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是创建块引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;kuaiyinyongkuaiyinyongkkk&lt;br&gt;这是多个段落的块引用&lt;br&gt;kuaiyinyongkkk&lt;/p&gt;
&lt;p&gt;kkk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是嵌套块引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;kuaiyinyongkkk&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;qiantaoaaa&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用短横杠（注意两边空格）出来是圆点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是有序列表&lt;br&gt;1.我是1第一项必须数字一加英文句号后面数字无所谓&lt;br&gt;2.我是2&lt;br&gt;    1.我是1&lt;br&gt;    2.我是2&lt;br&gt;3.我是3&lt;/p&gt;
&lt;p&gt;这是无序列表点乘加短横杠都可以变成圆点&lt;br&gt;-111&lt;br&gt;-222&lt;br&gt;    -1111嵌套前面四个空格&lt;br&gt;    -代码在列表里缩进8个空格或者2个tab&lt;br&gt;            print(“hello world~”)&lt;br&gt;-333&lt;/p&gt;
&lt;p&gt;这是代码语法&lt;br&gt;把代码包裹在反引号&lt;code&gt;中 比如我这里是 &lt;/code&gt;代码代码代码&lt;code&gt;创建代码块就还是缩进4个空格or1个tab&lt;/code&gt;        我是代码块啊啊啊&amp;#96;&lt;/p&gt;
&lt;h2 id=&#34;这是分隔线单独一行三星或多星-破折号-下划线&#34;&gt;&lt;a href=&#34;#这是分隔线单独一行三星或多星-破折号-下划线&#34; class=&#34;headerlink&#34; title=&#34;这是分隔线单独一行三星或多星&amp;#x2F;破折号&amp;#x2F;下划线***&#34;&gt;&lt;/a&gt;这是分隔线单独一行三星或多星&amp;#x2F;破折号&amp;#x2F;下划线&lt;br&gt;***&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;出来的效果一样的&lt;/p&gt;
&lt;p&gt;这是链接链接的文本放中括号地址放后面圆括号&lt;a href=&#34;https://www.xuexi.cn/&#34; title=&#34;我是title&#34;&gt;快来学习&lt;/a&gt;&lt;br&gt;或者直接尖括号链接跳转&lt;a href=&#34;https://www.xuexi.cn/&#34;&gt;https://www.xuexi.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;强调链接就在尖括号前后增加星号，表示为代码就加反引号&lt;br&gt;I love &lt;strong&gt;&lt;a href=&#34;https://www.xuexi.cn/&#34; title=&#34;我是title&#34;&gt;学习&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是引用型链接，两个方括号前一个写文本后一个指向其他位置的链接&lt;br&gt;[跳转跳转啊啊啊] &lt;a href=&#34;https://www.xuexi.cn/&#34;&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是添加图像使用感叹号+方括号+圆括号。方括号里写替代文本，圆括号里写图片链接，也可以后接图片标题文本。跳转链接写在最外面并再套一层方括号。&lt;br&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;/images/kabi.jpg&#34; alt=&#34;这是图片&#34; title=&#34;我是title&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>

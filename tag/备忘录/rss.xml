<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Per aspera ad astra • Posts by &#34;备忘录&#34; tag</title>
        <link>https://232akira.github.io</link>
        <description>欢迎交流学习!</description>
        <language>zh-CN</language>
        <pubDate>Mon, 16 Jun 2025 10:10:30 +0800</pubDate>
        <lastBuildDate>Mon, 16 Jun 2025 10:10:30 +0800</lastBuildDate>
        <category>TIPS</category>
        <category>记录</category>
        <category>专题</category>
        <category>力扣</category>
        <category>算法</category>
        <category>备忘录</category>
        <category>AI</category>
        <category>指南</category>
        <category>案例</category>
        <category>笔记</category>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/06/16/%E5%A4%87%E5%BF%98/%E5%A4%87%E5%BF%98%E5%BD%95-%E6%A1%88%E4%BE%8B/</guid>
            <title>备忘录 ⋮ 案例</title>
            <link>https://232akira.github.io/2025/06/16/%E5%A4%87%E5%BF%98/%E5%A4%87%E5%BF%98%E5%BD%95-%E6%A1%88%E4%BE%8B/</link>
            <category>备忘录</category>
            <category>AI</category>
            <pubDate>Mon, 16 Jun 2025 10:10:30 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;工作以来接触到了很多新知识，博客也拖了俩月没更了…😂今天开始慢慢补充案例！&lt;/p&gt;
&lt;h2 id=&#34;工作案例备忘&#34;&gt;&lt;a href=&#34;#工作案例备忘&#34; class=&#34;headerlink&#34; title=&#34;工作案例备忘&#34;&gt;&lt;/a&gt;工作案例备忘&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;记录的文章会以&lt;code&gt;【实战x-x】&lt;/code&gt;的方式作为开头。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1️⃣AIGC开发案例&#34;&gt;&lt;a href=&#34;#1️⃣AIGC开发案例&#34; class=&#34;headerlink&#34; title=&#34;1️⃣AIGC开发案例&#34;&gt;&lt;/a&gt;1️⃣AIGC开发案例&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;直接应用 + API编排&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;文生文&lt;/li&gt;
&lt;li&gt;文生图&lt;/li&gt;
&lt;li&gt;文生视频&lt;/li&gt;
&lt;li&gt;图生图&lt;/li&gt;
&lt;li&gt;图生3D&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2️⃣AI辅助编程&#34;&gt;&lt;a href=&#34;#2️⃣AI辅助编程&#34; class=&#34;headerlink&#34; title=&#34;2️⃣AI辅助编程&#34;&gt;&lt;/a&gt;2️⃣AI辅助编程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;VSCode + 插件为主，编译器用的少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Cursor&lt;/li&gt;
&lt;li&gt;Trae&lt;/li&gt;
&lt;li&gt;Copilot&lt;/li&gt;
&lt;li&gt;Cline&lt;/li&gt;
&lt;li&gt;Lingma&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3️⃣AI客户端&#34;&gt;&lt;a href=&#34;#3️⃣AI客户端&#34; class=&#34;headerlink&#34; title=&#34;3️⃣AI客户端&#34;&gt;&lt;/a&gt;3️⃣AI客户端&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;LLM服务商配置、MCP服务部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Chatbox&lt;/li&gt;
&lt;li&gt;Cherry Studio&lt;/li&gt;
&lt;li&gt;DeepChat&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;个人案例备忘&#34;&gt;&lt;a href=&#34;#个人案例备忘&#34; class=&#34;headerlink&#34; title=&#34;个人案例备忘&#34;&gt;&lt;/a&gt;个人案例备忘&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;记录的文章会以&lt;code&gt;【笔记x-x】&lt;/code&gt;的方式作为开头。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;待整理~😴&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/02/%E5%A4%87%E5%BF%98/%E5%A4%87%E5%BF%98%E5%BD%95-%E5%8A%9B%E6%89%A3/</guid>
            <title>备忘录 ⋮ 力扣</title>
            <link>https://232akira.github.io/2025/03/02/%E5%A4%87%E5%BF%98/%E5%A4%87%E5%BF%98%E5%BD%95-%E5%8A%9B%E6%89%A3/</link>
            <category>力扣</category>
            <category>备忘录</category>
            <pubDate>Sun, 02 Mar 2025 19:55:55 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;一些问题总结和标签比较杂、没有分类的题目会放到这篇。&lt;/p&gt;
&lt;h1 id=&#34;基础算法问题&#34;&gt;&lt;a href=&#34;#基础算法问题&#34; class=&#34;headerlink&#34; title=&#34;基础算法问题&#34;&gt;&lt;/a&gt;基础算法问题&lt;/h1&gt;&lt;p&gt;这些题听着老熟了，一到写起来就主打一个略有耳闻🫠&lt;/p&gt;
&lt;h2 id=&#34;题目一览&#34;&gt;&lt;a href=&#34;#题目一览&#34; class=&#34;headerlink&#34; title=&#34;题目一览&#34;&gt;&lt;/a&gt;题目一览&lt;/h2&gt;&lt;p&gt;省流表👇️&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目并非只有表中那几个，可在&lt;a href=&#34;https://leetcode.cn/problemset/&#34;&gt;此页&lt;/a&gt;自行筛选。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1️⃣数组与数学类&#34;&gt;&lt;a href=&#34;#1️⃣数组与数学类&#34; class=&#34;headerlink&#34; title=&#34;1️⃣数组与数学类&#34;&gt;&lt;/a&gt;&lt;strong&gt;1️⃣数组与数学类&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体 &amp;#x2F; 要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;杨辉三角&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[118/119]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一维数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;斐波那契数列&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[509]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;爬楼梯问题&lt;code&gt;[70]&lt;/code&gt;&amp;#x2F;递归&amp;#x2F;迭代&amp;#x2F;动态规划&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;两数之和&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[1]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表优化时间复杂度到O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;合并两个有序数组&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[88]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;原地合并（从后向前填充）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;最大子数组和&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[53]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;动态规划&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;2️⃣字符串操作类&#34;&gt;&lt;a href=&#34;#2️⃣字符串操作类&#34; class=&#34;headerlink&#34; title=&#34;2️⃣字符串操作类&#34;&gt;&lt;/a&gt;&lt;strong&gt;2️⃣字符串操作类&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体&amp;#x2F;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;反转字符串&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[344]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;原地修改（双指针）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;有效的括号&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[20]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用栈实现括号匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;最长公共前缀&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[14]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;纵向扫描&amp;#x2F;分治&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字符串转整数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[8]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;处理边界（溢出&amp;#x2F;符号&amp;#x2F;空格）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;3️⃣链表类&#34;&gt;&lt;a href=&#34;#3️⃣链表类&#34; class=&#34;headerlink&#34; title=&#34;3️⃣链表类&#34;&gt;&lt;/a&gt;&lt;strong&gt;3️⃣链表类&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体&amp;#x2F;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;反转链表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[206]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;迭代&amp;#x2F;递归&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;环形链表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[141]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快慢指针判环&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;合并两个有序链表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[21]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;迭代&amp;#x2F;递归&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;删除链表倒数第N个节点&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[19]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一趟扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;4️⃣树与递归&#34;&gt;&lt;a href=&#34;#4️⃣树与递归&#34; class=&#34;headerlink&#34; title=&#34;4️⃣树与递归&#34;&gt;&lt;/a&gt;&lt;strong&gt;4️⃣树与递归&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体&amp;#x2F;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;二叉树的最大深度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[104]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;迭代&amp;#x2F;递归&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;对称二叉树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[101]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;迭代（队列&amp;#x2F;栈）&amp;#x2F;递归&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;路径总和&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[112]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;动回溯法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;5️⃣动态规划&#34;&gt;&lt;a href=&#34;#5️⃣动态规划&#34; class=&#34;headerlink&#34; title=&#34;5️⃣动态规划&#34;&gt;&lt;/a&gt;&lt;strong&gt;5️⃣动态规划&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体&amp;#x2F;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;打家劫舍&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[198]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;状态转移方程推导&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;零钱兑换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[322]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;完全背包问题解法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;最长递增子序列&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[300]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)优化解法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;6️⃣排序与查找&#34;&gt;&lt;a href=&#34;#6️⃣排序与查找&#34; class=&#34;headerlink&#34; title=&#34;6️⃣排序与查找&#34;&gt;&lt;/a&gt;&lt;strong&gt;6️⃣排序与查找&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体&amp;#x2F;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;快速排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;力扣排序题均可&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;手写递归和非递归版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;二分查找&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[53]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;处理边界条件（左闭右闭&amp;#x2F;左闭右开）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;寻找峰值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[53]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;二分法的特殊应用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;7️⃣其他高频&#34;&gt;&lt;a href=&#34;#7️⃣其他高频&#34; class=&#34;headerlink&#34; title=&#34;7️⃣其他高频&#34;&gt;&lt;/a&gt;&lt;strong&gt;7️⃣其他高频&lt;/strong&gt;&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;题目&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;力扣题号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;变体&amp;#x2F;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;LRU缓存&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[146]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;手写递归和非递归版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;实现队列&amp;#x2F;栈&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[232/225]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;处理边界条件（左闭右闭&amp;#x2F;左闭右开）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;汉明距离&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[461]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;二分法的特殊应用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;具体题目思路&amp;amp;代码记录见各个专题🤗&lt;/p&gt;
&lt;h1 id=&#34;简单题&#34;&gt;&lt;a href=&#34;#简单题&#34; class=&#34;headerlink&#34; title=&#34;简单题&#34;&gt;&lt;/a&gt;简单题&lt;/h1&gt;&lt;h2 id=&#34;66-加一&#34;&gt;&lt;a href=&#34;#66-加一&#34; class=&#34;headerlink&#34; title=&#34;66.加一&#34;&gt;&lt;/a&gt;66.加一&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。&lt;br&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。&lt;br&gt;你可以假设除了整数 0 之外，这个整数不会以零开头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;判断数组末尾是否有9：
    无9：末尾数字+1;
    有9：
        是否全为9：
            是全9：
                构造长度=size+1的数组，首位=1，其余全置0;
            非全9：
                找到倒着数第一个不是9的元素,
                该元素加1,
                末尾所有的9置0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码&#34;&gt;&lt;a href=&#34;#AC代码&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) &amp;#123;
        int len=digits.size();
        if(digits[len-1]!=9)&amp;#123;
            digits[len-1]+=1;
        &amp;#125;
        else&amp;#123;
            int cnt=0;//记录9出现的次数，第一个非9元素的下标即为len-cnt-1
            for(int i=len-1;i&amp;gt;=0;i--)&amp;#123;
                if(digits[i]==9)&amp;#123;
                    cnt++;
                &amp;#125;
                else&amp;#123;
                    break;
                &amp;#125;
            &amp;#125;
            if(cnt==len)&amp;#123;
                digits.insert(digits.begin(),1);
                for(int i=1;i&amp;lt;len+1;i++)&amp;#123;
                    digits[i]=0;
                &amp;#125;
            &amp;#125;
            else&amp;#123;
                int index=len-cnt-1;
                digits[index]+=1;
                for(int i=index+1;i&amp;lt;len;i++)&amp;#123;
                    digits[i]=0;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return digits;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;896-单调数列&#34;&gt;&lt;a href=&#34;#896-单调数列&#34; class=&#34;headerlink&#34; title=&#34;896.单调数列&#34;&gt;&lt;/a&gt;896.单调数列&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果数组是单调递增或单调递减的，那么它是&lt;strong&gt;单调&lt;/strong&gt;的。&lt;br&gt;如果对于所有 i &amp;lt;&amp;#x3D; j，nums[i] &amp;lt;&amp;#x3D; nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &amp;lt;&amp;#x3D; j，nums[i] &amp;gt;&amp;#x3D; nums[j]，那么数组 nums 是单调递减的。&lt;br&gt;当给定的数组 nums 是单调数组时返回 true，否则返回 false。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;bool 递增变量=真，递减变量=真；
遍历数组：
    如果该元素+1 大于 该元素：
        标记递减变量=假；
    如果该元素+1 小于 该元素：
        标记递增变量=假；
如果递增or递减=真，返回真；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-1&#34;&gt;&lt;a href=&#34;#AC代码-1&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    bool isMonotonic(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        bool increase=true,decrease=true;
        for(int i=0;i&amp;lt;nums.size()-1;i++)&amp;#123;
            if(nums[i+1] &amp;gt; nums[i])&amp;#123;
                decrease=false;
            &amp;#125;
            if(nums[i+1] &amp;lt; nums[i])&amp;#123;
                increase=false;
            &amp;#125;
        &amp;#125;
        return decrease || increase;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;896-罗马数字转整数&#34;&gt;&lt;a href=&#34;#896-罗马数字转整数&#34; class=&#34;headerlink&#34; title=&#34;896.罗马数字转整数&#34;&gt;&lt;/a&gt;896.罗马数字转整数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/strong&gt;&lt;br&gt;字符          数值&lt;br&gt;I             1&lt;br&gt;V             5&lt;br&gt;X             10&lt;br&gt;L             50&lt;br&gt;C             100&lt;br&gt;D             500&lt;br&gt;M             1000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。&lt;/li&gt;
&lt;li&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;br&gt;①I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;br&gt;②X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。&lt;br&gt;③C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;给定一个罗马数字，将其转换成整数。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;这题一开始我无从下手，直接跑去翻题解了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ &lt;a href=&#34;https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html&#34;&gt;map&lt;/a&gt;用法&lt;/strong&gt;&lt;br&gt;想起来python的字典。同样cpp stl中的map提供的是一种键值对（key-value）容器，其中的数据成对出现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化：&lt;code&gt;map类型 &amp;lt;数据类型1，数据类型2&amp;gt; 容器名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于map类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;键值对容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;实现方式&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;键值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是否有序&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找键对应的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要有序键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找元素是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要排序的集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_multimap&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有重复键且不关心顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;对于本题&lt;/strong&gt;&lt;br&gt;引用评论区&lt;a href=&#34;https://leetcode.cn/u/hust_wei/&#34;&gt;大佬&lt;/a&gt;的解释：当前位置的元素比下个位置的元素小，就减去当前值，否则加上当前值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义键值对容器 &amp;lt;字符，整型&amp;gt; 
    分别对应罗马数字的字符和数值(注意字符变量加单引号);

int 结果变量；
int 罗马数字长度；
遍历罗马数字：
    如果元素 当前位置&amp;lt;下一个位置：（注意使用值时加方括号[]）
        结果变量-=值变量；
    否则：
        结果变量+=值变量；
返回结果；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-2&#34;&gt;&lt;a href=&#34;#AC代码-2&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    unordered_map&amp;lt;char,int&amp;gt;mymap=&amp;#123;
        &amp;#123;&amp;#39;I&amp;#39;,1&amp;#125;,
        &amp;#123;&amp;#39;V&amp;#39;,5&amp;#125;,
        &amp;#123;&amp;#39;X&amp;#39;,10&amp;#125;,
        &amp;#123;&amp;#39;L&amp;#39;,50&amp;#125;,
        &amp;#123;&amp;#39;C&amp;#39;,100&amp;#125;,
        &amp;#123;&amp;#39;D&amp;#39;,500&amp;#125;,
        &amp;#123;&amp;#39;M&amp;#39;,1000&amp;#125;,
    &amp;#125;;
    int romanToInt(string s) &amp;#123;
        int ans=0;
        int len=s.length();
        for(int i=0;i&amp;lt;len;i++)&amp;#123;
            if(mymap[s[i]]&amp;lt;mymap[s[i+1]])&amp;#123;
                ans-=mymap[s[i]];
            &amp;#125;
            else&amp;#123;
                ans+=mymap[s[i]];
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;58-最后一个单词的长度&#34;&gt;&lt;a href=&#34;#58-最后一个单词的长度&#34; class=&#34;headerlink&#34; title=&#34;58.最后一个单词的长度&#34;&gt;&lt;/a&gt;58.最后一个单词的长度&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。&lt;br&gt;&lt;strong&gt;单词&lt;/strong&gt;是指仅由字母组成、不包含任何空格字符的最大子字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-3&#34;&gt;&lt;a href=&#34;#解题思路-3&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;【方法一】&lt;/strong&gt;&lt;br&gt;我的思路是&lt;strong&gt;从后向前&lt;/strong&gt;遍历字符串时：如果它的后一个是空格或空，自己不是空格，意味着句尾有空格，该下标是倒着数第一个不为空格的字母；如果前一个是空格或空，自己不是空格，代表这是词的开头，记录下标直接退出循环。最后长度就是二者相减。&lt;br&gt;但是这样写大多数样例不通过（悲&lt;/p&gt;
&lt;p&gt;（二编）卧槽我改对了！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【方法二】&lt;/strong&gt;&lt;br&gt;不对那就改呗：直接从字符串的尾部开始遍历，&lt;strong&gt;跳过所有尾部空格&lt;/strong&gt;，直到遇到&lt;strong&gt;第一个非空格字符&lt;/strong&gt;，并计算其长度。能够更好的处理边界情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int 长度=字符串长度;
int i=长度-1;
int 结果长度=0
当i大于等于0并且s的第i个字符为空格时：
    i--；（倒着循环遍历）
*本题设定s不为空，若无此条件需在此判断：当i&amp;lt;0时直接返回（s为空）
当i大于等于0并且s的第i个字符不为空格时：
    结果长度++；
    i--；
返回结果长度;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-3&#34;&gt;&lt;a href=&#34;#AC代码-3&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;【方法一】&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int lengthOfLastWord(string s) &amp;#123;
        int len=s.length();
        int m=0,n=0;
        for(int i=len-1;i&amp;gt;0;i--)&amp;#123;
            if(s[i]!=&amp;#39; &amp;#39; &amp;amp;&amp;amp; (s[i+1]==&amp;#39; &amp;#39; || s[i+1]==&amp;#39;\0&amp;#39;))&amp;#123;
                m=i;
            &amp;#125;
            if((s[i-1]==&amp;#39; &amp;#39; || s[i-1]==&amp;#39;\0&amp;#39;) &amp;amp;&amp;amp; s[i]!=&amp;#39; &amp;#39;)&amp;#123;
                n=i;
                break;
            &amp;#125;
        &amp;#125;
        return m-n+1;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;【方法二】&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int lengthOfLastWord(string s) &amp;#123;
        int len=s.length();
        int ans=0;
        int i=len-1;
        while(i&amp;gt;=0 &amp;amp;&amp;amp; s[i]==&amp;#39; &amp;#39;)&amp;#123;
            i--;
        &amp;#125;
        while(i&amp;gt;=0 &amp;amp;&amp;amp; s[i]!=&amp;#39; &amp;#39;)&amp;#123;
            ans++;
            i--;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-回文数&#34;&gt;&lt;a href=&#34;#9-回文数&#34; class=&#34;headerlink&#34; title=&#34;9.回文数&#34;&gt;&lt;/a&gt;9.回文数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;br&gt;回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;br&gt;例如，121 是回文，而 123 不是。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-4&#34;&gt;&lt;a href=&#34;#解题思路-4&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回文数是正整数&lt;/li&gt;
&lt;li&gt;负数不是回文数&lt;/li&gt;
&lt;li&gt;一个数的最后一位是0且这个数不为0，不是回文数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将数字的后半部分反转，用&lt;code&gt;反转数字&lt;/code&gt;存储。最后的反转数字包含原始x的后半部分，x包含原始x的前半部分。&lt;br&gt;最后返回时：若&lt;strong&gt;原始x是偶数&lt;/strong&gt;，那么对于回文数，&lt;strong&gt;x一定&amp;#x3D;反转数字&lt;/strong&gt;。若&lt;strong&gt;原始x是奇数&lt;/strong&gt;，那么反转数字会比x多一位，这一位是反转数字的个位并且是原始x的中位数，不影响回文数判断。所以&lt;strong&gt;先去掉个位&lt;/strong&gt;再与当前的x比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果（x小于0，或者x的个位不等于0且x不等于0）：
    不是回文数；
定义反转数字=0；
当（x &amp;gt; 反转数字）：
    反转数字=反转数字*10+x%10；
    x/=10；
x = 反转数字
返回x = 反转数字 或者 x = 去掉个位的反转数字；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-4&#34;&gt;&lt;a href=&#34;#AC代码-4&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    bool isPalindrome(int x) &amp;#123;
        if(x&amp;lt;0 || (x%10==0 &amp;amp;&amp;amp; x!=0))&amp;#123;
            return false;
        &amp;#125;
        int num=0;
        while(x&amp;gt;num)&amp;#123;
            num=num*10+x%10;
            x/=10;
        &amp;#125;
        return x==num || x==num/10;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-最长公共前缀&#34;&gt;&lt;a href=&#34;#14-最长公共前缀&#34; class=&#34;headerlink&#34; title=&#34;14.最长公共前缀&#34;&gt;&lt;/a&gt;14.最长公共前缀&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-5&#34;&gt;&lt;a href=&#34;#解题思路-5&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;区区小简单，真是难倒我了。&lt;br&gt;这里总结力扣官方题解的纵向扫描方法。我一开始想的也是类似思路，奈何憋不出来代码。&lt;br&gt;&lt;strong&gt;关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最长公共前缀的长度不可能超过任何一个字符串的长度&lt;/li&gt;
&lt;li&gt;数组strs的大小即为字符串的总个数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二维数组形式&lt;/strong&gt;可以直接表示第i个字符的第j位&lt;/li&gt;
&lt;li&gt;如果 &lt;strong&gt;&lt;code&gt;i&lt;/code&gt;超出某个字符串的长度&lt;/strong&gt;或**第&lt;code&gt;j&lt;/code&gt;个字符串的第&lt;code&gt;i&lt;/code&gt;个字符不等于&lt;code&gt;c&lt;/code&gt;**时，直接返回当前的公共前缀。&lt;/li&gt;
&lt;li&gt;循环结束说明所有字符串的所有字符都匹配，那么第一个字符串本身就是最长公共前缀，返回第一个字符串&lt;code&gt;strs[0]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;如果数组为空：
    返回&amp;quot;&amp;quot;；
int 长度变量=数组第一个字符串元素的长度；
int 计数变量=数组大小；
遍历i，从0到长度变量：
    char 字符变量=第一个字符串的第i个字符；
    遍历j，从1到计数变量：
        如果（i==第j个字符串的大小 || 第j个字符串的第i个字符 ！= 字符变量）：
            返回 第一个字符串的第一个字符~第i个字符；
返回 第一个字符；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-5&#34;&gt;&lt;a href=&#34;#AC代码-5&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) &amp;#123;
        if(!strs.size())&amp;#123;
            return &amp;quot;&amp;quot;;
        &amp;#125;
        int len=strs[0].size();
        int cnt=strs.size();
        for(int i=0;i&amp;lt;len;i++)&amp;#123;
            char c=strs[0][i];
            for(int j=1;j&amp;lt;cnt;j++)&amp;#123;
                if(i==strs[j].size() || strs[j][i]!=c)&amp;#123;
                    return strs[0].substr(0,i);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return strs[0];
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;682-棒球比赛&#34;&gt;&lt;a href=&#34;#682-棒球比赛&#34; class=&#34;headerlink&#34; title=&#34;682.棒球比赛&#34;&gt;&lt;/a&gt;682.棒球比赛&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;比赛开始时，记录是空白的。你会得到一个记录操作的&lt;strong&gt;字符串列表&lt;/strong&gt; ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数 x - 表示本回合新获得分数 x&lt;/li&gt;
&lt;li&gt;“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。&lt;/li&gt;
&lt;li&gt;“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。&lt;/li&gt;
&lt;li&gt;“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。&lt;br&gt;请你返回记录中所有得分的总和。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-6&#34;&gt;&lt;a href=&#34;#解题思路-6&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;用int动态数组ans记录得分，但是不用i做索引来查询，而是用begin、end、size、back等方法来防止发生越界访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意&lt;code&gt;string&lt;/code&gt;类型为字符串，用双引号””括起来，&lt;code&gt;char&lt;/code&gt;类型为字符，用单引号’’。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;前两次得分之和：size-1 +size-2
前一次得分：back
最近一次得分移除-&amp;gt;出栈-&amp;gt;pop_back
加入得分：压栈-&amp;gt;push_back
字符串转整型：stoi
计算动态数组的和：accumulate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，我一开始想用&lt;code&gt;unordered_map&lt;/code&gt;，做题做迷了。后来发现动态数组完全可以解决：C++ 标准库中的 vector 支持动态调整大小，可以方便地模拟栈的行为。而unordered_map 是用来存储键值对（key-value pairs）的哈希表。&lt;br&gt;本问题中不需要映射关系，所以并不需要用到 unordered_map。&lt;br&gt;还有，&lt;strong&gt;stack&lt;int&gt;&lt;strong&gt;的&lt;code&gt;.push()&lt;/code&gt;和&lt;code&gt;.pop()&lt;/code&gt;也可，但是&lt;/strong&gt;vector&lt;/strong&gt;的&lt;code&gt;.push_back()&lt;/code&gt;和&lt;code&gt;.pop_back()&lt;/code&gt;也同样可以。那就选更常用的vector，何乐而不为呢？&lt;/p&gt;
&lt;h3 id=&#34;AC代码-6&#34;&gt;&lt;a href=&#34;#AC代码-6&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;用时击败7%，悲。之后滚回来优化算法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int calPoints(vector&amp;lt;string&amp;gt;&amp;amp; operations) &amp;#123;
        vector&amp;lt;int&amp;gt;ans;
        for(string ch:operations)&amp;#123;
            if(ch==&amp;quot;+&amp;quot;)&amp;#123;
                ans.push_back(ans[ans.size()-1]+ans[ans.size()-2]);
            &amp;#125;
            else if(ch==&amp;quot;D&amp;quot;)&amp;#123;
                ans.push_back(ans.back()*2);
            &amp;#125;
            else if(ch==&amp;quot;C&amp;quot;)&amp;#123;
                ans.pop_back();
            &amp;#125;
            else&amp;#123;
                ans.push_back(stoi(ch));
            &amp;#125;
        &amp;#125;
        return accumulate(ans.begin(),ans.end(),0);
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;26-删除有序数组中的重复项&#34;&gt;&lt;a href=&#34;#26-删除有序数组中的重复项&#34; class=&#34;headerlink&#34; title=&#34;26.删除有序数组中的重复项&#34;&gt;&lt;/a&gt;26.删除有序数组中的重复项&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个非严格递增排列的数组nums,请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回nums中唯一元素的个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑nums的唯一元素的数量为k，你需要做以下事情确保你的题解可以被通过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改数组nums，使nums的前k个元素包含唯一元素，并按照它们最初在nums中出现的顺序排列。nums的其余元素与nums的大小不重要。&lt;/li&gt;
&lt;li&gt;返回 k 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-7&#34;&gt;&lt;a href=&#34;#解题思路-7&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;int 最终数组长度=1;
遍历nums：
    如果第i个元素不等于第i-1个元素：
        nums[最终数组长度]=nums[i]；
        最终数组长度++；
返回最终数组长度；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;AC代码-7&#34;&gt;&lt;a href=&#34;#AC代码-7&#34; class=&#34;headerlink&#34; title=&#34;AC代码&#34;&gt;&lt;/a&gt;AC代码&lt;/h3&gt;&lt;p&gt;妈呀这题一提交发现每ms都有解法…密密麻麻(ΩДΩ)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int ans=1;
        for(int i=1;i&amp;lt;nums.size();i++)&amp;#123;
            if(nums[i]!=nums[i-1])&amp;#123;
                nums[ans]=nums[i];
                ans++;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1922-统计好数字的数目&#34;&gt;&lt;a href=&#34;#1922-统计好数字的数目&#34; class=&#34;headerlink&#34; title=&#34;1922.统计好数字的数目&#34;&gt;&lt;/a&gt;1922.统计好数字的数目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。&lt;br&gt;比方说，”2582” 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 “3245” 不是 好数字，因为 3 在偶数下标处但不是偶数。&lt;br&gt;给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 10^9 + 7 取余后返回 。&lt;br&gt;一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 1015&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-8&#34;&gt;&lt;a href=&#34;#解题思路-8&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;🤔一开始就被范围吓到了，这完全穷举不了啊，悲。&lt;br&gt;这道题不超时的话只能用数学方法了，快来和我一起看&lt;a href=&#34;https://leetcode.cn/problems/count-good-numbers/solutions/857728/cheng-fa-yuan-li-kuai-su-mi-by-endlessch-btkn/?envType=daily-question&amp;envId=2025-04-13&#34;&gt;题解&lt;/a&gt;!&lt;br&gt;&lt;strong&gt;总结一下&lt;/strong&gt; 对于长度为n的好数字字符串：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;偶数下标个数&lt;code&gt;a=⌈n/2⌉=⌊(n+1)/2⌋&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;下标有五种可能：0、2、4、6、8&lt;/li&gt;
&lt;li&gt;方案数&lt;code&gt;5^a&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;*注意这里⌈ ⌉是向上取整，⌊ ⌋是向下取整。我也是最近才学到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;奇数下标个数&lt;code&gt;b=⌊n/2⌋&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;下标有四种可能：2、3、5、7&lt;/li&gt;
&lt;li&gt;方案数&lt;code&gt;4^b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;可得总方案数为&lt;code&gt;(5^a)*(4^b)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里涉及到两个问题：&lt;br&gt;&lt;strong&gt;👉️快速幂&lt;/strong&gt;&lt;br&gt;直接暴力pow必定超时&amp;#x2F;爆栈，所以需要快速幂。&lt;a href=&#34;https://leetcode.cn/problems/powx-n/solutions/2858114/tu-jie-yi-zhang-tu-miao-dong-kuai-su-mi-ykp3i/&#34;&gt;方法&lt;/a&gt;太神了…趁热打铁把&lt;a href=&#34;https://leetcode.cn/problems/powx-n/description/&#34;&gt;50.Pow(x,n)&lt;/a&gt;一起拿下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;x^n&lt;/code&gt;怎么快速算？&lt;br&gt;n转二进制后，从右往左遍历，遇到1就乘对应x的幂次。&lt;br&gt;比如&lt;code&gt;13 = 1101&lt;/code&gt;：&lt;br&gt;那么&lt;code&gt;x^13&lt;/code&gt; &amp;#x3D; &lt;code&gt;x^(2^0)&lt;/code&gt; * &lt;code&gt;x^(2^2)&lt;/code&gt; * &lt;code&gt;x^(2^3)&lt;/code&gt; &amp;#x3D; &lt;code&gt;x&lt;/code&gt; * &lt;code&gt;x^4&lt;/code&gt; * &lt;code&gt;x^8&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;👉️取模&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为题目要算的答案特别大以至于超出64位整数的范围，所以要求对&lt;code&gt;10^9 + 7&lt;/code&gt;取模。&lt;br&gt;这里好多数学公式😫先把代码总结&lt;a href=&#34;(https://leetcode.cn/discuss/post/3584387/fen-xiang-gun-mo-yun-suan-de-shi-jie-dan-7xgu/)&#34;&gt;copy&lt;/a&gt;过来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;MOD = 1_000_000_007
// 加
(a + b) % MOD
// 减
(a - b + MOD) % MOD
// 把任意整数 a 取模到 [0,MOD-1] 中，无论 a 是正是负
(a % MOD + MOD) % MOD
// 乘（注意使用 64 位整数）
a * b % MOD
// 多个数相乘，要步步取模，防止溢出
a * b % MOD * c % MOD
// 除（MOD 是质数且 b 不是 MOD 的倍数）
a * qpow(b, MOD - 2, MOD) % MOD
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    const long long mod=1e9+7;
    //快速幂：计算base^exp
    long long ModPow(long long base,long long exp)&amp;#123;
        long long res=1;
        while(exp)&amp;#123;
            if(exp%2==1)&amp;#123;//当前位是1
                res=(res*base)%mod;
            &amp;#125;
            base=(base*base)%mod;//base^2是base的下一步幂
            exp/=2;
        &amp;#125;
        return res;
    &amp;#125;
    //主函数
    int countGoodNumbers(long long n) &amp;#123;
        long long a,b;
        a=(n+1)/2;
        b=n/2;
        return (ModPow(5,a)*ModPow(4,b))% mod;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;50-Pow-x-n&#34;&gt;&lt;a href=&#34;#50-Pow-x-n&#34; class=&#34;headerlink&#34; title=&#34;50.Pow(x,n)&#34;&gt;&lt;/a&gt;50.Pow(x,n)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-100.0 &amp;lt; x &amp;lt; 100.0&lt;/li&gt;
&lt;li&gt;231 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 231-1&lt;/li&gt;
&lt;li&gt;n 是一个整数&lt;/li&gt;
&lt;li&gt;要么 x 不为零，要么 n &amp;gt; 0 。&lt;/li&gt;
&lt;li&gt;-104 &amp;lt;&amp;#x3D; xn &amp;lt;&amp;#x3D; 104&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解题思路-9&#34;&gt;&lt;a href=&#34;#解题思路-9&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;详见上一题~这里还涉及到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n为负数&lt;br&gt;把n变成-n，x变为1&amp;#x2F;x。&lt;/li&gt;
&lt;li&gt;n&amp;#x3D;(−2)^31&lt;br&gt;此时n取反会超出int最大值，可以转为64位int。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，关键代码&lt;a href=&#34;https://leetcode.cn/problems/powx-n/solutions/2858114/tu-jie-yi-zhang-tu-miao-dong-kuai-su-mi-ykp3i/&#34;&gt;灵神&lt;/a&gt;的更简洁，放在这里学习一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        while (n) &amp;#123; // 从低到高枚举 n 的每个比特位
            if (n &amp;amp; 1) &amp;#123; // 这个比特位是 1
                ans *= x; // 把 x 乘到 ans 中
            &amp;#125;
            x *= x; // x 自身平方
            n &amp;gt;&amp;gt;= 1; // 继续枚举下一个比特位
        &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h3&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    double myPow(double x, int N) &amp;#123;
        double res=1;
        long long n=N;
        while(n)&amp;#123;
            if(n&amp;lt;0)&amp;#123;
                n=-n;
                x=1/x;
            &amp;#125;
            if(n%2==1)&amp;#123;
                res=(res*x);
            &amp;#125;
            x=x*x;
            n/=2;
        &amp;#125;
        return res;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>

{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"链表\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "url": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "title": "Leetcode链表",
            "date_published": "2025-03-06T02:25:28.000Z",
            "content_html": "<p>链表这东西真的学一阵忘一阵😂</p>\n<h1 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h1><h2 id=\"结构定义\"><a href=\"#结构定义\" class=\"headerlink\" title=\"结构定义\"></a>结构定义</h2><ul>\n<li>节点结构 <code>ListNode</code></li>\n<li>值 <code>data</code></li>\n<li>指向下一个节点的指针 <code>next</code></li>\n</ul>\n<pre><code class=\"language-cpp\">struct ListNode&#123;\n    int data;\n    ListNode* next;\n    ListNode(int x):data(x),next(nullptr)&#123;&#125;\n&#125;Node;\n</code></pre>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h3 id=\"创建链表\"><a href=\"#创建链表\" class=\"headerlink\" title=\"创建链表\"></a>创建链表</h3><p>定义单链表类，封装基本操作。下面的几个操作都在public里~</p>\n<pre><code class=\"language-cpp\">class LinkedList&#123;\npublic:\n    ListNode* head;\n    LinkedList():head(nullptr);\n&#125;\n</code></pre>\n<h3 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h3><ul>\n<li>头插法:新节点加到链表头部</li>\n</ul>\n<pre><code class=\"language-cpp\">void insertAtHead(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    newNode-&gt;next=head;\n    head=newNode;\n&#125;\n</code></pre>\n<ul>\n<li>尾插法：:新节点加到链表尾部</li>\n</ul>\n<pre><code class=\"language-cpp\">void insertAtTail(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    if(!head)&#123;\n        head=newNode;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    temp-&gt;next=newNode;\n&#125;\n</code></pre>\n<h3 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h3><pre><code class=\"language-cpp\">void deleteNode(int data)&#123;\n    if(!head)&#123;\n        return;\n    &#125;\n    if(head-&gt;data==data)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;val !=val)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    if(temp-&gt;next)&#123;\n        ListNode* delNode=temp-&gt;next;\n        temp-&gt;next=temp-&gt;next-&gt;next;\n        delete delNode;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"修改节点\"><a href=\"#修改节点\" class=\"headerlink\" title=\"修改节点\"></a>修改节点</h3><pre><code class=\"language-cpp\">void updateNode(int oldData,newData)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-data==oldData)&#123;\n            temp-&gt;data==oldData;\n            return;\n        &#125;\n        temp=temp-&gt;next;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h3><pre><code class=\"language-cpp\">bool searchNode(int data)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-&gt;data==data)&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h3 id=\"打印链表\"><a href=\"#打印链表\" class=\"headerlink\" title=\"打印链表\"></a>打印链表</h3><pre><code class=\"language-cpp\">void printList()&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        cout&lt;&lt;temp-&gt;val&lt;&lt;&quot;-&gt;&quot;;\n        temp=temp-&gt;next;\n    &#125;\n    cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl;\n&#125;\n</code></pre>\n<h3 id=\"释放链表内存\"><a href=\"#释放链表内存\" class=\"headerlink\" title=\"释放链表内存\"></a>释放链表内存</h3><pre><code class=\"language-cpp\">~LinkedList()&#123;\n    while(head)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21.合并两个有序链表\"></a>21.合并两个有序链表</h1><blockquote>\n<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>提示：</p>\n<ul>\n<li>两个链表的节点数目范围是 [0, 50]</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>l1和l2均按非递减顺序排列</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>👉️ <em><strong>终止条件</strong></em>：有链表为空</p>\n<ul>\n<li>list1为空，合并结果直接为list2</li>\n<li>list2为空，合并结果直接为list1</li>\n</ul>\n<p>👉️ <em><strong>递归调用</strong></em>：小的打头，每一步递归后返回的值链接到链表末尾</p>\n<ul>\n<li>如果<code>list1节点的值 &lt; list2</code>：寻找list1后面节点还有没有也比list2小的节点</li>\n</ul>\n<pre><code>让list1-&gt;next接上递归后合并的结果；\n返回当前较小的节点list1;\n</code></pre>\n<ul>\n<li>else：寻找list2后面节点还有没有也比list1小的节点</li>\n</ul>\n<pre><code>让list2-&gt;next接上递归后合并的结果；\n返回当前较小的节点list2;\n</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        if(list1==NULL || list2==NULL)&#123;\n            return list1==NULL ? list2:list1;\n        &#125;\n        if(list1-&gt;val &lt; list2-&gt;val)&#123;\n            list1-&gt;next = mergeTwoLists(list1-&gt;next,list2);\n            return list1;\n        &#125;\n        else&#123;\n            list2-&gt;next = mergeTwoLists(list1,list2-&gt;next);\n            return list2;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.反转链表</h1><p>又是一道经典中的经典题🙀</p>\n<blockquote>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点的数目范围是 [0, 5000]</li>\n<li>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>👉️ <em><strong>链表反转的本质</strong></em></p>\n<ul>\n<li>让当前节点<code>cur</code>指向它的前一个节点<code>pre</code>。而不是后一个节点next</li>\n<li>更新<code>pre</code>和<code>cur</code>，直到cur为空。此时pre为新的head节点</li>\n</ul>\n<p>这里模拟一下过程。<br>👉️ <em><strong>假设存在链表：1-&gt;2-&gt;3-&gt;4-&gt;nullptr</strong></em><br>初始状态：</p>\n<ul>\n<li>pre &#x3D; nullptr</li>\n<li>cur &#x3D; head<br>那么逐步变化如下：</li>\n</ul>\n<p>| <code>cur</code> | <code>tmp(cur-&gt;next)</code> | <code>cur-&gt;next=pre</code> | <code>pre=cur</code> | <code>cur=tmpS</code> |<br>| :–: | :–: | :–: |<br>| 1 | 2 | <code>1-&gt;nullptr</code> | <code>pre=1</code> | <code>cur=2</code> |<br>| 2 | 3 | <code>2-&gt;1</code> | <code>pre=2</code> | <code>cur=3</code> |<br>| 3 | 4 | <code>3-&gt;2</code> | <code>pre=3</code> | <code>cur=4</code> |<br>| 4 | nullptr | <code>4-&gt;3</code> | <code>pre=4</code> | <code>cur=nullptr</code>（结束） |</p>\n<p>最终pre变成4，即新的链表头头。<br><strong>此时链表结构为：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; nullptr</strong>。</p>\n<p>👉️ <em><strong>简单来说，关键步骤是</strong></em><br>1️⃣记录下一个节点<br>2️⃣反转指向<br>3️⃣更新pre（当前节点变成新的头）<br>4️⃣继续遍历</p>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* pre=nullptr;\n        ListNode* cur=head;\n        while(cur!=nullptr)&#123;\n            ListNode* tmp=cur-&gt;next;\n            cur-&gt;next=pre;\n            pre=cur;\n            cur=tmp;\n        &#125;\n        return pre;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加\"></a>2.两数相加</h1><blockquote>\n<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>每个链表中的节点数在范围 [1, 100] 内</li>\n<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>这道题着实难倒我🥹乖乖去看<a href=\"https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/\">题解</a></p>\n<ol>\n<li><p>链表<strong>逆序</strong>存储数字</p>\n</li>\n<li><p><code>两个链表的节点值 + 进位值</code>如果记为<code>a</code>：</p>\n</li>\n</ol>\n<ul>\n<li><code>a % 10</code>为当前节点保存的数位</li>\n<li><code>a / 10</code>为新的进位值</li>\n</ul>\n<ol start=\"3\">\n<li>递归思路</li>\n</ol>\n<ul>\n<li>如果l1、l2都为空且carry&#x3D;0，递归结束</li>\n<li>定义sum&#x3D;carry</li>\n<li>如果l1不为空，sum+&#x3D;l1-&gt;val，l1&#x3D;l1-&gt;next</li>\n<li>同理，如果l2不为空，sum+&#x3D;l2-&gt;val，l2&#x3D;l2-&gt;next</li>\n<li>new一个当前节点node：<code>ListNode* node=new ListNode(sum%10)</code></li>\n<li>递归调用处理node-&gt;next</li>\n<li>返回当前节点node</li>\n</ul>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2,int carry=0) &#123;\n        if(l1==nullptr &amp;&amp; l2==nullptr &amp;&amp; carry==0)&#123;\n            return nullptr;\n        &#125;\n        int sum=carry;\n        if(l1!=nullptr)&#123;\n            sum+=l1-&gt;val;\n            l1=l1-&gt;next;\n        &#125;\n        if(l2!=nullptr)&#123;\n            sum+=l2-&gt;val;\n            l2=l2-&gt;next;\n        &#125;\n        ListNode* node=new ListNode(sum%10);\n        carry=sum/10;\n        node-&gt;next=addTwoNumbers(l1,l2,carry);\n        return node;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"83-删除排序链表中的重复元素\"><a href=\"#83-删除排序链表中的重复元素\" class=\"headerlink\" title=\"83.删除排序链表中的重复元素\"></a>83.删除排序链表中的重复元素</h1><blockquote>\n<p>给定一个已排序的链表的头head，删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点数目在范围 [0, 300] 内</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>题目数据保证链表已经按升序排列</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li>【如果】头节点&#x3D;空：直接返回该节点</li>\n<li>初始化一个当前节点变量&#x3D;头节点</li>\n<li>【只要】当前<code>节点-&gt;next</code>不为空</li>\n</ol>\n<ul>\n<li>「如果」<code>当前节点-&gt;next的值</code>&#x3D;<code>当前节点的值</code>： <code>当前节点-&gt;next</code>&#x3D;<code>当前节点-&gt;next-&gt;next</code></li>\n<li>「否则」<code>当前节点</code>&#x3D;<code>当前节点-&gt;next</code></li>\n</ul>\n<ol start=\"4\">\n<li>返回头节点</li>\n</ol>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if(head==nullptr)&#123;\n            return head;\n        &#125;\n        ListNode* cur=head;\n        while(cur-&gt;next!=nullptr)&#123;\n            if(cur-&gt;next-&gt;val==cur-&gt;val)&#123;\n                cur-&gt;next=cur-&gt;next-&gt;next;\n            &#125;\n            else&#123;\n                cur=cur-&gt;next;\n            &#125;\n        &#125;\n        return head;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "算法",
                "链表",
                "力扣"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"专题\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/04/01/%E4%B8%93%E9%A2%983-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "url": "https://232akira.github.io/2025/04/01/%E4%B8%93%E9%A2%983-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "title": "专题3️⃣ 动态规划",
            "date_published": "2025-04-01T01:18:00.000Z",
            "content_html": "<p>动规来力！！！</p>\n<h1 id=\"2140-解决智力问题\"><a href=\"#2140-解决智力问题\" class=\"headerlink\" title=\"2140.解决智力问题\"></a>2140.解决智力问题</h1><blockquote>\n<p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] &#x3D; [pointsi, brainpoweri] 。<br>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。<br>比方说，给你 questions &#x3D; [[3, 2], [4, 3], [4, 4], [2, 5]] ：</p>\n<ul>\n<li>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</li>\n<li>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br>请你返回这场考试里你能获得的 最高分数。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; questions.length &lt;&#x3D; 105</li>\n<li>questions[i].length &#x3D;&#x3D; 2</li>\n<li>1 &lt;&#x3D; pointsi, brainpoweri &lt;&#x3D; 105</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>解决我的智力问题（不是🤯</p>\n<p>看了<a href=\"https://leetcode.cn/problems/solving-questions-with-brainpower/solutions/1213919/dao-xu-dp-by-endlesscheng-2qkc/?envType=daily-question&envId=2025-04-01\">题解</a>发现是打家劫舍的变体题，所以带着一块儿做了。</p>\n<p>👉相当于如果选了k，接下来有x个不能选：打家劫舍是x&#x3D;1，本题x&#x3D;questions[i][1]。</p>\n<ol>\n<li><p>子问题<br>原问题：“完成考试（即所有题都已解决or跳过）能获得的最大分数”<code>→</code>子问题：“完成前k道题能获得的最大分数”</p>\n</li>\n<li><p>递推关系<br>👉已知子问题f(k)，那么只关注当前（即第k道）题，只有两种做题方法：<br>做k &amp;&amp; 做k+x<code>or</code>不做k &amp;&amp; 做k+1</p>\n</li>\n</ol>\n<p>👉递推关系：<code>f(k)=max&#123;f(k-1),k-1道题的分数+f(k-1+x)&#125;</code></p>\n<p>边界：无题目（k&#x3D;0）和只有一道题(k&#x3D;1)</p>\n<ol start=\"3\">\n<li>dp数组的计算顺序<br>✅️dp[k]依赖于dp[k-1]和dp[k-1+x]</li>\n</ol>\n<p>不对。这题搞得我现在有点懵，这会正好感冒昏昏沉沉的😵‍💫等我二编…</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">\n</code></pre>\n<h1 id=\"53-最大子数组和\"><a href=\"#53-最大子数组和\" class=\"headerlink\" title=\"53.最大子数组和\"></a>53.最大子数组和</h1><blockquote>\n<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>经典解法：Kadane算法</strong>。核心思路是动态规划，通过遍历数组维护当前最大子数组和。整体思路如下：<br>1️⃣<strong>维护两个变量：</strong></p>\n<ul>\n<li><code>sum</code>当前最大子数组和</li>\n<li><code>maxsum</code>全局最大子数组和<br>2️⃣<strong>遍历数组，每次决定是否扩展当前子数组</strong></li>\n<li>如果<code>sum+nums[i] &lt; nums[i]</code> 从nums[i]重新开始（之前的子数组必定与最大和无关</li>\n<li>否则继续累加nums[i]<br>3️⃣<strong>每次更新<code>maxsum</code></strong></li>\n</ul>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int sum=nums[0];\n        int maxsum=nums[0];\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            sum=max(nums[i],sum+nums[i]);\n            maxsum=max(sum,maxsum);\n        &#125;\n        return maxsum;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "专题",
                "C++"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "url": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "title": "专题1️⃣ 滑动窗口",
            "date_published": "2025-03-12T10:20:15.000Z",
            "content_html": "<p>今天照例每日一题，然后麻溜的看题解，发现又是一道滑动窗口题。所以开个专题归类一下。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><h2 id=\"基础算法精讲03-滑动窗口\"><a href=\"#基础算法精讲03-滑动窗口\" class=\"headerlink\" title=\"基础算法精讲03-滑动窗口\"></a><a href=\"https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">基础算法精讲03-滑动窗口</a></h2><p>👉️双指针的应用场景：</p>\n<ul>\n<li>单调性</li>\n</ul>\n<h1 id=\"713-乘积小于K的子数组\"><a href=\"#713-乘积小于K的子数组\" class=\"headerlink\" title=\"713.乘积小于K的子数组\"></a>713.乘积小于K的子数组</h1><blockquote>\n<p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p>\n</blockquote>\n<blockquote>\n<p>提示: </p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; 106</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3.无重复字符的最长子串\"></a>3.无重复字符的最长子串</h1><blockquote>\n<p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</li>\n<li>s 由英文字母、数字、符号和空格组成</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h1><blockquote>\n<p>给定一个含有n个正整数的数组和一个正整数target。<br>找出该数组中满足其总和大于等于target的长度最小的子数组 [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; target &lt;&#x3D; 109</li>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>进阶：</p>\n<ul>\n<li>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>在数组字串问题中，经常会用到<strong>双指针</strong>这一技巧。</p>\n<ol>\n<li><p>暴力方法 时间复杂度<code>O(n^2)</code></p>\n</li>\n<li><p>枚举右端点，收缩左端点 时间复杂度<code>O(n)</code></p>\n</li>\n</ol>\n<ul>\n<li>拿到数组的长度n</li>\n<li>答案ans初始化为n+1或者更大</li>\n<li>总和sum初始化为0</li>\n<li>左端点left初始化为0</li>\n<li>right右端点for循环(0~n-1)：sum+&#x3D;nums[right]</li>\n<li>for嵌套while(s-nums[left]):此时子数组的和减去左端点依旧&gt;&#x3D;target：sum-&#x3D;nums[left];left+&#x3D;1;(移掉左端点)</li>\n<li>如果sum&gt;&#x3D;target:更新答案最小值 ans&#x3D;min(ans,right-left+1)</li>\n<li>返回ans（&lt;&#x3D;n返回ans，否则返回0）</li>\n</ul>\n<p><em><strong>注意：此题不需要判断left和right两者间的大小关系。</strong></em><br>因为当left&#x3D;right时，s-nums[left]&#x3D;0，一定比target小（target为正整数），不满足while条件。</p>\n<ol start=\"3\">\n<li>在「2」的基础上，把ans的更新写到while里面</li>\n</ol>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;\n        int n,ans,sum,left;\n        n=nums.size();\n        ans=n+1;\n        sum=left=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            // sum+=nums[i];\n            // while(sum-nums[left]&gt;=target)&#123;\n            //     sum-=nums[left];\n            //     left++;\n            // &#125;\n            // if(sum&gt;=target)&#123;\n            //     ans=min(ans,i-left+1);\n            // &#125;\n            while(sum&gt;=target)&#123;\n                ans=min(ans,i-left+1);\n                sum-=nums[left++];\n            &#125;\n        &#125;\n        return ans&lt;=n?ans:0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><p>今天字符串也要美丽了🆘</p>\n<blockquote>\n<p>一个整数num的k美丽值定义为num中符合以下条件的子字符串数目：</p>\n<ul>\n<li>子字符串长度为k。</li>\n<li>子字符串能整除num。<br>给你整数num和k，请你返回num的k美丽值。<br>注意：<br>允许有前缀0。<br>0不能整除任何值。<br>一个子字符串是一个字符串里的连续一段字符序列。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= num &lt;= 109</code></li>\n<li><code>1 &lt;= k &lt;= num.length</code> （将 num 视为字符串）</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我觉得这道的要点就是子串怎么得，剩下的就好判断了。偏偏我就栽在这儿了😅</p>\n<ul>\n<li><strong>int转string</strong> <code>to_string()</code>注意此函数需要赋给个string变量</li>\n<li><strong>string转int</strong> <code>stoi()</code>同样，需要赋给个int变量</li>\n<li><strong>获取长度为k的字符串</strong> <code>substr(i,k)</code>距离c++学这个函数已经过了一两年了，忘的一干二净，趁此好机会来总结一下。</li>\n</ul>\n<p>👇️ <em><strong>获取子串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>substr(pos,len)</code></td>\n<td align=\"center\">从pos开始，提取长度为len的子串</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>查找字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>find(str,pos)</code></td>\n<td align=\"center\">在pos之后查找str的位置，找不到返回string::pos</td>\n</tr>\n<tr>\n<td align=\"center\"><code>rfind(str,pos)</code></td>\n<td align=\"center\">逆向查找str,从pos开始向前找</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_first_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的第一次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_last_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的最后一次出现</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>替换字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>replace(pos,len,str)</code></td>\n<td align=\"center\">从pos开始，用str替换len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>erase(pos,len)</code></td>\n<td align=\"center\">删除从pos开始的len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>insert(pos,str)</code></td>\n<td align=\"center\">在pos位置插入str</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>大小写转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>toupper(c)</code></td>\n<td align=\"center\">将字符c转换为大写</td>\n</tr>\n<tr>\n<td align=\"center\"><code>tolower(c)</code></td>\n<td align=\"center\">将字符c转换为小写</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>数字与字符串转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>to_string(num)</code></td>\n<td align=\"center\">把num转换为字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stoi(str)</code></td>\n<td align=\"center\">把str转换为int</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stol(str)</code></td>\n<td align=\"center\">把str转换为long</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stod(str)</code></td>\n<td align=\"center\">把str转换为double</td>\n</tr>\n</tbody></table>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int divisorSubstrings(int num, int k) &#123;\n        int cnt=0;\n        string str=to_string(num);\n        for(int i=0;i&lt;=str.size()-k;i++)&#123;\n            string ans=str.substr(i,k);\n            int answer=stoi(ans);\n            if(answer!=0 &amp;&amp; num%answer==0)&#123;\n                cnt++;\n            &#125;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3305-元音辅音字符串计数Ⅰ\"><a href=\"#3305-元音辅音字符串计数Ⅰ\" class=\"headerlink\" title=\"3305.元音辅音字符串计数Ⅰ\"></a>3305.元音辅音字符串计数Ⅰ</h1><blockquote>\n<p>给你一个字符串word和一个非负整数 k。<br>返回word的子字符串中，每个元音字母（’a’、’e’、’i’、’o’、’u’）至少出现一次，并且恰好包含k个辅音字母的子字符串的总数。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>5 &lt;&#x3D; word.length &lt;&#x3D; 250</li>\n<li>word 仅由小写英文字母组成。</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; word.length - 5</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先试了试暴力😤循环套三层观感太差，不放上来。</p>\n<p><strong>正经解法</strong></p>\n<ul>\n<li>滑动窗口代替暴力循环</li>\n<li>哈希表统计元音出现次数</li>\n</ul>\n<p><strong>注意几个用法</strong><br><em><strong>1️⃣ 几个键值对容器</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键值对容器</th>\n<th align=\"center\">实现方式</th>\n<th align=\"center\">键值</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">是否有序</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unordered_map</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找键对应的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>map</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要有序键值对</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_set</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找元素是否存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>set</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要排序的集合</td>\n</tr>\n</tbody></table>\n<p><em><strong>2️⃣ 键值对容器+函数求的是什么？</strong></em></p>\n<ul>\n<li><code>unordered_map.size()</code>返回unordered_map中<strong>键值对的数量</strong>。</li>\n<li><code>unordered_set.count(x)</code>unordered_set中<strong>某个元素是否存在</strong>，返回1表示在，0表示不在。</li>\n</ul>\n<p>代码思路如下。这个方法时间空间上并非最优，后续需要调整思路。</p>\n<pre><code class=\"language-cpp\">定义n：word长度;\n定义unordered_map类型的vowel_cnt:元音出现次数;\n定义consonant_cnt:辅音个数;\n定义ans：统计最终答案;\n定义unordered_set类型的vowels:所有元音字母;\n定义左指针j=0;\n遍历word从下标0~word.size():\n    定义右元素right=word[i];\n    统计元音出现次数：\n        进行元/辅音计数;\n    当辅音数量超过k://收缩窗口左边界\n        定义左元素left=word[左指针];//取左边界字符\n        如果left是元音：\n            该元音出现次数--;\n            当元音的计数减少到0时：\n                将它从vowel_cnt中删除；\n        否则：\n            辅音个数--;\n        左指针右移;\n    如果包含所有元音且辅音个数为k:\n        //避免修改原窗口状态,思路整体与上半部分相同☝️\n        定义临时变量temp_vowel=vowel_cnt;\n        定义临时变量temp_consonant=consonant_cnt;\n        定义临时变量temp_j=j;\n        定义计数cnt=0;\n        当临时左下标&lt;=右下标:\n            如果包含所有临时元音且临时辅音个数为k:\n                cnt++;\n            否则:\n                退出该层循环;\n            定义c:word[临时左指针];\n            如果c是元音：\n                临时该元音出现次数--;\n                当临时元音的计数减少到0时：\n                    将它从临时vowel_cnt中删除;\n            否则:\n                临时辅音个数--;\n            临时左指针j右移;\n        ans+=cnt;\n返回ans;\n</code></pre>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countOfSubstrings(string word, int k) &#123;\n        int len=word.size();\n        unordered_map&lt;char,int&gt;vowel_cnt;\n        int consonant_cnt=0;\n        int ans=0;\n        unordered_set&lt;int&gt;vowels=&#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;&#125;;\n        int j=0;\n        for(int i=0;i&lt;len;i++)&#123;\n            char right=word[i];\n            if(vowels.count(right))&#123;\n                vowel_cnt[right]++;\n            &#125;\n            else&#123;\n                consonant_cnt++;\n            &#125;\n            while(consonant_cnt&gt;k)&#123;\n                char left=word[j];\n                if(vowels.count(left))&#123;\n                    vowel_cnt[left]--;\n                    if(vowel_cnt[left]==0)&#123;\n                        vowel_cnt.erase(left);\n                    &#125;\n                &#125;\n                else&#123;\n                    consonant_cnt--;\n                &#125;\n                j++;\n            &#125;\n            if(vowel_cnt.size()==5 &amp;&amp; consonant_cnt==k)&#123;\n                unordered_map&lt;char,int&gt;temp_vowel=vowel_cnt;\n                int temp_consonant=consonant_cnt;\n                int temp_j=j;\n                int cnt=0;\n                while(temp_j&lt;=i)&#123;\n                    if(temp_vowel.size()==5 &amp;&amp; temp_consonant==k)&#123;\n                        cnt++;\n                    &#125;\n                    else&#123;\n                        break;\n                    &#125;\n                    int c=word[temp_j];\n                    if(vowels.count(c))&#123;\n                        temp_vowel[c]--;\n                        if(temp_vowel[c]==0)&#123;\n                            temp_vowel.erase(c);\n                        &#125;\n                    &#125;\n                    else&#123;\n                        temp_consonant--;\n                    &#125;\n                    temp_j++;\n                &#125;\n                ans+=cnt;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3306-元音辅音字符串计数Ⅱ\"><a href=\"#3306-元音辅音字符串计数Ⅱ\" class=\"headerlink\" title=\"3306.元音辅音字符串计数Ⅱ\"></a>3306.元音辅音字符串计数Ⅱ</h1><p>不行，彻底懵了脑子转不动做梦都是元辅音😫先把copy的官方题解放这，过两天我再苟回来看。</p>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long countOfSubstrings(string word, int k) &#123;\n        set&lt;char&gt; vowels = &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;&#125;;\n        auto count = [&amp;](int m) -&gt; long long &#123;\n            int n = word.size(), consonants = 0;\n            long long res = 0;\n            map&lt;char, int&gt; occur;\n            for (int i = 0, j = 0; i &lt; n; i++) &#123;\n                while (j &lt; n &amp;&amp; (consonants &lt; m || occur.size() &lt; vowels.size())) &#123;\n                    if (vowels.count(word[j])) &#123;\n                        occur[word[j]]++;\n                    &#125; else &#123;\n                        consonants++;\n                    &#125;\n                    j++;\n                &#125;\n                if (consonants &gt;= m &amp;&amp; occur.size() == vowels.size()) &#123;\n                    res += n - j + 1;\n                &#125;\n                if (vowels.count(word[i])) &#123;\n                    occur[word[i]]--;\n                    if (occur[word[i]] == 0) &#123;\n                        occur.erase(word[i]);\n                    &#125;\n                &#125; else &#123;\n                    consonants--;\n                &#125;\n            &#125;\n            return res;\n        &#125;;\n        return count(k) - count(k + 1);\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "专题",
                "C++"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/04/%E4%B8%93%E9%A2%982-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/",
            "url": "https://232akira.github.io/2025/03/04/%E4%B8%93%E9%A2%982-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/",
            "title": "专题2️⃣ 贪心算法",
            "date_published": "2025-03-04T05:41:46.000Z",
            "content_html": "<p>力扣连着刷到了几个贪心，而且另一篇笔记字数要爆了，决定先按大类慢慢分一下。<br>🤟<a href=\"https://zhuanlan.zhihu.com/p/180104885\">参考链接</a><br>规律特征就是更加注重当前的状态,通常用于组合优化问题。即每一次都做出<strong>当前</strong>看起来<strong>最好的</strong>选择。每次只需要考虑一个问题，并通常是自底向上求解。即<strong>局部最优→全局最优</strong>。</p>\n<h1 id=\"455-分发饼干\"><a href=\"#455-分发饼干\" class=\"headerlink\" title=\"455.分发饼干\"></a>455.分发饼干</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><h1 id=\"976-三角形的最大周长\"><a href=\"#976-三角形的最大周长\" class=\"headerlink\" title=\"976.三角形的最大周长\"></a>976.三角形的最大周长</h1><blockquote>\n<p>给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。</p>\n<ul>\n<li><code>3 &lt;= nums.length &lt;= 104</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 106</code></li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>因为题目需要的是最大的三角形周长，所以不需要暴力列举所有的情况再一一对比，而是直接奔着“最大”这个目标求解就行:<br>三条边a,b,c（假设从小到大已排好），当a+b&gt;c时满足三角形。<strong>如果不满足，必须换更大的a,b</strong>。<br>贪心优化策略：</p>\n<ul>\n<li>nums排序</li>\n<li>从最大的三个数开始 尝试是否满足</li>\n<li>若无法满足，往前找更小的a,b</li>\n<li>一旦找到符合条件的三边，直接返回</li>\n</ul>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        for(int i=nums.size()-1;i&gt;=2;i++)&#123;\n            if(nums[i-1]+nums[i-2]&gt;nums[i])\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"860-柠檬水找零\"><a href=\"#860-柠檬水找零\" class=\"headerlink\" title=\"860.柠檬水找零\"></a>860.柠檬水找零</h1><blockquote>\n<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>\n<ul>\n<li><code>1 &lt;= bills.length &lt;= 105</code></li>\n<li><code>bills[i] 不是 5 就是 10 或是 20 </code></li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>**找零时，尽量先用大额。**并且只记录5美元、10美元的数量（因为这题目的情况不可能找20块）那么</p>\n<ul>\n<li>收到5美元  直接收 </li>\n<li>收到10美元 <code>10-5=5</code> 找5美元（如果有）</li>\n<li>收到20美元 <strong>贪心来了~</strong><code>20-5=15</code>优先使用10+5找零，否则用5+5+5（如果有）</li>\n</ul>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;\n        int five=0,ten=0;\n        for(int bill:bills)&#123;\n            if(bill==5)&#123;\n                five++;\n            &#125;\n            else if(bill==10)&#123;\n                if(five!=0)&#123;\n                    five--;\n                    ten++;\n                &#125;\n                else&#123;\n                    return false;\n                &#125;\n            &#125;\n            else if(bill==20)&#123;\n                if(ten&gt;0 &amp;&amp; five&gt;0)&#123;\n                    ten--;\n                    five--;\n                &#125;\n                else if(five&gt;=3)&#123;\n                    five-=3;\n                &#125;\n                else&#123;\n                    return false;\n                &#125;\n                \n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2680-最大或值\"><a href=\"#2680-最大或值\" class=\"headerlink\" title=\"2680.最大或值\"></a>2680.最大或值</h1><blockquote>\n<p>给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 k 。每一次操作中，你可以选择一个数并将它乘 2 。<br>你最多可以进行 k 次操作，请你返回 nums[0] | nums[1] | … | nums[n - 1] 的最大值。<br>a | b 表示两个整数 a 和 b 的 按位或 运算。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li>\n<li>1 &lt;&#x3D; k &lt;&#x3D; 15</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>做了这么几道中等题，发现很多难就难在变量大的时候怎么才能不超时的问题上😂</p>\n<p>因此要注意：<br><em><strong>👉️按位或（|）的特性</strong></em>（二进制数）某一位只要有一个是1，按位或的结果该位就是1。<br>题目需要按位或的最大值，那么也就意味着尽量让高位变成1。</p>\n<p><em><strong>👉️不能直接暴力枚举</strong></em>否则会超时。</p>\n<p><em><strong>🔍️按位运算总结</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运算</th>\n<th align=\"center\">运算符</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">按位与</td>\n<td align=\"center\"><code>&amp;</code></td>\n<td align=\"center\">两位都是1，结果才是1</td>\n<td align=\"center\"><code>5 &amp; 3 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">按位或</td>\n<td align=\"center\"><code>一竖杠</code></td>\n<td align=\"center\">只要有一个是1，结果就是1</td>\n<td align=\"center\"><code>5 或 3 = 7</code></td>\n</tr>\n<tr>\n<td align=\"center\">按位异或</td>\n<td align=\"center\"><code>^</code></td>\n<td align=\"center\">相同为0，不同为1</td>\n<td align=\"center\"><code>5 ^ 3 = 6</code></td>\n</tr>\n<tr>\n<td align=\"center\">按位取反</td>\n<td align=\"center\"><code>~</code></td>\n<td align=\"center\">0变1，1变0</td>\n<td align=\"center\"><code>~5 = -6</code>（补码）</td>\n</tr>\n<tr>\n<td align=\"center\">左移</td>\n<td align=\"center\"><code>&lt;&lt;</code></td>\n<td align=\"center\">乘2^k</td>\n<td align=\"center\"><code>5 &lt;&lt; 1 = 10</code></td>\n</tr>\n<tr>\n<td align=\"center\">右移</td>\n<td align=\"center\"><code>&gt;&gt;</code></td>\n<td align=\"center\">除2^k</td>\n<td align=\"center\"><code>5 &gt;&gt; 1 = 2</code></td>\n</tr>\n</tbody></table>\n<p>解决方案：<br><strong>1️⃣预计算最初的或值</strong></p>\n<ul>\n<li><code>orsum|=num</code></li>\n</ul>\n<p><strong>2️⃣按位或最大化</strong></p>\n<ul>\n<li>遍历nums，对每个num[i]进行优化</li>\n<li>假设nums[i]被选中，*2^k，计算新的或值</li>\n<li>对于已经选定的nums[i]，<code>0~i-1</code>的或值设为<code>leftor</code>;<code>i+1~n-1</code>的或值设为<code>rightor</code>。那么新的或值只需要让<code>leftor | nums[i]*2^k | rightor</code>即可。</li>\n<li>nums[i]*2^k用<code>nums[i] * (1LL &lt;&lt; k)</code>。表示位运算中的左移操作，让nums[i]的二进制向左移动k位右侧补零，等价于<code>*2^k</code>（这里可以自己试一试：<code>5&lt;&lt;3</code>等价于<code>40=5*8</code>。）；LL防止溢出。</li>\n</ul>\n<p><strong>🆗其他问题</strong></p>\n<ul>\n<li>为什么 <code>left[i+1] = left[i] | nums[i]</code>，<code>right[i] = right[i+1] | nums[i]</code>？<br>按位或计算有个特点：计算或值具有单调性，也就是a|b|c的结果一定不会比a|b小。<br><code>left[i]</code>存的是nums[0]~nums[1]的或值，又因为left[i+1]相比left[i]需要加入nums[i]进行或值运算，所以<code>left[i+1] = left[i] | nums[i]</code>；<code>right[i]</code>同理。</li>\n</ul>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long maximumOr(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n=nums.size();\n        vector&lt;long long&gt; left(n+1,0),right(n+1,0);\n        for(int i=0;i&lt;n;i++)&#123;\n            left[i+1]=left[i]|nums[i];\n        &#125;\n        for(int i=n-1;i&gt;=0;i--)&#123;\n            right[i]=right[i+1]|nums[i];\n        &#125;\n        long long maxor=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            long long newor;\n            newor=left[i]|(nums[i]*(1LL&lt;&lt;k))|right[i+1];\n            maxor=max(maxor,newor);\n        &#125;\n        return maxor;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2829-k-avoiding数组的最小总和\"><a href=\"#2829-k-avoiding数组的最小总和\" class=\"headerlink\" title=\"2829.k-avoiding数组的最小总和\"></a>2829.k-avoiding数组的最小总和</h1><blockquote>\n<p>给你两个整数 n 和 k 。<br>对于一个由 不同 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 k-avoiding 数组。<br>返回长度为 n 的 k-avoiding 数组的可能的最小总和。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; n, k &lt;&#x3D; 50</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li><strong>数组总和最小</strong><br>从<code>1</code>开始逐步添加符合条件的数字，直到数组长度达到<code>n</code></li>\n<li><strong>避免和为k</strong><br>尝试加入<code>x</code>时，确保数组中不存在<code>k-x</code></li>\n</ol>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minimumSum(int n, int k) &#123;\n        vector&lt;int&gt; ans;\n        unordered_set&lt;int&gt; used;\n        int num=1;\n        while(ans.size()&lt;n)&#123;\n            if(used.find(k-num)==used.end())&#123;\n                ans.push_back(num);\n                used.insert(num);\n            &#125;\n            num++;\n        &#125;\n        return accumulate(ans.begin(),ans.end(),0);\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2712-使所有字符相等的最小成本\"><a href=\"#2712-使所有字符相等的最小成本\" class=\"headerlink\" title=\"2712.使所有字符相等的最小成本\"></a>2712.使所有字符相等的最小成本</h1><blockquote>\n<p>给你一个下标从 0 开始、长度为 n 的二进制字符串 s ，你可以对其执行两种操作：</p>\n<ul>\n<li>选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。</li>\n<li>选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。<br>返回使字符串内所有字符 相等 需要的 最小成本 。<br>反转字符意味着：如果原来的值是 ‘0’ ，则反转后值变为 ‘1’ ，反之亦然。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; s.length &#x3D;&#x3D; n &lt;&#x3D; 105</li>\n<li>s[i] 为 ‘0’ 或 ‘1’</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li><strong>所有字符相等</strong></li>\n</ol>\n<ul>\n<li>全<code>1</code></li>\n<li>全<code>0</code></li>\n</ul>\n<ol start=\"2\">\n<li><strong>对于<code>i</code>，反转的成本</strong></li>\n</ol>\n<ul>\n<li>反转前缀<code>[0,i]</code>，成本<code>i+1</code></li>\n<li>反转后缀<code>[i,n-1]</code>，成本<code>n-i</code></li>\n</ul>\n<ol start=\"3\">\n<li><strong>核心问题</strong><br>对每个i，求出 min（s全1）和min（s全0），再对二者求min。<br>说人话就是：从0开始遍历，如果<code>s[i] ≠ s[i+1]</code>，那么我们此时有两种选择：反转前缀[0,i] 或 反转后缀[i,n-1]。对于每一个这样需要反转的i，我们选择反转前缀还是后缀的原则就是<strong>哪个成本小选哪个</strong>。最后得到的总成本也必然最小。</li>\n</ol>\n<p>👉️难理解的部分：<code>min(i,n-i)</code> 或 <code>min(i+1,n-i-1)</code>。<br>个人理解是因为对于此算法，实际上的分界点在s[i]和s[i+1]之间。也就是说：修正分界点需要做的是</p>\n<ul>\n<li>反转0~i</li>\n<li>反转i+1~n-1<br>这样求得的min才能保证达到我们“最小成本”的目标。</li>\n</ul>\n<p>👉️这里学到一个小知识：s.size()返回的类型为<strong>无符号整数（unsigned int）</strong></p>\n<blockquote>\n<ul>\n<li><code>size_t</code>无符号整型 (unsigned)</li>\n</ul>\n<ol>\n<li>是C++标准库中专门用于表示数组、容器的大小或索引的类型</li>\n<li>不能表示负数</li>\n<li>在 64 位系统上，size_t通常是unsigned long，比int更大，可表示更大的范围。</li>\n</ol>\n<ul>\n<li><code>int</code>有符号整型 (signed)</li>\n</ul>\n<ol>\n<li>是C++默认的整数类型，可以存储正数、负数和 0。</li>\n<li>取值范围一般是 [-2³¹, 2³¹ - 1]（32位系统） 或 [-2⁶³, 2⁶³ - 1]（64位系统）<br><em><strong>更适合存储一般的计数、索引、数学运算，而size_t主要用于数组大小和内存管理。</strong></em></li>\n</ol>\n</blockquote>\n<h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long minimumCost(string s) &#123;\n        long long int sum=0;\n        int n=s.size();\n        for(int i=0;i&lt;n-1;i++)&#123;\n            if(s[i]!=s[i+1])&#123;\n                sum+=min(i+1,n-i-1);\n            &#125;\n        &#125;\n        return sum;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "专题",
                "C++"
            ]
        }
    ]
}
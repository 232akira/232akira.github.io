{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"记录\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/04/09/%E7%82%B9%E6%88%91%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%BC%95/",
            "url": "https://232akira.github.io/2025/04/09/%E7%82%B9%E6%88%91%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%BC%95/",
            "title": "🔝点我查看指引",
            "date_published": "2025-04-09T07:09:00.000Z",
            "content_html": "<h1 id=\"关于如何食用本博客\"><a href=\"#关于如何食用本博客\" class=\"headerlink\" title=\"关于如何食用本博客\"></a>关于如何食用本博客</h1><p><strong>任务栏</strong>：pc全屏可直接点击顶端选项🍭pc分屏&#x2F;移动端点击左上角三横杠</p>\n<h2 id=\"了解更多我的故事\"><a href=\"#了解更多我的故事\" class=\"headerlink\" title=\"了解更多我的故事\"></a>了解更多我的故事</h2><p><code>左上角三横杠</code>-&gt;<code>关于</code><br>一些碎碎念，感谢赏光</p>\n<h2 id=\"昼夜模式\"><a href=\"#昼夜模式\" class=\"headerlink\" title=\"昼夜模式\"></a>昼夜模式</h2><p><code>任务栏右上角</code>-&gt;<code>太阳</code>or<code>月亮图标</code><br>不管白天黑夜，选择您舒适的方式浏览~</p>\n<h2 id=\"更清晰的看看有哪些文章\"><a href=\"#更清晰的看看有哪些文章\" class=\"headerlink\" title=\"更清晰的看看有哪些文章\"></a>更清晰的看看有哪些文章</h2><p><code>任务栏左上角</code>-&gt;<code>文章</code>-&gt;<code>归档</code><br>看看每月写了什么</p>\n<p><code>任务栏左上角</code>-&gt;<code>文章</code>-&gt;<code>标签</code><br>关键词定位文章更高效</p>\n<p>也可以直接点击目录上方的数字跳转。</p>\n<h2 id=\"🧩其他\"><a href=\"#🧩其他\" class=\"headerlink\" title=\"🧩其他\"></a>🧩其他</h2><h3 id=\"想来点音乐？\"><a href=\"#想来点音乐？\" class=\"headerlink\" title=\"想来点音乐？\"></a>想来点音乐？</h3><p><code>波浪动效</code>-&gt;<code>右边播放键</code></p>\n<h3 id=\"待完善的功能\"><a href=\"#待完善的功能\" class=\"headerlink\" title=\"待完善的功能\"></a>待完善的功能</h3><ul>\n<li>评论系统</li>\n<li>文章搜索</li>\n<li>其他异常显示<br>…</li>\n</ul>\n",
            "tags": [
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/01/HOT%20100/",
            "url": "https://232akira.github.io/2025/04/01/HOT%20100/",
            "title": "HOT 100",
            "date_published": "2025-04-01T07:29:31.000Z",
            "content_html": "<p>想了想方便复习，把<a href=\"https://leetcode.cn/studyplan/top-100-liked/\">hot100</a>先不按模块，零碎的把做过的还有简单题先搞定了再说。题都挪到这篇。</p>\n<p>话不多说开刷😤！！！</p>\n<h1 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h1><h2 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283.移动零\"></a>283.移动零</h2><blockquote>\n<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<strong>请注意</strong>，必须在不复制数组的情况下原地对数组进行操作。</p>\n</blockquote>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>一开始看到这道题就觉得不就是交换嘛。但是发现题目中的：“保持非零元素的相对顺序”我就懵了。于是开始暴力穷举循环一层套一层…后来被拉回正道。<br>核心思想不变，仍是“交换”。<br>但是交换的条件是<strong>将非零元素全部移到数组头部</strong>，虽然直观看来与题目所引导的“0全部移到末尾”完全反着来，但是我发现这样做比把0移到末尾再对非零元素进行某种交换排序要来的简单得多。题目作者居心叵测啊（不是</p>\n<h3 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    void swap(vector&lt;int&gt;&amp; nums,int i,int j)&#123;\n        int t;\n        t=nums[i];\n        nums[i]=nums[j];\n        nums[j]=t;\n        \n    &#125;\n    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;\n        int i=0; \n        for(int j=0;j&lt;nums.size();j++)&#123;\n            if(nums[j]!=0)&#123;\n                swap(nums,i,j);\n                i++;\n            &#125;\n        &#125;\n\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><h1 id=\"子串\"><a href=\"#子串\" class=\"headerlink\" title=\"子串\"></a>子串</h1><h1 id=\"普通数组\"><a href=\"#普通数组\" class=\"headerlink\" title=\"普通数组\"></a>普通数组</h1><h1 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h1><h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.反转链表</h2><p>又是一道经典中的经典题🙀</p>\n<blockquote>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点的数目范围是 [0, 5000]</li>\n<li>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>👉️ <em><strong>链表反转的本质</strong></em></p>\n<ul>\n<li>让当前节点<code>cur</code>指向它的前一个节点<code>pre</code>。而不是后一个节点next</li>\n<li>更新<code>pre</code>和<code>cur</code>，直到cur为空。此时pre为新的head节点</li>\n</ul>\n<p>这里模拟一下过程。<br>👉️ <em><strong>假设存在链表：1-&gt;2-&gt;3-&gt;4-&gt;nullptr</strong></em><br>初始状态：</p>\n<ul>\n<li>pre &#x3D; nullptr</li>\n<li>cur &#x3D; head<br>那么逐步变化如下：</li>\n</ul>\n<p>| <code>cur</code> | <code>tmp(cur-&gt;next)</code> | <code>cur-&gt;next=pre</code> | <code>pre=cur</code> | <code>cur=tmpS</code> |<br>| :–: | :–: | :–: |<br>| 1 | 2 | <code>1-&gt;nullptr</code> | <code>pre=1</code> | <code>cur=2</code> |<br>| 2 | 3 | <code>2-&gt;1</code> | <code>pre=2</code> | <code>cur=3</code> |<br>| 3 | 4 | <code>3-&gt;2</code> | <code>pre=3</code> | <code>cur=4</code> |<br>| 4 | nullptr | <code>4-&gt;3</code> | <code>pre=4</code> | <code>cur=nullptr</code>（结束） |</p>\n<p>最终pre变成4，即新的链表头头。<br><strong>此时链表结构为：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; nullptr</strong>。</p>\n<p>👉️ <em><strong>简单来说，关键步骤是</strong></em><br>1️⃣记录下一个节点<br>2️⃣反转指向<br>3️⃣更新pre（当前节点变成新的头）<br>4️⃣继续遍历</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* pre=nullptr;\n        ListNode* cur=head;\n        while(cur!=nullptr)&#123;\n            ListNode* tmp=cur-&gt;next;\n            cur-&gt;next=pre;\n            pre=cur;\n            cur=tmp;\n        &#125;\n        return pre;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21.合并两个有序链表\"></a>21.合并两个有序链表</h2><blockquote>\n<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>提示：</p>\n<ul>\n<li>两个链表的节点数目范围是 [0, 50]</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>l1和l2均按非递减顺序排列</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>👉️ <em><strong>终止条件</strong></em>：有链表为空</p>\n<ul>\n<li>list1为空，合并结果直接为list2</li>\n<li>list2为空，合并结果直接为list1</li>\n</ul>\n<p>👉️ <em><strong>递归调用</strong></em>：小的打头，每一步递归后返回的值链接到链表末尾</p>\n<ul>\n<li>如果<code>list1节点的值 &lt; list2</code>：寻找list1后面节点还有没有也比list2小的节点</li>\n</ul>\n<pre><code>让list1-&gt;next接上递归后合并的结果；\n返回当前较小的节点list1;\n</code></pre>\n<ul>\n<li>else：寻找list2后面节点还有没有也比list1小的节点</li>\n</ul>\n<pre><code>让list2-&gt;next接上递归后合并的结果；\n返回当前较小的节点list2;\n</code></pre>\n<h3 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        if(list1==NULL || list2==NULL)&#123;\n            return list1==NULL ? list2:list1;\n        &#125;\n        if(list1-&gt;val &lt; list2-&gt;val)&#123;\n            list1-&gt;next = mergeTwoLists(list1-&gt;next,list2);\n            return list1;\n        &#125;\n        else&#123;\n            list2-&gt;next = mergeTwoLists(list1,list2-&gt;next);\n            return list2;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加\"></a>2.两数相加</h2><blockquote>\n<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>每个链表中的节点数在范围 [1, 100] 内</li>\n<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这道题着实难倒我🥹乖乖去看<a href=\"https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/\">题解</a></p>\n<ol>\n<li><p>链表<strong>逆序</strong>存储数字</p>\n</li>\n<li><p><code>两个链表的节点值 + 进位值</code>如果记为<code>a</code>：</p>\n</li>\n</ol>\n<ul>\n<li><code>a % 10</code>为当前节点保存的数位</li>\n<li><code>a / 10</code>为新的进位值</li>\n</ul>\n<ol start=\"3\">\n<li>递归思路</li>\n</ol>\n<ul>\n<li>如果l1、l2都为空且carry&#x3D;0，递归结束</li>\n<li>定义sum&#x3D;carry</li>\n<li>如果l1不为空，sum+&#x3D;l1-&gt;val，l1&#x3D;l1-&gt;next</li>\n<li>同理，如果l2不为空，sum+&#x3D;l2-&gt;val，l2&#x3D;l2-&gt;next</li>\n<li>new一个当前节点node：<code>ListNode* node=new ListNode(sum%10)</code></li>\n<li>递归调用处理node-&gt;next</li>\n<li>返回当前节点node</li>\n</ul>\n<h3 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2,int carry=0) &#123;\n        if(l1==nullptr &amp;&amp; l2==nullptr &amp;&amp; carry==0)&#123;\n            return nullptr;\n        &#125;\n        int sum=carry;\n        if(l1!=nullptr)&#123;\n            sum+=l1-&gt;val;\n            l1=l1-&gt;next;\n        &#125;\n        if(l2!=nullptr)&#123;\n            sum+=l2-&gt;val;\n            l2=l2-&gt;next;\n        &#125;\n        ListNode* node=new ListNode(sum%10);\n        carry=sum/10;\n        node-&gt;next=addTwoNumbers(l1,l2,carry);\n        return node;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h1 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h1><h1 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h1><h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><h2 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35.搜索插入位置\"></a>35.搜索插入位置</h2><blockquote>\n<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br><strong>请必须使用时间复杂度为<code>O(logn)</code>的算法。</strong></p>\n</blockquote>\n<h3 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>我一开始用的暴力穷举，如下。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        while(nums.size()!=1)&#123;\n            if(target&lt;nums[0])&#123;\n                return 0;\n            &#125;\n            for(int i=0;i&lt;nums.size()-1;i++)&#123;\n                if(nums[i]==target)&#123;\n                    return i;\n                &#125;\n                else if(nums[i]&lt;target &amp;&amp; nums[i+1]&gt;=target)&#123;\n                    return i+1;\n                &#125;\n            &#125;\n            return nums.size();\n        &#125;\n        return (target&lt;=nums[0])? 0:1;\n    &#125;\n&#125;;\n</code></pre>\n<p>然后提交之后意识到不符合题意，于是再来换个思路：<strong>二分查找</strong><br>我前几天刚记的二分查找笔记 今天竟然没意识到这道题有多直白地明示我要用!!!∑(ﾟДﾟノ)ノ</p>\n<blockquote>\n<p><strong>二分查找</strong>：在有序集合中搜索特定值。</p>\n</blockquote>\n<p><strong>使用术语</strong>：</p>\n<ul>\n<li>目标 <code>target</code></li>\n<li>索引 <code>index</code></li>\n<li>左、右指示符 <code>left</code>、<code>right</code></li>\n<li>中间指示符 <code>mid</code></li>\n</ul>\n<p><strong>计算 <code>mid</code> 位置</strong>：<br>如果 <code>nums[mid] == target</code>，直接返回索引。<br>如果 <code>nums[mid] &lt; target</code>，说明 target 应该在右半部分，所以left向右移动（left &#x3D; mid + 1）。<br>如果 <code>nums[mid] &gt; target</code>，说明 target 应该在左半部分，所以right向左移动（ right &#x3D; mid - 1）。</p>\n<p>循环结束后，left 就是 target 应该插入的位置。</p>\n<h3 id=\"AC代码-1\"><a href=\"#AC代码-1\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p>二分查找最基础的方法。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int left,right;\n        left=0;\n        right=nums.size()-1;\n        while(left&lt;=right)&#123;\n            int mid=left+(right-left)/2;\n            if(nums[mid]==target)&#123;\n                return mid;\n            &#125;\n            else if(nums[mid]&lt;target)&#123;\n                left=mid+1;\n            &#125;\n            else&#123;\n                right=mid-1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20.有效的括号\"></a>20.有效的括号</h2><blockquote>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>\n</blockquote>\n<blockquote>\n<p>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>\n</blockquote>\n<h3 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>定义栈的括号匹配规则；() [] &#123;&#125;\n\n初始化一个栈;\n当遇到左括号时：\n    左括号压栈；\n当遇到右括号时:\n    如果（栈空）:\n        ×；\n    否则：\n        char 栈顶元素；\n        弹出栈顶元素；\n        如果栈顶元素与当前右括号不匹配：\n            ×；\n字符串遍历完后：\n    如果（栈空）：\n        √；\n</code></pre>\n<ul>\n<li>这里的for循环可以直接用for(char ch:s)，表示<strong>对于字符串<code>s</code>中的每一个字符<code>ch</code>,执行循环内容</strong>。</li>\n</ul>\n<h3 id=\"AC代码-2\"><a href=\"#AC代码-2\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        unordered_map&lt;char,char&gt;pairs=&#123;&#123;')','('&#125;,&#123;']','['&#125;,&#123;'&#125;','&#123;'&#125;&#125;;\n        stack&lt;char&gt;stk;\n        for(char ch:s)&#123;\n            if(ch==&#39;(&#39; || ch==&#39;[&#39; || ch==&#39;&#123;&#39;)&#123;\n                stk.push(ch);\n            &#125;\n            else&#123;\n                if(stk.empty())&#123;\n                    return false;\n                &#125;\n                char top=stk.top();\n                stk.pop();\n                if(pairs[ch]!=top)&#123;\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        if(stk.empty())&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"70-爬楼梯\"><a href=\"#70-爬楼梯\" class=\"headerlink\" title=\"70.爬楼梯\"></a>70.爬楼梯</h2><blockquote>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n</blockquote>\n<h3 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>试图暴力然后失败。然后查看题解：竟然是<strong>动态规划</strong>~</p>\n<p>重点理解部分：</p>\n<ul>\n<li><strong>逆向思维</strong>：如果要到第<code>n</code>个台阶，就必须从第<code>n-1</code>阶走1步，或者从第<code>n-2</code>阶走2步。</li>\n<li>dp[n]&#x3D;dp[n-1]+dp[n-2]</li>\n</ul>\n<p><em><strong>为什么这样递推？</strong></em><br>动态规划的核心是<strong>拆分子问题,然后找到递推关系</strong>。本质根据题目限制条件，建立递推关系，然后用代码实现。<br>👉 因为你每次只能走 1 级或 2 级，所以你到 n 级的方式只能来自 n-1 和 n-2，而不能来自 n-3、n-4 等。</p>\n<pre><code>//先处理边界情况\n如果n&lt;=2：返回n；\n//动规\n定义a=1,b=2；（对应能上的楼梯阶数）和当前阶梯的方案数量temp;\n遍历n（从3开始）：\n    temp=a+b； //dp[i]=dp[i-2]+dp[i-1]\n    a=b;      //a=dp[i-1]\n    b=temp;   //b=dp[i];\n返回 b;\n</code></pre>\n<h3 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        if(n&lt;=2)&#123;\n            return n;\n        &#125;\n        int a=1,b=2,temp;\n        for(int i=3;i&lt;=n;i++)&#123;\n            temp=a+b;\n            a=b;\n            b=temp;\n        &#125;\n        return b;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198.打家劫舍\"></a>198.打家劫舍</h2><blockquote>\n<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>\n</blockquote>\n<h3 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><a href=\"https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/\">题解</a>写的特别详细！这里复述一下：</p>\n<p><strong>动态规划的四个解题步骤：</strong></p>\n<ul>\n<li>定义子问题</li>\n<li>写出子问题的递推关系</li>\n<li>确定dp数组的计算顺序</li>\n<li>（可选）空间优化<blockquote>\n<p>这里根据自己现有的水平仅梳理前三点。</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><p><strong>定义子问题</strong><br>原问题：“从全部房间偷到的最大金额”<code>→</code>子问题：“从前k个房间偷到的最大金额”</p>\n</li>\n<li><p>写出<strong>子问题的递推关系</strong><br>👉已知子问题f(k)，那么只关注当前（即第k个）房间，只有两种偷法：<br>偷k &amp;&amp; 偷k-2<code>or</code>不偷k &amp;&amp; 偷k-1间</p>\n</li>\n</ol>\n<p>👉可得递推关系：<code>f(k)=max&#123;f(k-1),k-1房间的钱+f(k-2)&#125;</code>。这里的f(k)也叫做状态，式子也叫做状态转移方程。</p>\n<p>同时别忘了边界情况：无房子（k&#x3D;0）和只有一个房子(k&#x3D;1)。</p>\n<ol start=\"3\">\n<li>确定<strong>dp数组的计算顺序</strong><br>👉dp数组（子问题数组，）：dp[k]&#x3D;偷前k间房子的最大金额。</li>\n</ol>\n<p>👉大多动规问题使用<code>自底向上</code>的dp数组循环方法。</p>\n<p>✅️由子问题的计算顺序可得：dp[k]依赖于dp[k-1]和dp[k-2]。那么就可以开写力</p>\n<h3 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n=nums.size();\n        if(n==0)&#123;\n            return 0;\n        &#125;\n        vector&lt;int&gt; dp(n+1,0);\n        dp[1]=nums[0];\n        for(int i=2;i&lt;=n;i++)&#123;\n            dp[i]=max(dp[i-1],nums[i-1]+dp[i-2]);\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416.分割等和子集\"></a>416.分割等和子集</h2><blockquote>\n<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-8\"><a href=\"#解题思路-8\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这里涉及「恰好装满」的0-1背包问题，教程<a href=\"https://www.bilibili.com/video/BV16Y411v7Y6/?vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h3 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum=accumulate(nums.begin(),nums.end(),0);\n        if(sum%2!=0)&#123;\n            return false;\n        &#125;\n        int target=sum/2;\n        vector&lt;bool&gt; dp(target+1,false);\n        dp[0]=true;//存在和为i=0的子集\n        for(int num:nums)&#123;\n            for(int i=target;i&gt;=num;i--)&#123;\n                dp[i]=dp[i] || dp[i-num];\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"多维动态规划\"><a href=\"#多维动态规划\" class=\"headerlink\" title=\"多维动态规划\"></a>多维动态规划</h1><h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1>",
            "tags": [
                "记录",
                "力扣",
                "算法"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/15/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/",
            "url": "https://232akira.github.io/2025/03/15/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/",
            "title": "游戏开发笔记",
            "date_published": "2025-03-15T14:22:22.000Z",
            "content_html": "<p>👌当下主要学习<strong>图形</strong>方向，具体细节可以查看<a href=\"https://docs.unity3d.com/cn/current/Manual/Graphics.html\">Unity官方文档</a>。</p>\n<pre><code>渲染管线\n摄像机\n光照\n模型\n网格\n纹理\n着色器\n材质\nVisual effects\n天空\n颜色\n图形API\nGraphics performance and profiling\n</code></pre>\n<blockquote>\n<p>虽然自己程序方面更擅长C++而且现在用UE也是个趋势，但是Unity普及度更高而且教程更多，UE蓝图也摒弃了传统的纯程序开发路线，所以打好这方面基础是现在最需要做的。如果有任何建议和想法需要交流欢迎联系我！不断试错不断学习中🤗</p>\n</blockquote>\n<p>笔记内容90%来自视频原话，其他内容个人补充，欢迎勘误。<br>学习内容大多来自b站佬们的教程（先三连之后看的！）🤟参考链接点击标题跳转</p>\n<h1 id=\"项目实战-Uinty\"><a href=\"#项目实战-Uinty\" class=\"headerlink\" title=\"项目实战-Uinty\"></a>项目实战-Uinty</h1><h2 id=\"Shader代码基础\"><a href=\"#Shader代码基础\" class=\"headerlink\" title=\"Shader代码基础\"></a><a href=\"https://www.bilibili.com/video/BV1Xu4y1S7LF/?spm_id_from=333.1387.favlist.content.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">Shader代码基础</a></h2><h3 id=\"PART1\"><a href=\"#PART1\" class=\"headerlink\" title=\"PART1\"></a>PART1</h3><h4 id=\"Shader代码基本架构\"><a href=\"#Shader代码基本架构\" class=\"headerlink\" title=\"Shader代码基本架构\"></a>Shader代码基本架构</h4><pre><code class=\"language-c#\">Shader&quot;1️⃣&quot;\n&#123;\n    Properties\n    &#123;\n    2️⃣\n    &#125;\n    SubShader\n    &#123;\n    ️3️⃣\n        Pass\n        &#123;\n        4️⃣\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>1️⃣Shader名称</strong></p>\n<p><strong>2️⃣定义变量位置</strong><br>常见的五种变量类型:</p>\n<ul>\n<li>Float</li>\n<li>Range</li>\n<li>Vector</li>\n<li>Color</li>\n<li>Texture</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        //常用的五种数据类型\n        _Float(&quot;Float&quot;,Float)=0.0\n        _Range(&quot;Range&quot;,Range(0.0,1.0))=0.0\n        _Vector(&quot;Vector&quot;,Vector)=(1,1,1,1)\n        _Color(&quot;Color&quot;,Color)=(0.5,0.5,0.5,0.5)\n        _Texture(&quot;Texture&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n</code></pre>\n<p><strong>3️⃣主要Shader代码部分</strong><br>可以理解成一个Pass等于一个完整的GPU渲染管线，SubShader里可以写多个Pass，写几个代表会被重复渲染几次，而且每次调用的Shader都不一样。</p>\n<pre><code class=\"language-c#\">            CGPROGRAM\n            //中间的任何代码都属于unity cg的范围\n            ENDCG\n</code></pre>\n<ol>\n<li>这里对于<code>float</code>类型<a href=\"https://docs.unity3d.com/cn/current/Manual/SL-VertexProgramInputs.html\">补充</a>一点：</li>\n</ol>\n<ul>\n<li>‌<code>float‌</code>：用于表示单个浮点数，常用于颜色通道、位置坐标等。</li>\n<li>‌<code>float2‌</code>（Vector2）：用于表示二维向量，如二维坐标、UV坐标等。</li>\n<li>‌<code>float3‌</code>（Vector3）：用于表示三维向量，如位置、法线等。</li>\n<li>‌<code>float4‌</code>（Vector4）：用于表示四维向量，如颜色、四元数等。</li>\n</ul>\n<ol start=\"2\">\n<li><p>在unity中，一个模型最多有四套UV</p>\n</li>\n<li><p>float&#x2F;half&#x2F;fixed的区别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">位宽</th>\n<th align=\"center\">适用范围</th>\n<th align=\"center\">常见用途</th>\n<th align=\"center\">精度</th>\n<th align=\"center\">现代GPU支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32-bit</td>\n<td align=\"center\">大</td>\n<td align=\"center\">位置、物理计算、PBR</td>\n<td align=\"center\">高</td>\n<td align=\"center\">强烈推荐</td>\n</tr>\n<tr>\n<td align=\"center\">half</td>\n<td align=\"center\">16-bit</td>\n<td align=\"center\">中</td>\n<td align=\"center\">颜色计算、法线、屏幕后处理</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">推荐（移动端优化）</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">10-bit</td>\n<td align=\"center\">小</td>\n<td align=\"center\">颜色计算（老设备）</td>\n<td align=\"center\">低</td>\n<td align=\"center\">几乎淘汰</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"GPU渲染管线\"><a href=\"#GPU渲染管线\" class=\"headerlink\" title=\"GPU渲染管线\"></a>GPU渲染管线</h4><p><strong>基本结构</strong>：</p>\n<pre><code>【模型数据】 -&gt; 1️⃣【顶点Shader】 -&gt; 2️⃣【图元装配及光栅化】 -&gt; 3️⃣【片元Shader】 -&gt; 4️⃣【输出合并】\n            |-----------------------------GPU渲染管线---------------------------------------|\n</code></pre>\n<p><strong>1️⃣顶点Shader</strong>：</p>\n<ul>\n<li>将模型数据的模型空间坐标转换到对应的裁剪空间，即输出在裁剪空间下的顶点坐标</li>\n<li>【模型空间】 -&gt; 世界空间 -&gt; 相机空间 -&gt; 【裁剪空间】，中间经过三个矩阵（Model,View,Projection）操作</li>\n</ul>\n<p><strong>2️⃣图元装配及光栅化</strong></p>\n<ul>\n<li>硬件阶段</li>\n<li>生成片元并进行光栅化插值</li>\n</ul>\n<p><strong>3️⃣片元Shader</strong></p>\n<ul>\n<li>每个片元调用片元shader给自身着色</li>\n<li>计算对应的颜色后输出</li>\n</ul>\n<p><strong>4️⃣输出合并</strong></p>\n<ul>\n<li>输出到对应的帧缓冲区</li>\n</ul>\n<p><em><strong>一个完整的Shader通常由顶点Shader和片段Shader共同组成。</strong></em></p>\n<h4 id=\"完整Shader代码\"><a href=\"#完整Shader代码\" class=\"headerlink\" title=\"完整Shader代码\"></a>完整Shader代码</h4><pre><code class=\"language-c#\">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;\n// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;\nShader &quot;CS0102/shader&quot;\n&#123;\n    Properties\n    &#123;\n        // 常用的五种数据类型\n        _Float(&quot;Float&quot;, Float) = 0.0\n        _Range(&quot;Range&quot;, Range(0.0, 1.0)) = 0.0\n        _Vector(&quot;Vector&quot;, Vector) = (1,1,1,1)\n        _Color(&quot;Color&quot;, Color) = (0.5,0.5,0.5,0.5)\n        //_Texture(&quot;Texture&quot;, 2D) = &quot;black&quot; &#123;&#125; \n        _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            // Shader 主要代码部分\n            CGPROGRAM\n            #pragma vertex vert // 指定一个顶点 Shader：vert\n            #pragma fragment frag // 指定一个片元 Shader：frag\n            #include &quot;UnityCG.cginc&quot; // 头文件\n\n            // 从 CPU 端获取模型数据\n            struct appdata &#123;\n                float4 vertex : POSITION;  // 模型顶点坐标\n                // 第一套uv，共4个可用（TEXCOORD0~TEXCOORD3）\n                float2 uv : TEXCOORD0; \n                float3 normal : NORMAL;    // 法线\n                float4 color : COLOR;      // 顶点色\n            &#125;;\n            // 输出结构体定义\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                //通用储存器（插值器），共16个可用（TEXCOORD0~TEXCOORD15）\n                float2 uv:TEXCOORD0;\n            &#125;;\n            float4 _Color;\n            sampler2D _MainTex;\n            float4 _MainTex_ST;//动态链接四个参数\n            // 顶点 Shader\n            v2f vert(appdata v) &#123;\n                v2f o;\n                //float4 pos_world = mul(unity_ObjectToWorld, v.vertex); // 模型空间转世界空间\n                //float4 pos_clip = mul(UNITY_MATRIX_VP, pos_world); // 世界空间直接变换到裁剪空间\n                //o.pos = pos_clip;\n                //或者直接合成一个mvp操作\n                o.pos=UnityObjectToClipPos(v.vertex);\n                //输出uv值\n                //o.uv=v.uv;\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            // 片元 Shader\n            float4 frag(v2f i) : SV_Target &#123;\n                //贴图采样\n                float4 col=tex2D(_MainTex,i.uv);\n                return col;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"PART2\"><a href=\"#PART2\" class=\"headerlink\" title=\"PART2\"></a>PART2</h3><h4 id=\"背面剔除（Backface-Culling）\"><a href=\"#背面剔除（Backface-Culling）\" class=\"headerlink\" title=\"背面剔除（Backface Culling）\"></a>背面剔除（Backface Culling）</h4><p>背面剔除在硬件阶段、NDC空间之后进行，Unity默认使用背面剔除（只渲染正面）。</p>\n<ol>\n<li>Shader代码控制:直接显示出渲染结果</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull Off  //1️⃣不剔除\n            Cull Back //2️⃣默认剔除背面\n            Cull Front//3️⃣剔除正面\n            //注意在CGPROGRAM之前\n            CGPROGRAM\n            ...\n            ENDCG\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>材质球控制：物体材质球处出现可选项：Off&#x2F;Front&#x2F;Back</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull [_CullMode]\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"PART3-纹理映射\"><a href=\"#PART3-纹理映射\" class=\"headerlink\" title=\"PART3 纹理映射\"></a>PART3 纹理映射</h3><h4 id=\"正面纹理采样设定\"><a href=\"#正面纹理采样设定\" class=\"headerlink\" title=\"正面纹理采样设定\"></a>正面纹理采样设定</h4><p>这里用XY坐标值采样贴图，即uv按模型本身的XY展开。<br>代码如下：</p>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                ...\n                float2 pos_uv:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                ...\n                o.pos_uv=v.vertex.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.pos_uv);\n                return col;\n            &#125;\n</code></pre>\n<p>👉️补充：</p>\n<ul>\n<li>正面 XY平面</li>\n<li>侧面 ZY平面</li>\n<li>俯视 XZ平面</li>\n</ul>\n<p>总结：纹理映射的来源不一定是单纯的o.uv的uv坐标，也可以是上面写的o.pos_uv（世界坐标pos_world也可）这种自己设定的值。</p>\n<p>另，如果想三平面都能够完美覆盖涉及到：<strong>三平面映射</strong>。up在此链接中有提到，所以查了其他教程补充在这里。</p>\n<h4 id=\"三平面映射\"><a href=\"#三平面映射\" class=\"headerlink\" title=\"三平面映射\"></a><a href=\"https://www.bilibili.com/opus/814269127492370548\">三平面映射</a></h4><ol>\n<li>**目的：**防止”纹理拉伸”</li>\n</ol>\n<p>防止纹理拉伸传统思路可以手动展开uv坐标以贴合模型起伏，但是难以适应实时渲染的要求，因此引入这一方法：三平面映射。</p>\n<ol start=\"2\">\n<li><p>**应用：**普通网格地形、瀑布、程序化建模的地形、水池的焦散效果</p>\n</li>\n<li><p><strong>实现步骤</strong></p>\n</li>\n</ol>\n<ul>\n<li>根据顶点的世界空间坐标计算对应的UV坐标</li>\n</ul>\n<pre><code class=\"language-c#\">//取每个片元在三个方向的uv坐标\nhalf2 yUV=IN.worldPos.xz/_TextureScale;\nhalf2 xUV=IN.worldPos.yz/_TextureScale;\nhalf2 zUV=IN.worldPos.xy/_TextureScale;\n</code></pre>\n<ul>\n<li>从x&#x2F;y&#x2F;z三个方向对漫反射贴图进行采样</li>\n</ul>\n<pre><code class=\"language-c#\">half3 yDiff=tex2D(_DiffuseMap,yUV);\nhalf3 xDiff=tex2D(_DiffuseMap,xUV);\nhalf3 zDiff=tex2D(_DiffuseMap,zUV);\n</code></pre>\n<ul>\n<li>调整三平面边界过渡的锐利度</li>\n</ul>\n<pre><code class=\"language-c#\">//用法线方向作为从三个方向采样的权重值\n//额外解决纹理接缝问题（法线是连续过渡的）\nhalf3 blendWeights=pow(abs(In.worldNormal),_TriplanarBlendSharpness);\n</code></pre>\n<ul>\n<li>将混合权重值单位化</li>\n</ul>\n<pre><code class=\"language-c#\">//第三步pow锐化三平面边界后，得到的法线值可能偏小\n//重新单位化\nblendWeights=blendWeights/(blendWeights.x+blendWeights.y+blendWeights.z);\n</code></pre>\n<ul>\n<li>按三个面的混合权重，将采样颜色混合在一起</li>\n</ul>\n<pre><code class=\"language-c#\">//根据混合系数混合\np.Albedo=xDiff*blendWeights.x+yDiff*blendWeights.y+zDiff*blendWeights.z;\n</code></pre>\n<p>更多相关内容<a href=\"https://www.bilibili.com/video/BV1AM4y1Y78D/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h4 id=\"渲染扭曲问题\"><a href=\"#渲染扭曲问题\" class=\"headerlink\" title=\"渲染扭曲问题\"></a>渲染扭曲问题</h4><p>打印uv坐标：</p>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.uv);\n                return float4(i.uv,0.0,0.0);\n            &#125;\n</code></pre>\n<p>若uv存在不连续的情况，则会导致贴图采样时引起纹理图像的失真问题。</p>\n<p><strong>👉️为什么会有uv不连续的现象？</strong><br>光栅化过程产生。光栅化时根据三角面的进行，每个三角按照每个三角面进行一个插值。而对于模型而言，其三角网排列就会造成一定程度上的问题。<br>解决方式：</p>\n<ul>\n<li>uv展开并缩放到0~1之间</li>\n<li>模型加面</li>\n<li>手动在片元shader中重新计算uv</li>\n</ul>\n<h3 id=\"PART4-透明度测试-Alpha-test\"><a href=\"#PART4-透明度测试-Alpha-test\" class=\"headerlink\" title=\"PART4 透明度测试 Alpha-test\"></a>PART4 透明度测试 Alpha-test</h3><p>参考链接<a href=\"https://docs.unity3d.com/cn/2020.2/Manual/SL-AlphaTest.html\">1️⃣</a><a href=\"https://blog.csdn.net/qq_34697930/article/details/136530909\">2️⃣</a></p>\n<h4 id=\"输出合并\"><a href=\"#输出合并\" class=\"headerlink\" title=\"输出合并\"></a>输出合并</h4><p>对于<strong>输出合并</strong>阶段，可以细分为：</p>\n<pre><code>【片元数据】Color,Depth\n    ↓\n【Alpha测试】\n    ↓\n【模板测试】Stencil Test\n    ↓\n【深度测试】Depth test\n    ↓\n【混合】Blending\n    ↓\n【帧缓冲区】Color,Depth,Stencil\n</code></pre>\n<h4 id=\"Alpha-test\"><a href=\"#Alpha-test\" class=\"headerlink\" title=\"Alpha-test\"></a>Alpha-test</h4><p>**Alpha 测试是拒绝将像素写入屏幕的最后机会。**在计算出最终输出颜色之后，颜色可选择性地将其 Alpha 值与固定值进行比较。如果测试失败，则不会将像素写入显示屏。</p>\n<p>当下在Shader中，很少会直接用alpha test这个指令。一般用的是更好用、更可控的指令：<code>clip</code>“裁剪”。</p>\n<p>如果clip()括号中的值&lt;0，整个模型将不显示。</p>\n<ol>\n<li>模型的一部分被裁剪掉</li>\n</ol>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 gradient=tex2D(_MainTex,i.uv);\n                clip(gradient-0.1);\n                return gradient.xxx;\n            &#125;\n</code></pre>\n<ol start=\"2\">\n<li>设置一个值实现动态控制<br>好神奇😂我这里模型用的球，Cutout调到0.5变成吃豆人了</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n         _Cutout(&quot;Cutout&quot;,Range(-0.1,1.1))=0.0\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv).r;\n                clip(gradient-_Cutout);\n                return gradient.xxxx;\n                //gradient.xxxx等价于float4(gradient,gradient,gradient,gradient);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>对UV进行动画处理</li>\n</ol>\n<pre><code class=\"language-c#\">                half gradient=tex2D(_MainTex,i.uv+_Time.y).r;\n</code></pre>\n<ol start=\"4\">\n<li>对UV进行动画速度的处理</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _Speed(&quot;Speed&quot;,Vector)=(1,1,0,0)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _Speed;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>noise贴图控制<br>适当的模型+贴图可以实现波形扩散效果</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _NoiseTex(&quot;Noise Tex&quot;,2D)=&quot;white&quot;&#123;&#125;\n         //_MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _NoiseTex_ST;\n            //float4 _MainColor;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n                half noise=tex2D(_NoiseTex,i.uv+_Time.y*_Speed.zw).r;\n                clip(gradient-noise-_Cutout);\n                return noise.xxxx;\n                //return _MainColor;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p><strong>综上</strong> alpha-test可以用来做溶解相关的效果。</p>\n<h3 id=\"PART5-半透明混合-Blending\"><a href=\"#PART5-半透明混合-Blending\" class=\"headerlink\" title=\"PART5 半透明混合 Blending\"></a>PART5 半透明混合 Blending</h3><p>参考链接<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/\">1️⃣</a><a href=\"https://blog.csdn.net/weixin_34505326/article/details/112181270\">2️⃣</a></p>\n<ol>\n<li>实现半透明混合</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;saturate\n    SubShader\n    &#123;\n        Blend SrcAlpha OneMinusSrcAlpha//注意此句在CGPROGRAM之前\n        float4 _MainColor;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half4 col=tex2D(_MainTex,i.uv)*_MainColor;\n                return col;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>关闭ZWrite深度写入<br>半透明混合的使用要注意排序问题：<code>ZWrite Off</code></li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>渲染队列问题<br>先前我们的材质球的Render Queue为2000，处于不透明的渲染队列中。使用半透明效果必须记得使用<code>Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</code>+关掉<code>ZWrite</code>（部分情况下ZWrite需要开启）</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"4\">\n<li>贴图半透效果</li>\n</ol>\n<ul>\n<li>当前贴图无alpha通道，所以只能用其灰度值来做一个半透效果。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz;\n                half alpha=tex2D(_MainTex,i.uv).r*_MainColor.a;\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<p>做出来的球像透明泡泡🤗好好看~</p>\n<ul>\n<li>增加显示强度<blockquote>\n<p>此处要确保alpha值在0~1的范围内，否则开HDR的时候就很容易出问题</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _Emiss(&quot;Emiss&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        float _Emiss;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz*_Emiss;\n\n                half alpha=saturate(tex2D(_MainTex,i.uv).r*_MainColor.a*_Emiss);\n                return float4(col,alpha);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>其他混合模式<br>常用的柔和叠加模式：<code>Blend SrcAlpha One</code></li>\n</ol>\n<h3 id=\"PART6-边缘光\"><a href=\"#PART6-边缘光\" class=\"headerlink\" title=\"PART6 边缘光\"></a>PART6 边缘光</h3><ol>\n<li>得到normal_world</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            struct appdata &#123;\n                float3 normal : NORMAL;\n            &#125;;\n            struct v2f &#123;\n                float3 normal_world:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos=UnityObjectToClipPos(v.vertex);\n                o.normal_world=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz);\n                //\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>得到view_world</li>\n</ol>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                float3 view_world:TEXCOORD2;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                float3 pos_world=mul(unity_ObjectToWorld,v.vertex).xyz;\n                o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);\n            &#125;\n</code></pre>\n<ol start=\"3\">\n<li>在片元Shader中把数据承接过来</li>\n</ol>\n<ul>\n<li><code>dot(a,b)</code>：a向量与b向量进行点乘。<br>两个向量越重合就越接近1；180°为-1。[-1,1]👉️dot结果在[-1,1]</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 normal_world=normalize(i.normal_world);\n                //光栅化的过程会导致向量的长度变化\n                float3 view_world=normalize(i.view_world);\n                float NdoV=saturate(dot(normal_world,view_world));\n                float rim=1.0-NdoV;\n                return NdoV.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"4\">\n<li>得到边缘光效果</li>\n</ol>\n<ul>\n<li>（来自弹幕佬的解释）边缘处的法线和视角方向接近垂直，dot&#x3D;0,1-dot进行取反，边缘就显示出颜色，其他部分就较为透明。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                ...\n                float rim=1.0-NdoV;\n                return rim.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"5\">\n<li>边缘光改色</li>\n</ol>\n<ul>\n<li>也可以用alpha通道调：<code>float alpha=saturate((1.0-NdoV)*_Emiss);</code></li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 col=_MainColor.xyz*_Emiss;//乘倍增系数，Inspector可调\n                ...\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<ol start=\"6\">\n<li>边缘光对比度调节</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _RimPower(&quot;_RimPower&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float _RimPower;\n            half4 frag(v2f i) : SV_Target &#123;\n               float NdoV=pow(saturate(dot(normal_world,view_world)),RimPower);\n               float fresnel=pow((1.0-NdoV),_RimPower);\n               float alpha=saturate(fresnel*_Emiss);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"7\">\n<li>模型透过问题：预先写深度<br>经过上面的步骤，模型能够看到内部的透过结构。如何避免这种现象？</li>\n</ol>\n<p>☝「打开ZWrite」<code>ZWrite On</code>。此时效果其实不算特别完美</p>\n<p>✌「再加一个&#96;Pass」预写一遍深度，代码如下：</p>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass\n        &#123;\n            Cull Of\n            ZWrite On\n            ColorMask 0\n            CGPROGRAM\n            float4 _Color;\n            #pragma vertex vert\n            #pragma fragment frag\n            float4 vert(float4 veryexPos:POSITION):SV_POSITION\n            &#123;\n                return UnityObjectToClipPos(vertexPos);\n            &#125;\n            float4 frag(void):COLOR\n            &#123;\n                return _Color;\n            &#125;\n            ENDCG\n        &#125;\n        Pass\n        &#123;\n            ...\n        &#125;\n    &#125;\n</code></pre>\n<ul>\n<li>把最靠前的三角形的片元的深度预先<code>ZWrite On</code>写好</li>\n<li><code>Color Mask</code>的操作：只写深度，不写任何的颜色信息</li>\n<li>到了第二遍pass绘制的时候，这些片元就通过深度测试，默认把背后的像素剔除</li>\n</ul>\n<p>👉️ASE中有对应的功能，此处仅为简单演示。</p>\n<p>🤯🤯🤯断断续续一个多星期终于把这一小时的视频啃完辣！！！休息休息继续战斗！</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"其他参考链接\"><a href=\"#其他参考链接\" class=\"headerlink\" title=\"其他参考链接\"></a>其他参考链接</h1><p>反射探针：<br><a href=\"https://zhuanlan.zhihu.com/p/438022045\">https://zhuanlan.zhihu.com/p/438022045</a><br>三大Shader编程语言：<br><a href=\"https://blog.csdn.net/weixin_56516170/article/details/135266277\">https://blog.csdn.net/weixin_56516170/article/details/135266277</a><br>《Shader入门精要》源代码:<br><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\">https://github.com/candycat1992/Unity_Shaders_Book</a><br>法线贴图：<br><a href=\"https://blog.csdn.net/weixin_49427945/article/details/136458398\">https://blog.csdn.net/weixin_49427945/article/details/136458398</a><br><a href=\"https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html\">https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html</a></p>\n",
            "tags": [
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/",
            "url": "https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/",
            "title": "力扣备忘录",
            "date_published": "2025-03-02T11:55:55.000Z",
            "content_html": "<h1 id=\"基础算法问题\"><a href=\"#基础算法问题\" class=\"headerlink\" title=\"基础算法问题\"></a>基础算法问题</h1><p>这些题听着老熟了，一到写起来就主打一个略有耳闻🫠</p>\n<h2 id=\"题目一览\"><a href=\"#题目一览\" class=\"headerlink\" title=\"题目一览\"></a>题目一览</h2><p>省流表👇️</p>\n<blockquote>\n<p>题目并非只有表中那几个，可在<a href=\"https://leetcode.cn/problemset/\">此页</a>自行筛选。</p>\n</blockquote>\n<h3 id=\"1️⃣数组与数学类\"><a href=\"#1️⃣数组与数学类\" class=\"headerlink\" title=\"1️⃣数组与数学类\"></a><strong>1️⃣数组与数学类</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体 &#x2F; 要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">杨辉三角</td>\n<td align=\"center\"><code>[118/119]</code></td>\n<td align=\"center\">一维数组</td>\n</tr>\n<tr>\n<td align=\"center\">斐波那契数列</td>\n<td align=\"center\"><code>[509]</code></td>\n<td align=\"center\">爬楼梯问题<code>[70]</code>&#x2F;递归&#x2F;迭代&#x2F;动态规划</td>\n</tr>\n<tr>\n<td align=\"center\">两数之和</td>\n<td align=\"center\"><code>[1]</code></td>\n<td align=\"center\">哈希表优化时间复杂度到O(n)</td>\n</tr>\n<tr>\n<td align=\"center\">合并两个有序数组</td>\n<td align=\"center\"><code>[88]</code></td>\n<td align=\"center\">原地合并（从后向前填充）</td>\n</tr>\n<tr>\n<td align=\"center\">最大子数组和</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">动态规划</td>\n</tr>\n</tbody></table>\n<h3 id=\"2️⃣字符串操作类\"><a href=\"#2️⃣字符串操作类\" class=\"headerlink\" title=\"2️⃣字符串操作类\"></a><strong>2️⃣字符串操作类</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">反转字符串</td>\n<td align=\"center\"><code>[344]</code></td>\n<td align=\"center\">原地修改（双指针）</td>\n</tr>\n<tr>\n<td align=\"center\">有效的括号</td>\n<td align=\"center\"><code>[20]</code></td>\n<td align=\"center\">用栈实现括号匹配</td>\n</tr>\n<tr>\n<td align=\"center\">最长公共前缀</td>\n<td align=\"center\"><code>[14]</code></td>\n<td align=\"center\">纵向扫描&#x2F;分治</td>\n</tr>\n<tr>\n<td align=\"center\">字符串转整数</td>\n<td align=\"center\"><code>[8]</code></td>\n<td align=\"center\">处理边界（溢出&#x2F;符号&#x2F;空格）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3️⃣链表类\"><a href=\"#3️⃣链表类\" class=\"headerlink\" title=\"3️⃣链表类\"></a><strong>3️⃣链表类</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">反转链表</td>\n<td align=\"center\"><code>[206]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">环形链表</td>\n<td align=\"center\"><code>[141]</code></td>\n<td align=\"center\">快慢指针判环</td>\n</tr>\n<tr>\n<td align=\"center\">合并两个有序链表</td>\n<td align=\"center\"><code>[21]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">删除链表倒数第N个节点</td>\n<td align=\"center\"><code>[19]</code></td>\n<td align=\"center\">一趟扫描</td>\n</tr>\n</tbody></table>\n<h3 id=\"4️⃣树与递归\"><a href=\"#4️⃣树与递归\" class=\"headerlink\" title=\"4️⃣树与递归\"></a><strong>4️⃣树与递归</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二叉树的最大深度</td>\n<td align=\"center\"><code>[104]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">对称二叉树</td>\n<td align=\"center\"><code>[101]</code></td>\n<td align=\"center\">迭代（队列&#x2F;栈）&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">路径总和</td>\n<td align=\"center\"><code>[112]</code></td>\n<td align=\"center\">动回溯法</td>\n</tr>\n</tbody></table>\n<h3 id=\"5️⃣动态规划\"><a href=\"#5️⃣动态规划\" class=\"headerlink\" title=\"5️⃣动态规划\"></a><strong>5️⃣动态规划</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">打家劫舍</td>\n<td align=\"center\"><code>[198]</code></td>\n<td align=\"center\">状态转移方程推导</td>\n</tr>\n<tr>\n<td align=\"center\">零钱兑换</td>\n<td align=\"center\"><code>[322]</code></td>\n<td align=\"center\">完全背包问题解法</td>\n</tr>\n<tr>\n<td align=\"center\">最长递增子序列</td>\n<td align=\"center\"><code>[300]</code></td>\n<td align=\"center\">O(nlogn)优化解法</td>\n</tr>\n</tbody></table>\n<h3 id=\"6️⃣排序与查找\"><a href=\"#6️⃣排序与查找\" class=\"headerlink\" title=\"6️⃣排序与查找\"></a><strong>6️⃣排序与查找</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\"><code>力扣排序题均可</code></td>\n<td align=\"center\">手写递归和非递归版本</td>\n</tr>\n<tr>\n<td align=\"center\">二分查找</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">处理边界条件（左闭右闭&#x2F;左闭右开）</td>\n</tr>\n<tr>\n<td align=\"center\">寻找峰值</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">二分法的特殊应用</td>\n</tr>\n</tbody></table>\n<h3 id=\"7️⃣其他高频\"><a href=\"#7️⃣其他高频\" class=\"headerlink\" title=\"7️⃣其他高频\"></a><strong>7️⃣其他高频</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">LRU缓存</td>\n<td align=\"center\"><code>[146]</code></td>\n<td align=\"center\">手写递归和非递归版本</td>\n</tr>\n<tr>\n<td align=\"center\">实现队列&#x2F;栈</td>\n<td align=\"center\"><code>[232/225]</code></td>\n<td align=\"center\">处理边界条件（左闭右闭&#x2F;左闭右开）</td>\n</tr>\n<tr>\n<td align=\"center\">汉明距离</td>\n<td align=\"center\"><code>[461]</code></td>\n<td align=\"center\">二分法的特殊应用</td>\n</tr>\n</tbody></table>\n<p>具体题目思路&amp;代码记录见各个专题🤗</p>\n<h1 id=\"简单题\"><a href=\"#简单题\" class=\"headerlink\" title=\"简单题\"></a>简单题</h1><h2 id=\"66-加一\"><a href=\"#66-加一\" class=\"headerlink\" title=\"66.加一\"></a>66.加一</h2><blockquote>\n<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>\n</blockquote>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>判断数组末尾是否有9：\n    无9：末尾数字+1;\n    有9：\n        是否全为9：\n            是全9：\n                构造长度=size+1的数组，首位=1，其余全置0;\n            非全9：\n                找到倒着数第一个不是9的元素,\n                该元素加1,\n                末尾所有的9置0;\n</code></pre>\n<h3 id=\"AC代码\"><a href=\"#AC代码\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code>class Solution &#123;\npublic:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;\n        int len=digits.size();\n        if(digits[len-1]!=9)&#123;\n            digits[len-1]+=1;\n        &#125;\n        else&#123;\n            int cnt=0;//记录9出现的次数，第一个非9元素的下标即为len-cnt-1\n            for(int i=len-1;i&gt;=0;i--)&#123;\n                if(digits[i]==9)&#123;\n                    cnt++;\n                &#125;\n                else&#123;\n                    break;\n                &#125;\n            &#125;\n            if(cnt==len)&#123;\n                digits.insert(digits.begin(),1);\n                for(int i=1;i&lt;len+1;i++)&#123;\n                    digits[i]=0;\n                &#125;\n            &#125;\n            else&#123;\n                int index=len-cnt-1;\n                digits[index]+=1;\n                for(int i=index+1;i&lt;len;i++)&#123;\n                    digits[i]=0;\n                &#125;\n            &#125;\n        &#125;\n        return digits;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"896-单调数列\"><a href=\"#896-单调数列\" class=\"headerlink\" title=\"896.单调数列\"></a>896.单调数列</h2><blockquote>\n<p>如果数组是单调递增或单调递减的，那么它是<strong>单调</strong>的。<br>如果对于所有 i &lt;&#x3D; j，nums[i] &lt;&#x3D; nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &lt;&#x3D; j，nums[i] &gt;&#x3D; nums[j]，那么数组 nums 是单调递减的。<br>当给定的数组 nums 是单调数组时返回 true，否则返回 false。</p>\n</blockquote>\n<h3 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>bool 递增变量=真，递减变量=真；\n遍历数组：\n    如果该元素+1 大于 该元素：\n        标记递减变量=假；\n    如果该元素+1 小于 该元素：\n        标记递增变量=假；\n如果递增or递减=真，返回真；\n</code></pre>\n<h3 id=\"AC代码-1\"><a href=\"#AC代码-1\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code>class Solution &#123;\npublic:\n    bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123;\n        bool increase=true,decrease=true;\n        for(int i=0;i&lt;nums.size()-1;i++)&#123;\n            if(nums[i+1] &gt; nums[i])&#123;\n                decrease=false;\n            &#125;\n            if(nums[i+1] &lt; nums[i])&#123;\n                increase=false;\n            &#125;\n        &#125;\n        return decrease || increase;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"896-罗马数字转整数\"><a href=\"#896-罗马数字转整数\" class=\"headerlink\" title=\"896.罗马数字转整数\"></a>896.罗马数字转整数</h2><blockquote>\n<p><strong>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</strong><br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</li>\n<li>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>①I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>②X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>③C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>给定一个罗马数字，将其转换成整数。</strong></p>\n</blockquote>\n<h3 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这题一开始我无从下手，直接跑去翻题解了。</p>\n<p><strong>C++ <a href=\"https://www.w3cschool.cn/cpp/cpp-fu8l2ppt.html\">map</a>用法</strong><br>想起来python的字典。同样cpp stl中的map提供的是一种键值对（key-value）容器，其中的数据成对出现。</p>\n<ul>\n<li>初始化：<code>map类型 &lt;数据类型1，数据类型2&gt; 容器名</code></li>\n</ul>\n<p>对于map类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键值对容器</th>\n<th align=\"center\">实现方式</th>\n<th align=\"center\">键值</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">是否有序</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unordered_map</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找键对应的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>map</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要有序键值对</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_set</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找元素是否存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>set</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要排序的集合</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_multimap</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">有重复键且不关心顺序</td>\n</tr>\n</tbody></table>\n<p><strong>对于本题</strong><br>引用评论区<a href=\"https://leetcode.cn/u/hust_wei/\">大佬</a>的解释：当前位置的元素比下个位置的元素小，就减去当前值，否则加上当前值。</p>\n<pre><code>定义键值对容器 &lt;字符，整型&gt; \n    分别对应罗马数字的字符和数值(注意字符变量加单引号);\n\nint 结果变量；\nint 罗马数字长度；\n遍历罗马数字：\n    如果元素 当前位置&lt;下一个位置：（注意使用值时加方括号[]）\n        结果变量-=值变量；\n    否则：\n        结果变量+=值变量；\n返回结果；\n</code></pre>\n<h3 id=\"AC代码-2\"><a href=\"#AC代码-2\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code>class Solution &#123;\npublic:\n    unordered_map&lt;char,int&gt;mymap=&#123;\n        &#123;&#39;I&#39;,1&#125;,\n        &#123;&#39;V&#39;,5&#125;,\n        &#123;&#39;X&#39;,10&#125;,\n        &#123;&#39;L&#39;,50&#125;,\n        &#123;&#39;C&#39;,100&#125;,\n        &#123;&#39;D&#39;,500&#125;,\n        &#123;&#39;M&#39;,1000&#125;,\n    &#125;;\n    int romanToInt(string s) &#123;\n        int ans=0;\n        int len=s.length();\n        for(int i=0;i&lt;len;i++)&#123;\n            if(mymap[s[i]]&lt;mymap[s[i+1]])&#123;\n                ans-=mymap[s[i]];\n            &#125;\n            else&#123;\n                ans+=mymap[s[i]];\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58.最后一个单词的长度\"></a>58.最后一个单词的长度</h2><blockquote>\n<p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。<br><strong>单词</strong>是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>\n</blockquote>\n<h3 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><strong>【方法一】</strong><br>我的思路是<strong>从后向前</strong>遍历字符串时：如果它的后一个是空格或空，自己不是空格，意味着句尾有空格，该下标是倒着数第一个不为空格的字母；如果前一个是空格或空，自己不是空格，代表这是词的开头，记录下标直接退出循环。最后长度就是二者相减。<br>但是这样写大多数样例不通过（悲</p>\n<p>（二编）卧槽我改对了！！！</p>\n<p><strong>【方法二】</strong><br>不对那就改呗：直接从字符串的尾部开始遍历，<strong>跳过所有尾部空格</strong>，直到遇到<strong>第一个非空格字符</strong>，并计算其长度。能够更好的处理边界情况。</p>\n<pre><code>int 长度=字符串长度;\nint i=长度-1;\nint 结果长度=0\n当i大于等于0并且s的第i个字符为空格时：\n    i--；（倒着循环遍历）\n*本题设定s不为空，若无此条件需在此判断：当i&lt;0时直接返回（s为空）\n当i大于等于0并且s的第i个字符不为空格时：\n    结果长度++；\n    i--；\n返回结果长度;\n</code></pre>\n<h3 id=\"AC代码-3\"><a href=\"#AC代码-3\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p><strong>【方法一】</strong></p>\n<pre><code>class Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        int len=s.length();\n        int m=0,n=0;\n        for(int i=len-1;i&gt;0;i--)&#123;\n            if(s[i]!=&#39; &#39; &amp;&amp; (s[i+1]==&#39; &#39; || s[i+1]==&#39;\\0&#39;))&#123;\n                m=i;\n            &#125;\n            if((s[i-1]==&#39; &#39; || s[i-1]==&#39;\\0&#39;) &amp;&amp; s[i]!=&#39; &#39;)&#123;\n                n=i;\n                break;\n            &#125;\n        &#125;\n        return m-n+1;\n    &#125;\n&#125;;\n</code></pre>\n<p><strong>【方法二】</strong></p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int lengthOfLastWord(string s) &#123;\n        int len=s.length();\n        int ans=0;\n        int i=len-1;\n        while(i&gt;=0 &amp;&amp; s[i]==&#39; &#39;)&#123;\n            i--;\n        &#125;\n        while(i&gt;=0 &amp;&amp; s[i]!=&#39; &#39;)&#123;\n            ans++;\n            i--;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9.回文数\"></a>9.回文数</h2><blockquote>\n<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。</p>\n</blockquote>\n<h3 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p><strong>关键点</strong></p>\n<ul>\n<li>回文数是正整数</li>\n<li>负数不是回文数</li>\n<li>一个数的最后一位是0且这个数不为0，不是回文数</li>\n</ul>\n<p>将数字的后半部分反转，用<code>反转数字</code>存储。最后的反转数字包含原始x的后半部分，x包含原始x的前半部分。<br>最后返回时：若<strong>原始x是偶数</strong>，那么对于回文数，<strong>x一定&#x3D;反转数字</strong>。若<strong>原始x是奇数</strong>，那么反转数字会比x多一位，这一位是反转数字的个位并且是原始x的中位数，不影响回文数判断。所以<strong>先去掉个位</strong>再与当前的x比较。</p>\n<pre><code>如果（x小于0，或者x的个位不等于0且x不等于0）：\n    不是回文数；\n定义反转数字=0；\n当（x &gt; 反转数字）：\n    反转数字=反转数字*10+x%10；\n    x/=10；\nx = 反转数字\n返回x = 反转数字 或者 x = 去掉个位的反转数字；\n</code></pre>\n<h3 id=\"AC代码-4\"><a href=\"#AC代码-4\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code>class Solution &#123;\npublic:\n    bool isPalindrome(int x) &#123;\n        if(x&lt;0 || (x%10==0 &amp;&amp; x!=0))&#123;\n            return false;\n        &#125;\n        int num=0;\n        while(x&gt;num)&#123;\n            num=num*10+x%10;\n            x/=10;\n        &#125;\n        return x==num || x==num/10;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"14-最长公共前缀\"><a href=\"#14-最长公共前缀\" class=\"headerlink\" title=\"14.最长公共前缀\"></a>14.最长公共前缀</h2><blockquote>\n<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>\n</blockquote>\n<h3 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>区区小简单，真是难倒我了。<br>这里总结力扣官方题解的纵向扫描方法。我一开始想的也是类似思路，奈何憋不出来代码。<br><strong>关键点</strong></p>\n<ul>\n<li>最长公共前缀的长度不可能超过任何一个字符串的长度</li>\n<li>数组strs的大小即为字符串的总个数</li>\n<li><strong>二维数组形式</strong>可以直接表示第i个字符的第j位</li>\n<li>如果 <strong><code>i</code>超出某个字符串的长度</strong>或**第<code>j</code>个字符串的第<code>i</code>个字符不等于<code>c</code>**时，直接返回当前的公共前缀。</li>\n<li>循环结束说明所有字符串的所有字符都匹配，那么第一个字符串本身就是最长公共前缀，返回第一个字符串<code>strs[0]</code>。</li>\n</ul>\n<pre><code>如果数组为空：\n    返回&quot;&quot;；\nint 长度变量=数组第一个字符串元素的长度；\nint 计数变量=数组大小；\n遍历i，从0到长度变量：\n    char 字符变量=第一个字符串的第i个字符；\n    遍历j，从1到计数变量：\n        如果（i==第j个字符串的大小 || 第j个字符串的第i个字符 ！= 字符变量）：\n            返回 第一个字符串的第一个字符~第i个字符；\n返回 第一个字符；\n</code></pre>\n<h3 id=\"AC代码-5\"><a href=\"#AC代码-5\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><pre><code>class Solution &#123;\npublic:\n    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;\n        if(!strs.size())&#123;\n            return &quot;&quot;;\n        &#125;\n        int len=strs[0].size();\n        int cnt=strs.size();\n        for(int i=0;i&lt;len;i++)&#123;\n            char c=strs[0][i];\n            for(int j=1;j&lt;cnt;j++)&#123;\n                if(i==strs[j].size() || strs[j][i]!=c)&#123;\n                    return strs[0].substr(0,i);\n                &#125;\n            &#125;\n        &#125;\n        return strs[0];\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"682-棒球比赛\"><a href=\"#682-棒球比赛\" class=\"headerlink\" title=\"682.棒球比赛\"></a>682.棒球比赛</h2><blockquote>\n<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>\n</blockquote>\n<blockquote>\n<p>比赛开始时，记录是空白的。你会得到一个记录操作的<strong>字符串列表</strong> ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p>\n<ul>\n<li>整数 x - 表示本回合新获得分数 x</li>\n<li>“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>\n<li>“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n<li>“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。<br>请你返回记录中所有得分的总和。</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>用int动态数组ans记录得分，但是不用i做索引来查询，而是用begin、end、size、back等方法来防止发生越界访问。</p>\n<ul>\n<li>注意<code>string</code>类型为字符串，用双引号””括起来，<code>char</code>类型为字符，用单引号’’。</li>\n</ul>\n<pre><code>前两次得分之和：size-1 +size-2\n前一次得分：back\n最近一次得分移除-&gt;出栈-&gt;pop_back\n加入得分：压栈-&gt;push_back\n字符串转整型：stoi\n计算动态数组的和：accumulate\n</code></pre>\n<p>另外，我一开始想用<code>unordered_map</code>，做题做迷了。后来发现动态数组完全可以解决：C++ 标准库中的 vector 支持动态调整大小，可以方便地模拟栈的行为。而unordered_map 是用来存储键值对（key-value pairs）的哈希表。<br>本问题中不需要映射关系，所以并不需要用到 unordered_map。<br>还有，<strong>stack<int><strong>的<code>.push()</code>和<code>.pop()</code>也可，但是</strong>vector</strong>的<code>.push_back()</code>和<code>.pop_back()</code>也同样可以。那就选更常用的vector，何乐而不为呢？</p>\n<h3 id=\"AC代码-6\"><a href=\"#AC代码-6\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p>用时击败7%，悲。之后滚回来优化算法。</p>\n<pre><code>class Solution &#123;\npublic:\n    int calPoints(vector&lt;string&gt;&amp; operations) &#123;\n        vector&lt;int&gt;ans;\n        for(string ch:operations)&#123;\n            if(ch==&quot;+&quot;)&#123;\n                ans.push_back(ans[ans.size()-1]+ans[ans.size()-2]);\n            &#125;\n            else if(ch==&quot;D&quot;)&#123;\n                ans.push_back(ans.back()*2);\n            &#125;\n            else if(ch==&quot;C&quot;)&#123;\n                ans.pop_back();\n            &#125;\n            else&#123;\n                ans.push_back(stoi(ch));\n            &#125;\n        &#125;\n        return accumulate(ans.begin(),ans.end(),0);\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"26-删除有序数组中的重复项\"><a href=\"#26-删除有序数组中的重复项\" class=\"headerlink\" title=\"26.删除有序数组中的重复项\"></a>26.删除有序数组中的重复项</h2><blockquote>\n<p>给你一个非严格递增排列的数组nums,请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回nums中唯一元素的个数。</p>\n</blockquote>\n<blockquote>\n<p>考虑nums的唯一元素的数量为k，你需要做以下事情确保你的题解可以被通过：</p>\n<ul>\n<li>更改数组nums，使nums的前k个元素包含唯一元素，并按照它们最初在nums中出现的顺序排列。nums的其余元素与nums的大小不重要。</li>\n<li>返回 k 。</li>\n</ul>\n</blockquote>\n<h3 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><pre><code>int 最终数组长度=1;\n遍历nums：\n    如果第i个元素不等于第i-1个元素：\n        nums[最终数组长度]=nums[i]；\n        最终数组长度++；\n返回最终数组长度；\n</code></pre>\n<h3 id=\"AC代码-7\"><a href=\"#AC代码-7\" class=\"headerlink\" title=\"AC代码\"></a>AC代码</h3><p>妈呀这题一提交发现每ms都有解法…密密麻麻(ΩДΩ)</p>\n<pre><code>class Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int ans=1;\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            if(nums[i]!=nums[i-1])&#123;\n                nums[ans]=nums[i];\n                ans++;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<hr>\n",
            "tags": [
                "记录",
                "力扣",
                "算法"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/",
            "url": "https://232akira.github.io/2025/02/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8D%8A%E5%B9%B4%E7%9A%84%E7%97%9B/",
            "title": "博客搭建小半年的痛",
            "date_published": "2025-02-20T02:26:39.000Z",
            "content_html": "<p><strong>主打一个备忘</strong><br>断断续续从24年中搞到现在25年初，最磨蹭的一集。</p>\n<blockquote>\n<p><strong>最新问题</strong></p>\n<blockquote>\n<p>提交评论 ×<br>替换部分主题图片 ×<br>文章总访问量显示 ×</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"首先是参考链接\"><a href=\"#首先是参考链接\" class=\"headerlink\" title=\"首先是参考链接\"></a>首先是参考链接</h2><p>非常感谢！</p>\n<h3 id=\"ShokaX\"><a href=\"#ShokaX\" class=\"headerlink\" title=\"ShokaX\"></a>ShokaX</h3><p>github：<a href=\"https://github.com/theme-shoka-x/hexo-theme-shokaX\">https://github.com/theme-shoka-x/hexo-theme-shokaX</a><br>官方文档：<a href=\"https://hexo.docs.shokax.top/\">https://hexo.docs.shokax.top/</a><br>主题指南：<a href=\"https://docs.kaitaku.xyz/\">https://docs.kaitaku.xyz/</a><br>社区资源：<a href=\"https://github.com/theme-shoka-x/awesome-shokaX\">https://github.com/theme-shoka-x/awesome-shokaX</a><br>shoka：<a href=\"https://github.com/amehime/hexo-theme-shoka\">https://github.com/amehime/hexo-theme-shoka</a></p>\n<h3 id=\"其他相关网站-教程\"><a href=\"#其他相关网站-教程\" class=\"headerlink\" title=\"其他相关网站&amp;教程\"></a>其他相关网站&amp;教程</h3><p>Linn’s Shoka：<a href=\"https://linn-ylz.com/Hexo/blog-content-test/\">https://linn-ylz.com/Hexo/blog-content-test/</a><br>waline快速上手：<a href=\"https://waline.js.org/guide/get-started/\">https://waline.js.org/guide/get-started/</a><br>Vercel服务端部署：<a href=\"https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example&teamSlug=232akiras-projects\">https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample&amp;teamSlug=232akiras-projects</a><br>leancloud：<a href=\"https://console.leancloud.app/apps\">https://console.leancloud.app/apps</a><br>Gimhoy图床：<a href=\"https://pic.gimhoy.com/\">https://pic.gimhoy.com/</a><br>Google字体：<a href=\"https://fonts.google.com/\">https://fonts.google.com/</a><br>百度统计：<a href=\"https://tongji.baidu.com/main/setting/10000672027/home/site/index\">https://tongji.baidu.com/main/setting/10000672027/home/site/index</a><br>markdown排版：<a href=\"https://markdown.com.cn/editor/\">https://markdown.com.cn/editor/</a></p>\n<h2 id=\"搭建思路\"><a href=\"#搭建思路\" class=\"headerlink\" title=\"搭建思路\"></a>搭建思路</h2><p>这方面毫无实战知识，不停地踩坑踩坑…</p>\n<h3 id=\"Hexo初始化博客\"><a href=\"#Hexo初始化博客\" class=\"headerlink\" title=\"Hexo初始化博客\"></a><a href=\"https://hexo.io/zh-cn/\" title=\"点此跳转Hexo官网\">Hexo</a>初始化博客</h3><p>基于Node.js的博客框架。本博客采用Hexo+Github搭建。<br><strong>常用命令</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">功能</th>\n<th align=\"center\">命令</th>\n<th align=\"center\">简写</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">清理缓存</td>\n<td align=\"center\">hexo clean</td>\n<td align=\"center\"><code>hexo cl</code></td>\n</tr>\n<tr>\n<td align=\"center\">部署站点</td>\n<td align=\"center\">hexo deploy</td>\n<td align=\"center\"><code>hexo d</code></td>\n</tr>\n<tr>\n<td align=\"center\">生成博客</td>\n<td align=\"center\">hexo generate</td>\n<td align=\"center\"><code>hexo g</code></td>\n</tr>\n<tr>\n<td align=\"center\">启动本地服务</td>\n<td align=\"center\">hexo server</td>\n<td align=\"center\"><code>hexo s</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"Shoka主题配置\"><a href=\"#Shoka主题配置\" class=\"headerlink\" title=\"Shoka主题配置\"></a>Shoka主题配置</h3><p>一开始胡乱配置，后来更新的时候爆出来好多问题。于是这两天从头重做</p>\n<h4 id=\"步骤如下：\"><a href=\"#步骤如下：\" class=\"headerlink\" title=\"步骤如下：\"></a>步骤如下：</h4><pre><code>前置hexo init、Node.js等\npnpm安装shokax\n/_config.landscape.yml重命名为_config.shokax.yml\n</code></pre>\n<h4 id=\"config-yml中的配置项：\"><a href=\"#config-yml中的配置项：\" class=\"headerlink\" title=\"&#x2F;_config.yml中的配置项：\"></a>&#x2F;_config.yml中的配置项：</h4><pre><code>markdown配置\n停用默认代码高亮\n文件压缩\nfeed生成\n站内搜索\n</code></pre>\n<h4 id=\"config-shokax-yml中的配置项：\"><a href=\"#config-shokax-yml中的配置项：\" class=\"headerlink\" title=\"&#x2F;_config.shokax.yml中的配置项：\"></a>&#x2F;_config.shokax.yml中的配置项：</h4><pre><code>静态资源存放目录\nShokaX功能模块\n主页头图\nIconfont图标\n导航栏\n侧边栏\n大标题\n社交链接\n字数和阅读时间统计\n预加载和预解析地址\nSEO优化和访客优化\n夜间模式\n自动定位\n标题自定义\n图片自定义\n首页精选\n分类翻转块\n实验性特性\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"/images/github_blog.jpg\" alt=\"2025&#x2F;3&#x2F;17\" title=\"Insights\"></p>\n<p>突然发现放简历上的的网站二维码扫出来404😇可能当初生成二维码时没事，链接是某个具体的文章路径，后来Hexo更新或者改了文章的permalink，导致原来的链接失效了。</p>\n<p>回到我的主页😼👇️</p>\n<ul>\n<li>site: K’s BLOG<br>url: <a href=\"https://232akira.github.io/\">https://232akira.github.io/</a><br>color: “#adff2f”</li>\n</ul>\n<p>（？渲染器没安装好…</p>\n",
            "tags": [
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2024/11/23/%E5%AD%98%E5%AD%98markdown%E7%9B%B8%E5%85%B3/",
            "url": "https://232akira.github.io/2024/11/23/%E5%AD%98%E5%AD%98markdown%E7%9B%B8%E5%85%B3/",
            "title": "存存markdown相关",
            "date_published": "2024-11-23T10:40:43.000Z",
            "content_html": "<h2 id=\"这是232akira的第一篇博客的二级标题两个井号加空格\"><a href=\"#这是232akira的第一篇博客的二级标题两个井号加空格\" class=\"headerlink\" title=\"这是232akira的第一篇博客的二级标题两个井号加空格\"></a>这是232akira的第一篇博客的二级标题两个井号加空格</h2><h3 id=\"这是232akira的第一篇博客的三级标题三个井号加空格\"><a href=\"#这是232akira的第一篇博客的三级标题三个井号加空格\" class=\"headerlink\" title=\"这是232akira的第一篇博客的三级标题三个井号加空格\"></a>这是232akira的第一篇博客的三级标题三个井号加空格</h3><p>这是232akira的第一篇博客的第一段直接回车</p>\n<p>这是232akira的第一篇博客的第二段</p>\n<p>这是换行尝试两个空格+回车<br><br><br>换行！</p>\n<p>这是字体加粗尝试加粗 <strong>前后各加2个星星号</strong></p>\n<p>这是字体斜体尝试斜体 <em>前后各加1个星星号</em></p>\n<p>这是字体同时加粗斜体尝试 <em><strong>前后各加3个星星号</strong></em></p>\n<p>这是创建块引用</p>\n<blockquote>\n<p>kuaiyinyongkuaiyinyongkkk<br>这是多个段落的块引用<br>kuaiyinyongkkk</p>\n<p>kkk</p>\n</blockquote>\n<p>这是嵌套块引用</p>\n<blockquote>\n<p>kuaiyinyongkkk</p>\n<blockquote>\n<p>qiantaoaaa</p>\n<ul>\n<li>用短横杠（注意两边空格）出来是圆点</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>这是有序列表<br>1.我是1第一项必须数字一加英文句号后面数字无所谓<br>2.我是2<br>    1.我是1<br>    2.我是2<br>3.我是3</p>\n<p>这是无序列表点乘加短横杠都可以变成圆点<br>-111<br>-222<br>    -1111嵌套前面四个空格<br>    -代码在列表里缩进8个空格或者2个tab<br>            print(“hello world~”)<br>-333</p>\n<p>这是代码语法<br>把代码包裹在反引号<code>中 比如我这里是 </code>代码代码代码<code>创建代码块就还是缩进4个空格or1个tab</code>        我是代码块啊啊啊&#96;</p>\n<h2 id=\"这是分隔线单独一行三星或多星-破折号-下划线\"><a href=\"#这是分隔线单独一行三星或多星-破折号-下划线\" class=\"headerlink\" title=\"这是分隔线单独一行三星或多星&#x2F;破折号&#x2F;下划线***\"></a>这是分隔线单独一行三星或多星&#x2F;破折号&#x2F;下划线<br>***</h2><hr>\n<p>出来的效果一样的</p>\n<p>这是链接链接的文本放中括号地址放后面圆括号<a href=\"https://www.xuexi.cn/\" title=\"我是title\">快来学习</a><br>或者直接尖括号链接跳转<a href=\"https://www.xuexi.cn/\">https://www.xuexi.cn/</a></p>\n<p>强调链接就在尖括号前后增加星号，表示为代码就加反引号<br>I love <strong><a href=\"https://www.xuexi.cn/\" title=\"我是title\">学习</a></strong></p>\n<p>这是引用型链接，两个方括号前一个写文本后一个指向其他位置的链接<br>[跳转跳转啊啊啊] <a href=\"https://www.xuexi.cn/\">1</a></p>\n<p>这是添加图像使用感叹号+方括号+圆括号。方括号里写替代文本，圆括号里写图片链接，也可以后接图片标题文本。跳转链接写在最外面并再套一层方括号。<br><img loading=\"lazy\" data-src=\"/images/kabi.jpg\" alt=\"这是图片\" title=\"我是title\"></p>\n",
            "tags": [
                "记录",
                "Markdown"
            ]
        }
    ]
}
<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://232akira.github.io</id>
    <title>Per aspera ad astra • Posts by &#34;c++&#34; tag</title>
    <link href="https://232akira.github.io" />
    <updated>2025-04-01T01:18:00.000Z</updated>
    <category term="力扣" />
    <category term="算法" />
    <category term="字符串" />
    <category term="滑动窗口" />
    <category term="链表" />
    <category term="专题" />
    <category term="C++" />
    <category term="数组" />
    <category term="哈希表" />
    <category term="二分查找" />
    <category term="指南" />
    <category term="记录" />
    <category term="实战" />
    <category term="Markdown" />
    <category term="笔记" />
    <entry>
        <id>https://232akira.github.io/2025/04/01/%E4%B8%93%E9%A2%983-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
        <title>专题3️⃣ 动态规划</title>
        <link rel="alternate" href="https://232akira.github.io/2025/04/01/%E4%B8%93%E9%A2%983-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
        <content type="html">&lt;p&gt;动规来力！！！&lt;/p&gt;
&lt;h1 id=&#34;2140-解决智力问题&#34;&gt;&lt;a href=&#34;#2140-解决智力问题&#34; class=&#34;headerlink&#34; title=&#34;2140.解决智力问题&#34;&gt;&lt;/a&gt;2140.解决智力问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] &amp;#x3D; [pointsi, brainpoweri] 。&lt;br&gt;这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。&lt;br&gt;比方说，给你 questions &amp;#x3D; [[3, 2], [4, 3], [4, 4], [2, 5]] ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。&lt;/li&gt;
&lt;li&gt;如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。&lt;br&gt;请你返回这场考试里你能获得的 最高分数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; questions.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;questions[i].length &amp;#x3D;&amp;#x3D; 2&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; pointsi, brainpoweri &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;解决我的智力问题（不是🤯&lt;/p&gt;
&lt;p&gt;看了&lt;a href=&#34;https://leetcode.cn/problems/solving-questions-with-brainpower/solutions/1213919/dao-xu-dp-by-endlesscheng-2qkc/?envType=daily-question&amp;envId=2025-04-01&#34;&gt;题解&lt;/a&gt;发现是打家劫舍的变体题，所以带着一块儿做了。&lt;/p&gt;
&lt;p&gt;👉相当于如果选了k，接下来有x个不能选：打家劫舍是x&amp;#x3D;1，本题x&amp;#x3D;questions[i][1]。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;子问题&lt;br&gt;原问题：“完成考试（即所有题都已解决or跳过）能获得的最大分数”&lt;code&gt;→&lt;/code&gt;子问题：“完成前k道题能获得的最大分数”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;递推关系&lt;br&gt;👉已知子问题f(k)，那么只关注当前（即第k道）题，只有两种做题方法：&lt;br&gt;做k &amp;amp;&amp;amp; 做k+x&lt;code&gt;or&lt;/code&gt;不做k &amp;amp;&amp;amp; 做k+1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;👉递推关系：&lt;code&gt;f(k)=max&amp;#123;f(k-1),k-1道题的分数+f(k-1+x)&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;边界：无题目（k&amp;#x3D;0）和只有一道题(k&amp;#x3D;1)&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;dp数组的计算顺序&lt;br&gt;✅️dp[k]依赖于dp[k-1]和dp[k-1+x]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不对。这题搞得我现在有点懵，这会正好感冒昏昏沉沉的😵‍💫等我二编…&lt;/p&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;53-最大子数组和&#34;&gt;&lt;a href=&#34;#53-最大子数组和&#34; class=&#34;headerlink&#34; title=&#34;53.最大子数组和&#34;&gt;&lt;/a&gt;53.最大子数组和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;br&gt;子数组是数组中的一个连续部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;-104 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 104&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;经典解法：Kadane算法&lt;/strong&gt;。核心思路是动态规划，通过遍历数组维护当前最大子数组和。整体思路如下：&lt;br&gt;1️⃣&lt;strong&gt;维护两个变量：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sum&lt;/code&gt;当前最大子数组和&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxsum&lt;/code&gt;全局最大子数组和&lt;br&gt;2️⃣&lt;strong&gt;遍历数组，每次决定是否扩展当前子数组&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;sum+nums[i] &amp;lt; nums[i]&lt;/code&gt; 从nums[i]重新开始（之前的子数组必定与最大和无关&lt;/li&gt;
&lt;li&gt;否则继续累加nums[i]&lt;br&gt;3️⃣&lt;strong&gt;每次更新&lt;code&gt;maxsum&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int sum=nums[0];
        int maxsum=nums[0];
        for(int i=1;i&amp;lt;nums.size();i++)&amp;#123;
            sum=max(nums[i],sum+nums[i]);
            maxsum=max(sum,maxsum);
        &amp;#125;
        return maxsum;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="力扣" />
        <category term="算法" />
        <category term="专题" />
        <category term="C++" />
        <updated>2025-04-01T01:18:00.000Z</updated>
    </entry>
    <entry>
        <id>https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
        <title>专题1️⃣ 滑动窗口</title>
        <link rel="alternate" href="https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
        <content type="html">&lt;p&gt;今天照例每日一题，然后麻溜的看题解，发现又是一道滑动窗口题。所以开个专题归类一下。&lt;/p&gt;
&lt;h1 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h1&gt;&lt;h2 id=&#34;基础算法精讲03-滑动窗口&#34;&gt;&lt;a href=&#34;#基础算法精讲03-滑动窗口&#34; class=&#34;headerlink&#34; title=&#34;基础算法精讲03-滑动窗口&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6cef69f555ee1eb889d44945f2a3a38b&#34;&gt;基础算法精讲03-滑动窗口&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;👉️双指针的应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;713-乘积小于K的子数组&#34;&gt;&lt;a href=&#34;#713-乘积小于K的子数组&#34; class=&#34;headerlink&#34; title=&#34;713.乘积小于K的子数组&#34;&gt;&lt;/a&gt;713.乘积小于K的子数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 3 * 104&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 106&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-无重复字符的最长子串&#34;&gt;&lt;a href=&#34;#3-无重复字符的最长子串&#34; class=&#34;headerlink&#34; title=&#34;3.无重复字符的最长子串&#34;&gt;&lt;/a&gt;3.无重复字符的最长子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; s.length &amp;lt;&amp;#x3D; 5 * 104&lt;/li&gt;
&lt;li&gt;s 由英文字母、数字、符号和空格组成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;209-长度最小的子数组&#34;&gt;&lt;a href=&#34;#209-长度最小的子数组&#34; class=&#34;headerlink&#34; title=&#34;209.长度最小的子数组&#34;&gt;&lt;/a&gt;209.长度最小的子数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个含有n个正整数的数组和一个正整数target。&lt;br&gt;找出该数组中满足其总和大于等于target的长度最小的子数组 [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; target &amp;lt;&amp;#x3D; 109&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 104&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;在数组字串问题中，经常会用到&lt;strong&gt;双指针&lt;/strong&gt;这一技巧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;暴力方法 时间复杂度&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;枚举右端点，收缩左端点 时间复杂度&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;拿到数组的长度n&lt;/li&gt;
&lt;li&gt;答案ans初始化为n+1或者更大&lt;/li&gt;
&lt;li&gt;总和sum初始化为0&lt;/li&gt;
&lt;li&gt;左端点left初始化为0&lt;/li&gt;
&lt;li&gt;right右端点for循环(0~n-1)：sum+&amp;#x3D;nums[right]&lt;/li&gt;
&lt;li&gt;for嵌套while(s-nums[left]):此时子数组的和减去左端点依旧&amp;gt;&amp;#x3D;target：sum-&amp;#x3D;nums[left];left+&amp;#x3D;1;(移掉左端点)&lt;/li&gt;
&lt;li&gt;如果sum&amp;gt;&amp;#x3D;target:更新答案最小值 ans&amp;#x3D;min(ans,right-left+1)&lt;/li&gt;
&lt;li&gt;返回ans（&amp;lt;&amp;#x3D;n返回ans，否则返回0）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：此题不需要判断left和right两者间的大小关系。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;因为当left&amp;#x3D;right时，s-nums[left]&amp;#x3D;0，一定比target小（target为正整数），不满足while条件。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在「2」的基础上，把ans的更新写到while里面&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;完整代码-2&#34;&gt;&lt;a href=&#34;#完整代码-2&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int minSubArrayLen(int target, vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int n,ans,sum,left;
        n=nums.size();
        ans=n+1;
        sum=left=0;
        for(int i=0;i&amp;lt;n;i++)&amp;#123;
            // sum+=nums[i];
            // while(sum-nums[left]&amp;gt;=target)&amp;#123;
            //     sum-=nums[left];
            //     left++;
            // &amp;#125;
            // if(sum&amp;gt;=target)&amp;#123;
            //     ans=min(ans,i-left+1);
            // &amp;#125;
            while(sum&amp;gt;=target)&amp;#123;
                ans=min(ans,i-left+1);
                sum-=nums[left++];
            &amp;#125;
        &amp;#125;
        return ans&amp;lt;=n?ans:0;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2269-找到一个数字的-K-美丽值&#34;&gt;&lt;a href=&#34;#2269-找到一个数字的-K-美丽值&#34; class=&#34;headerlink&#34; title=&#34;2269.找到一个数字的 K 美丽值&#34;&gt;&lt;/a&gt;2269.找到一个数字的 K 美丽值&lt;/h1&gt;&lt;p&gt;今天字符串也要美丽了🆘&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个整数num的k美丽值定义为num中符合以下条件的子字符串数目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子字符串长度为k。&lt;/li&gt;
&lt;li&gt;子字符串能整除num。&lt;br&gt;给你整数num和k，请你返回num的k美丽值。&lt;br&gt;注意：&lt;br&gt;允许有前缀0。&lt;br&gt;0不能整除任何值。&lt;br&gt;一个子字符串是一个字符串里的连续一段字符序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= num &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= num.length&lt;/code&gt; （将 num 视为字符串）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-3&#34;&gt;&lt;a href=&#34;#解题思路-3&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;我觉得这道的要点就是子串怎么得，剩下的就好判断了。偏偏我就栽在这儿了😅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;int转string&lt;/strong&gt; &lt;code&gt;to_string()&lt;/code&gt;注意此函数需要赋给个string变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;string转int&lt;/strong&gt; &lt;code&gt;stoi()&lt;/code&gt;同样，需要赋给个int变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取长度为k的字符串&lt;/strong&gt; &lt;code&gt;substr(i,k)&lt;/code&gt;距离c++学这个函数已经过了一两年了，忘的一干二净，趁此好机会来总结一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;获取子串&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;substr(pos,len)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;从pos开始，提取长度为len的子串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;查找字符串&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;find(str,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在pos之后查找str的位置，找不到返回string::pos&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;rfind(str,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;逆向查找str,从pos开始向前找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;find_first_of(chars,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;查找chars中的任意字符的第一次出现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;find_last_of(chars,pos)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;查找chars中的任意字符的最后一次出现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;替换字符串&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;replace(pos,len,str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;从pos开始，用str替换len个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;erase(pos,len)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;删除从pos开始的len个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;insert(pos,str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;在pos位置插入str&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;大小写转换&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;toupper(c)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;将字符c转换为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;tolower(c)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;将字符c转换为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;👇️ &lt;em&gt;&lt;strong&gt;数字与字符串转换&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;to_string(num)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把num转换为字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;stoi(str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把str转换为int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;stol(str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把str转换为long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;stod(str)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;把str转换为double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;完整代码-3&#34;&gt;&lt;a href=&#34;#完整代码-3&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int divisorSubstrings(int num, int k) &amp;#123;
        int cnt=0;
        string str=to_string(num);
        for(int i=0;i&amp;lt;=str.size()-k;i++)&amp;#123;
            string ans=str.substr(i,k);
            int answer=stoi(ans);
            if(answer!=0 &amp;amp;&amp;amp; num%answer==0)&amp;#123;
                cnt++;
            &amp;#125;
        &amp;#125;
        return cnt;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3305-元音辅音字符串计数Ⅰ&#34;&gt;&lt;a href=&#34;#3305-元音辅音字符串计数Ⅰ&#34; class=&#34;headerlink&#34; title=&#34;3305.元音辅音字符串计数Ⅰ&#34;&gt;&lt;/a&gt;3305.元音辅音字符串计数Ⅰ&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串word和一个非负整数 k。&lt;br&gt;返回word的子字符串中，每个元音字母（’a’、’e’、’i’、’o’、’u’）至少出现一次，并且恰好包含k个辅音字母的子字符串的总数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5 &amp;lt;&amp;#x3D; word.length &amp;lt;&amp;#x3D; 250&lt;/li&gt;
&lt;li&gt;word 仅由小写英文字母组成。&lt;/li&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; word.length - 5&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-4&#34;&gt;&lt;a href=&#34;#解题思路-4&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;先试了试暴力😤循环套三层观感太差，不放上来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正经解法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口代替暴力循环&lt;/li&gt;
&lt;li&gt;哈希表统计元音出现次数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意几个用法&lt;/strong&gt;&lt;br&gt;&lt;em&gt;&lt;strong&gt;1️⃣ 几个键值对容器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;键值对容器&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;实现方式&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;键值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是否有序&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找键对应的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键-值对&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要有序键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;unordered_set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;哈希表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;平均O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;快速查找元素是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;红黑树&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;键&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要排序的集合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2️⃣ 键值对容器+函数求的是什么？&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unordered_map.size()&lt;/code&gt;返回unordered_map中&lt;strong&gt;键值对的数量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unordered_set.count(x)&lt;/code&gt;unordered_set中&lt;strong&gt;某个元素是否存在&lt;/strong&gt;，返回1表示在，0表示不在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码思路如下。这个方法时间空间上并非最优，后续需要调整思路。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;定义n：word长度;
定义unordered_map类型的vowel_cnt:元音出现次数;
定义consonant_cnt:辅音个数;
定义ans：统计最终答案;
定义unordered_set类型的vowels:所有元音字母;
定义左指针j=0;
遍历word从下标0~word.size():
    定义右元素right=word[i];
    统计元音出现次数：
        进行元/辅音计数;
    当辅音数量超过k://收缩窗口左边界
        定义左元素left=word[左指针];//取左边界字符
        如果left是元音：
            该元音出现次数--;
            当元音的计数减少到0时：
                将它从vowel_cnt中删除；
        否则：
            辅音个数--;
        左指针右移;
    如果包含所有元音且辅音个数为k:
        //避免修改原窗口状态,思路整体与上半部分相同☝️
        定义临时变量temp_vowel=vowel_cnt;
        定义临时变量temp_consonant=consonant_cnt;
        定义临时变量temp_j=j;
        定义计数cnt=0;
        当临时左下标&amp;lt;=右下标:
            如果包含所有临时元音且临时辅音个数为k:
                cnt++;
            否则:
                退出该层循环;
            定义c:word[临时左指针];
            如果c是元音：
                临时该元音出现次数--;
                当临时元音的计数减少到0时：
                    将它从临时vowel_cnt中删除;
            否则:
                临时辅音个数--;
            临时左指针j右移;
        ans+=cnt;
返回ans;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码-4&#34;&gt;&lt;a href=&#34;#完整代码-4&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int countOfSubstrings(string word, int k) &amp;#123;
        int len=word.size();
        unordered_map&amp;lt;char,int&amp;gt;vowel_cnt;
        int consonant_cnt=0;
        int ans=0;
        unordered_set&amp;lt;int&amp;gt;vowels=&amp;#123;&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;i&amp;#39;,&amp;#39;o&amp;#39;,&amp;#39;u&amp;#39;&amp;#125;;
        int j=0;
        for(int i=0;i&amp;lt;len;i++)&amp;#123;
            char right=word[i];
            if(vowels.count(right))&amp;#123;
                vowel_cnt[right]++;
            &amp;#125;
            else&amp;#123;
                consonant_cnt++;
            &amp;#125;
            while(consonant_cnt&amp;gt;k)&amp;#123;
                char left=word[j];
                if(vowels.count(left))&amp;#123;
                    vowel_cnt[left]--;
                    if(vowel_cnt[left]==0)&amp;#123;
                        vowel_cnt.erase(left);
                    &amp;#125;
                &amp;#125;
                else&amp;#123;
                    consonant_cnt--;
                &amp;#125;
                j++;
            &amp;#125;
            if(vowel_cnt.size()==5 &amp;amp;&amp;amp; consonant_cnt==k)&amp;#123;
                unordered_map&amp;lt;char,int&amp;gt;temp_vowel=vowel_cnt;
                int temp_consonant=consonant_cnt;
                int temp_j=j;
                int cnt=0;
                while(temp_j&amp;lt;=i)&amp;#123;
                    if(temp_vowel.size()==5 &amp;amp;&amp;amp; temp_consonant==k)&amp;#123;
                        cnt++;
                    &amp;#125;
                    else&amp;#123;
                        break;
                    &amp;#125;
                    int c=word[temp_j];
                    if(vowels.count(c))&amp;#123;
                        temp_vowel[c]--;
                        if(temp_vowel[c]==0)&amp;#123;
                            temp_vowel.erase(c);
                        &amp;#125;
                    &amp;#125;
                    else&amp;#123;
                        temp_consonant--;
                    &amp;#125;
                    temp_j++;
                &amp;#125;
                ans+=cnt;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3306-元音辅音字符串计数Ⅱ&#34;&gt;&lt;a href=&#34;#3306-元音辅音字符串计数Ⅱ&#34; class=&#34;headerlink&#34; title=&#34;3306.元音辅音字符串计数Ⅱ&#34;&gt;&lt;/a&gt;3306.元音辅音字符串计数Ⅱ&lt;/h1&gt;&lt;p&gt;不行，彻底懵了脑子转不动做梦都是元辅音😫先把copy的官方题解放这，过两天我再苟回来看。&lt;/p&gt;
&lt;h2 id=&#34;解题思路-5&#34;&gt;&lt;a href=&#34;#解题思路-5&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h2 id=&#34;完整代码-5&#34;&gt;&lt;a href=&#34;#完整代码-5&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    long long countOfSubstrings(string word, int k) &amp;#123;
        set&amp;lt;char&amp;gt; vowels = &amp;#123;&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;&amp;#125;;
        auto count = [&amp;amp;](int m) -&amp;gt; long long &amp;#123;
            int n = word.size(), consonants = 0;
            long long res = 0;
            map&amp;lt;char, int&amp;gt; occur;
            for (int i = 0, j = 0; i &amp;lt; n; i++) &amp;#123;
                while (j &amp;lt; n &amp;amp;&amp;amp; (consonants &amp;lt; m || occur.size() &amp;lt; vowels.size())) &amp;#123;
                    if (vowels.count(word[j])) &amp;#123;
                        occur[word[j]]++;
                    &amp;#125; else &amp;#123;
                        consonants++;
                    &amp;#125;
                    j++;
                &amp;#125;
                if (consonants &amp;gt;= m &amp;amp;&amp;amp; occur.size() == vowels.size()) &amp;#123;
                    res += n - j + 1;
                &amp;#125;
                if (vowels.count(word[i])) &amp;#123;
                    occur[word[i]]--;
                    if (occur[word[i]] == 0) &amp;#123;
                        occur.erase(word[i]);
                    &amp;#125;
                &amp;#125; else &amp;#123;
                    consonants--;
                &amp;#125;
            &amp;#125;
            return res;
        &amp;#125;;
        return count(k) - count(k + 1);
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="力扣" />
        <category term="算法" />
        <category term="专题" />
        <category term="C++" />
        <updated>2025-03-12T10:20:15.000Z</updated>
    </entry>
    <entry>
        <id>https://232akira.github.io/2025/03/04/%E4%B8%93%E9%A2%982-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
        <title>专题2️⃣ 贪心算法</title>
        <link rel="alternate" href="https://232akira.github.io/2025/03/04/%E4%B8%93%E9%A2%982-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
        <content type="html">&lt;p&gt;力扣连着刷到了几个贪心，而且另一篇笔记字数要爆了，决定先按大类慢慢分一下。&lt;br&gt;🤟&lt;a href=&#34;https://zhuanlan.zhihu.com/p/180104885&#34;&gt;参考链接&lt;/a&gt;&lt;br&gt;规律特征就是更加注重当前的状态,通常用于组合优化问题。即每一次都做出&lt;strong&gt;当前&lt;/strong&gt;看起来&lt;strong&gt;最好的&lt;/strong&gt;选择。每次只需要考虑一个问题，并通常是自底向上求解。即&lt;strong&gt;局部最优→全局最优&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;455-分发饼干&#34;&gt;&lt;a href=&#34;#455-分发饼干&#34; class=&#34;headerlink&#34; title=&#34;455.分发饼干&#34;&gt;&lt;/a&gt;455.分发饼干&lt;/h1&gt;&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;h1 id=&#34;976-三角形的最大周长&#34;&gt;&lt;a href=&#34;#976-三角形的最大周长&#34; class=&#34;headerlink&#34; title=&#34;976.三角形的最大周长&#34;&gt;&lt;/a&gt;976.三角形的最大周长&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;3 &amp;lt;= nums.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 106&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;因为题目需要的是最大的三角形周长，所以不需要暴力列举所有的情况再一一对比，而是直接奔着“最大”这个目标求解就行:&lt;br&gt;三条边a,b,c（假设从小到大已排好），当a+b&amp;gt;c时满足三角形。&lt;strong&gt;如果不满足，必须换更大的a,b&lt;/strong&gt;。&lt;br&gt;贪心优化策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nums排序&lt;/li&gt;
&lt;li&gt;从最大的三个数开始 尝试是否满足&lt;/li&gt;
&lt;li&gt;若无法满足，往前找更小的a,b&lt;/li&gt;
&lt;li&gt;一旦找到符合条件的三边，直接返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int largestPerimeter(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        sort(nums.begin(),nums.end());
        for(int i=nums.size()-1;i&amp;gt;=2;i++)&amp;#123;
            if(nums[i-1]+nums[i-2]&amp;gt;nums[i])
        &amp;#125;
        return 0;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;860-柠檬水找零&#34;&gt;&lt;a href=&#34;#860-柠檬水找零&#34; class=&#34;headerlink&#34; title=&#34;860.柠檬水找零&#34;&gt;&lt;/a&gt;860.柠檬水找零&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;br&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;br&gt;注意，一开始你手头没有任何零钱。&lt;br&gt;给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= bills.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bills[i] 不是 5 就是 10 或是 20 &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;**找零时，尽量先用大额。**并且只记录5美元、10美元的数量（因为这题目的情况不可能找20块）那么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到5美元  直接收 &lt;/li&gt;
&lt;li&gt;收到10美元 &lt;code&gt;10-5=5&lt;/code&gt; 找5美元（如果有）&lt;/li&gt;
&lt;li&gt;收到20美元 &lt;strong&gt;贪心来了~&lt;/strong&gt;&lt;code&gt;20-5=15&lt;/code&gt;优先使用10+5找零，否则用5+5+5（如果有）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-2&#34;&gt;&lt;a href=&#34;#完整代码-2&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    bool lemonadeChange(vector&amp;lt;int&amp;gt;&amp;amp; bills) &amp;#123;
        int five=0,ten=0;
        for(int bill:bills)&amp;#123;
            if(bill==5)&amp;#123;
                five++;
            &amp;#125;
            else if(bill==10)&amp;#123;
                if(five!=0)&amp;#123;
                    five--;
                    ten++;
                &amp;#125;
                else&amp;#123;
                    return false;
                &amp;#125;
            &amp;#125;
            else if(bill==20)&amp;#123;
                if(ten&amp;gt;0 &amp;amp;&amp;amp; five&amp;gt;0)&amp;#123;
                    ten--;
                    five--;
                &amp;#125;
                else if(five&amp;gt;=3)&amp;#123;
                    five-=3;
                &amp;#125;
                else&amp;#123;
                    return false;
                &amp;#125;
                
            &amp;#125;
        &amp;#125;
        return true;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2680-最大或值&#34;&gt;&lt;a href=&#34;#2680-最大或值&#34; class=&#34;headerlink&#34; title=&#34;2680.最大或值&#34;&gt;&lt;/a&gt;2680.最大或值&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 k 。每一次操作中，你可以选择一个数并将它乘 2 。&lt;br&gt;你最多可以进行 k 次操作，请你返回 nums[0] | nums[1] | … | nums[n - 1] 的最大值。&lt;br&gt;a | b 表示两个整数 a 和 b 的 按位或 运算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 109&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; k &amp;lt;&amp;#x3D; 15&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-3&#34;&gt;&lt;a href=&#34;#解题思路-3&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;做了这么几道中等题，发现很多难就难在变量大的时候怎么才能不超时的问题上😂&lt;/p&gt;
&lt;p&gt;因此要注意：&lt;br&gt;&lt;em&gt;&lt;strong&gt;👉️按位或（|）的特性&lt;/strong&gt;&lt;/em&gt;（二进制数）某一位只要有一个是1，按位或的结果该位就是1。&lt;br&gt;题目需要按位或的最大值，那么也就意味着尽量让高位变成1。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;👉️不能直接暴力枚举&lt;/strong&gt;&lt;/em&gt;否则会超时。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;🔍️按位运算总结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;运算&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;运算符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;按位与&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;两位都是1，结果才是1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;5 &amp;amp; 3 = 1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;按位或&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;一竖杠&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;只要有一个是1，结果就是1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;5 或 3 = 7&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;按位异或&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;相同为0，不同为1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;5 ^ 3 = 6&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;按位取反&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0变1，1变0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;~5 = -6&lt;/code&gt;（补码）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;左移&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;乘2^k&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;5 &amp;lt;&amp;lt; 1 = 10&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;右移&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;除2^k&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;5 &amp;gt;&amp;gt; 1 = 2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;解决方案：&lt;br&gt;&lt;strong&gt;1️⃣预计算最初的或值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;orsum|=num&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2️⃣按位或最大化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历nums，对每个num[i]进行优化&lt;/li&gt;
&lt;li&gt;假设nums[i]被选中，*2^k，计算新的或值&lt;/li&gt;
&lt;li&gt;对于已经选定的nums[i]，&lt;code&gt;0~i-1&lt;/code&gt;的或值设为&lt;code&gt;leftor&lt;/code&gt;;&lt;code&gt;i+1~n-1&lt;/code&gt;的或值设为&lt;code&gt;rightor&lt;/code&gt;。那么新的或值只需要让&lt;code&gt;leftor | nums[i]*2^k | rightor&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;nums[i]*2^k用&lt;code&gt;nums[i] * (1LL &amp;lt;&amp;lt; k)&lt;/code&gt;。表示位运算中的左移操作，让nums[i]的二进制向左移动k位右侧补零，等价于&lt;code&gt;*2^k&lt;/code&gt;（这里可以自己试一试：&lt;code&gt;5&amp;lt;&amp;lt;3&lt;/code&gt;等价于&lt;code&gt;40=5*8&lt;/code&gt;。）；LL防止溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;🆗其他问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么 &lt;code&gt;left[i+1] = left[i] | nums[i]&lt;/code&gt;，&lt;code&gt;right[i] = right[i+1] | nums[i]&lt;/code&gt;？&lt;br&gt;按位或计算有个特点：计算或值具有单调性，也就是a|b|c的结果一定不会比a|b小。&lt;br&gt;&lt;code&gt;left[i]&lt;/code&gt;存的是nums[0]~nums[1]的或值，又因为left[i+1]相比left[i]需要加入nums[i]进行或值运算，所以&lt;code&gt;left[i+1] = left[i] | nums[i]&lt;/code&gt;；&lt;code&gt;right[i]&lt;/code&gt;同理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-3&#34;&gt;&lt;a href=&#34;#完整代码-3&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    long long maximumOr(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) &amp;#123;
        int n=nums.size();
        vector&amp;lt;long long&amp;gt; left(n+1,0),right(n+1,0);
        for(int i=0;i&amp;lt;n;i++)&amp;#123;
            left[i+1]=left[i]|nums[i];
        &amp;#125;
        for(int i=n-1;i&amp;gt;=0;i--)&amp;#123;
            right[i]=right[i+1]|nums[i];
        &amp;#125;
        long long maxor=0;
        for(int i=0;i&amp;lt;n;i++)&amp;#123;
            long long newor;
            newor=left[i]|(nums[i]*(1LL&amp;lt;&amp;lt;k))|right[i+1];
            maxor=max(maxor,newor);
        &amp;#125;
        return maxor;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2829-k-avoiding数组的最小总和&#34;&gt;&lt;a href=&#34;#2829-k-avoiding数组的最小总和&#34; class=&#34;headerlink&#34; title=&#34;2829.k-avoiding数组的最小总和&#34;&gt;&lt;/a&gt;2829.k-avoiding数组的最小总和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你两个整数 n 和 k 。&lt;br&gt;对于一个由 不同 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 k-avoiding 数组。&lt;br&gt;返回长度为 n 的 k-avoiding 数组的可能的最小总和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; n, k &amp;lt;&amp;#x3D; 50&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-4&#34;&gt;&lt;a href=&#34;#解题思路-4&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数组总和最小&lt;/strong&gt;&lt;br&gt;从&lt;code&gt;1&lt;/code&gt;开始逐步添加符合条件的数字，直到数组长度达到&lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免和为k&lt;/strong&gt;&lt;br&gt;尝试加入&lt;code&gt;x&lt;/code&gt;时，确保数组中不存在&lt;code&gt;k-x&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;完整代码-4&#34;&gt;&lt;a href=&#34;#完整代码-4&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int minimumSum(int n, int k) &amp;#123;
        vector&amp;lt;int&amp;gt; ans;
        unordered_set&amp;lt;int&amp;gt; used;
        int num=1;
        while(ans.size()&amp;lt;n)&amp;#123;
            if(used.find(k-num)==used.end())&amp;#123;
                ans.push_back(num);
                used.insert(num);
            &amp;#125;
            num++;
        &amp;#125;
        return accumulate(ans.begin(),ans.end(),0);
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2712-使所有字符相等的最小成本&#34;&gt;&lt;a href=&#34;#2712-使所有字符相等的最小成本&#34; class=&#34;headerlink&#34; title=&#34;2712.使所有字符相等的最小成本&#34;&gt;&lt;/a&gt;2712.使所有字符相等的最小成本&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从 0 开始、长度为 n 的二进制字符串 s ，你可以对其执行两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。&lt;/li&gt;
&lt;li&gt;选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。&lt;br&gt;返回使字符串内所有字符 相等 需要的 最小成本 。&lt;br&gt;反转字符意味着：如果原来的值是 ‘0’ ，则反转后值变为 ‘1’ ，反之亦然。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; s.length &amp;#x3D;&amp;#x3D; n &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;s[i] 为 ‘0’ 或 ‘1’&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-5&#34;&gt;&lt;a href=&#34;#解题思路-5&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;所有字符相等&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;全&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;对于&lt;code&gt;i&lt;/code&gt;，反转的成本&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;反转前缀&lt;code&gt;[0,i]&lt;/code&gt;，成本&lt;code&gt;i+1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;反转后缀&lt;code&gt;[i,n-1]&lt;/code&gt;，成本&lt;code&gt;n-i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;核心问题&lt;/strong&gt;&lt;br&gt;对每个i，求出 min（s全1）和min（s全0），再对二者求min。&lt;br&gt;说人话就是：从0开始遍历，如果&lt;code&gt;s[i] ≠ s[i+1]&lt;/code&gt;，那么我们此时有两种选择：反转前缀[0,i] 或 反转后缀[i,n-1]。对于每一个这样需要反转的i，我们选择反转前缀还是后缀的原则就是&lt;strong&gt;哪个成本小选哪个&lt;/strong&gt;。最后得到的总成本也必然最小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;👉️难理解的部分：&lt;code&gt;min(i,n-i)&lt;/code&gt; 或 &lt;code&gt;min(i+1,n-i-1)&lt;/code&gt;。&lt;br&gt;个人理解是因为对于此算法，实际上的分界点在s[i]和s[i+1]之间。也就是说：修正分界点需要做的是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反转0~i&lt;/li&gt;
&lt;li&gt;反转i+1~n-1&lt;br&gt;这样求得的min才能保证达到我们“最小成本”的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👉️这里学到一个小知识：s.size()返回的类型为&lt;strong&gt;无符号整数（unsigned int）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_t&lt;/code&gt;无符号整型 (unsigned)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;是C++标准库中专门用于表示数组、容器的大小或索引的类型&lt;/li&gt;
&lt;li&gt;不能表示负数&lt;/li&gt;
&lt;li&gt;在 64 位系统上，size_t通常是unsigned long，比int更大，可表示更大的范围。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;有符号整型 (signed)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;是C++默认的整数类型，可以存储正数、负数和 0。&lt;/li&gt;
&lt;li&gt;取值范围一般是 [-2³¹, 2³¹ - 1]（32位系统） 或 [-2⁶³, 2⁶³ - 1]（64位系统）&lt;br&gt;&lt;em&gt;&lt;strong&gt;更适合存储一般的计数、索引、数学运算，而size_t主要用于数组大小和内存管理。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;完整代码-5&#34;&gt;&lt;a href=&#34;#完整代码-5&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    long long minimumCost(string s) &amp;#123;
        long long int sum=0;
        int n=s.size();
        for(int i=0;i&amp;lt;n-1;i++)&amp;#123;
            if(s[i]!=s[i+1])&amp;#123;
                sum+=min(i+1,n-i-1);
            &amp;#125;
        &amp;#125;
        return sum;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-盛最多水的容器&#34;&gt;&lt;a href=&#34;#11-盛最多水的容器&#34; class=&#34;headerlink&#34; title=&#34;11.盛最多水的容器&#34;&gt;&lt;/a&gt;11.盛最多水的容器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。&lt;br&gt;找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;br&gt;返回容器可以储存的最大水量。&lt;br&gt;说明：你不能倾斜容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n &amp;#x3D;&amp;#x3D; height.length&lt;/li&gt;
&lt;li&gt;2 &amp;lt;&amp;#x3D; n &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; height[i] &amp;lt;&amp;#x3D; 104&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-6&#34;&gt;&lt;a href=&#34;#解题思路-6&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;莫名想起接雨水（？😅一眼做不出来，上&lt;a href=&#34;https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/&#34;&gt;题解&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哪里贪心？&lt;br&gt; &lt;a href=&#34;https://leetcode.cn/u/teaven/&#34;&gt;评论&lt;/a&gt;佬的解释：永远找最高和最远的柱子，局部最优推出全局最优。双指针的解法存在遗漏，但对全局最优解无影响。&lt;/li&gt;
&lt;li&gt;双指针的解法本质：缩减搜索空间。&lt;/li&gt;
&lt;li&gt;排除i&amp;#x2F;j的配对可能性：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;i和j相遇算法结束；&lt;/li&gt;
&lt;li&gt;对于两边指针i、j，如果移动其中一边，那么新的容器h一定 不大于 另一边的柱子高度；&lt;/li&gt;
&lt;li&gt;收缩过程中，配对的h较低一方的柱子必定被舍弃所有可能，该位置指针向中间收缩。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-6&#34;&gt;&lt;a href=&#34;#完整代码-6&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;p&gt;单看代码理解应该也没问题，这道题知道思路后写起来是无压力的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) &amp;#123;
        int left,right;
        left=0;
        right=height.size()-1;
        int ans=0;
        while(left&amp;lt;right)&amp;#123;
            int h=height[left]&amp;lt;height[right]?height[left]:height[right];
            ans=max(ans,(right-left)*h);
            if(height[left]&amp;lt;height[right])&amp;#123;
                left++;
            &amp;#125;
            else&amp;#123;
                right--;
            &amp;#125;           
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="力扣" />
        <category term="算法" />
        <category term="专题" />
        <category term="C++" />
        <updated>2025-03-04T05:41:46.000Z</updated>
    </entry>
</feed>

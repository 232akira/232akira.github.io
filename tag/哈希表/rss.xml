<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Per aspera ad astra • Posts by &#34;哈希表&#34; tag</title>
        <link>https://232akira.github.io</link>
        <description>欢迎交流学习!</description>
        <language>zh-CN</language>
        <pubDate>Tue, 04 Mar 2025 19:15:05 +0800</pubDate>
        <lastBuildDate>Tue, 04 Mar 2025 19:15:05 +0800</lastBuildDate>
        <category>算法</category>
        <category>字符串</category>
        <category>滑动窗口</category>
        <category>力扣</category>
        <category>数组</category>
        <category>哈希表</category>
        <category>二分查找</category>
        <category>链表</category>
        <category>专题</category>
        <category>C++</category>
        <category>记录</category>
        <category>Markdown</category>
        <category>AI</category>
        <category>指南</category>
        <category>实战</category>
        <category>笔记</category>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/03/04/Leetcode-%E6%95%B0%E7%BB%84/</guid>
            <title>Leetcode | 数组</title>
            <link>https://232akira.github.io/2025/03/04/Leetcode-%E6%95%B0%E7%BB%84/</link>
            <category>力扣</category>
            <category>数组</category>
            <category>哈希表</category>
            <category>二分查找</category>
            <pubDate>Tue, 04 Mar 2025 19:15:05 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;912-排序数组&#34;&gt;&lt;a href=&#34;#912-排序数组&#34; class=&#34;headerlink&#34; title=&#34;912.排序数组&#34;&gt;&lt;/a&gt;912.排序数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 nums，请你将该数组升序排列。&lt;br&gt;你必须在 不使用任何内置函数 的情况下解决问题，时间复杂度为 O(nlog(n))，并且空间复杂度尽可能小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;先来总结一下&lt;/p&gt;
&lt;h3 id=&#34;十大排序算法&#34;&gt;&lt;a href=&#34;#十大排序算法&#34; class=&#34;headerlink&#34; title=&#34;十大排序算法~&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.runoob.com/w3cnote/ten-sorting-algorithm.html&#34;&gt;十大排序算法&lt;/a&gt;~&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;排序算法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;「平均」时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;「最坏」时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;「最好」时间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;空间复杂度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;稳定性&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;数据量小、基本有序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;选择排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;数据量小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;插入排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;数据量小、基本有序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;希尔排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlog^2n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlog^2n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;大数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;归并排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;链表排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;快速排序&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(logn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;处理大数据最常用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;堆排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;优先队列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;计数排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;数据范围较小、整数分布集中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;桶排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;数据分布均匀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;基数排序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n×k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n×k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;稳定&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;非比较排序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;其他总结&#34;&gt;&lt;a href=&#34;#其他总结&#34; class=&#34;headerlink&#34; title=&#34;其他总结&#34;&gt;&lt;/a&gt;其他总结&lt;/h3&gt;&lt;p&gt;1️⃣按稳定性分类&lt;br&gt;在排序前后，相等元素的相对顺序是否保持不变，如果相对顺序不变，则该排序算法是稳定的，否则是不稳定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定排序&lt;/strong&gt;：冒泡&amp;#x2F;插入&amp;#x2F;归并&amp;#x2F;基数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不稳定排序&lt;/strong&gt;：选择&amp;#x2F;快速&amp;#x2F;堆&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2️⃣排序算法优劣的&lt;a href=&#34;https://blog.csdn.net/2203_75646004/article/details/135172906&#34;&gt;衡量标准&lt;/a&gt;：&lt;br&gt;🔹 &lt;strong&gt;时间复杂度&lt;/strong&gt; 排序速度（比较&amp;amp;移动次数）&lt;br&gt;🔹 &lt;strong&gt;空间复杂度&lt;/strong&gt; 占内存辅助空间的大小&lt;br&gt;🔹 &lt;strong&gt;稳定性&lt;/strong&gt; A与B的关键字相等，排序后A、B的先后次序保持不变&lt;/p&gt;
&lt;p&gt;3️⃣按排序类别分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入&lt;/strong&gt;：插入&amp;#x2F;希尔&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择&lt;/strong&gt;：选择&amp;#x2F;堆&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交换&lt;/strong&gt;：冒泡&amp;#x2F;快速&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;归并&lt;/strong&gt;：归并&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基数&lt;/strong&gt;：基数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码&#34;&gt;&lt;a href=&#34;#完整代码&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1232-缀点成线&#34;&gt;&lt;a href=&#34;#1232-缀点成线&#34; class=&#34;headerlink&#34; title=&#34;1232.缀点成线&#34;&gt;&lt;/a&gt;1232.缀点成线&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 coordinates ，其中 coordinates[i] &amp;#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 &amp;lt;&amp;#x3D; coordinates.length &amp;lt;&amp;#x3D; 1000&lt;/li&gt;
&lt;li&gt;coordinates[i].length &amp;#x3D;&amp;#x3D; 2&lt;/li&gt;
&lt;li&gt;-10^4 &amp;lt;&amp;#x3D; coordinates[i][0], coordinates[i][1] &amp;lt;&amp;#x3D; 10^4&lt;/li&gt;
&lt;li&gt;coordinates 中不含重复的点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-1&#34;&gt;&lt;a href=&#34;#解题思路-1&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;我本来是想着soeasy，用y&amp;#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…&lt;/p&gt;
&lt;p&gt;那么就不使用斜率，而是使用&lt;strong&gt;斜率交叉乘法&lt;/strong&gt;：如果所有点都在同一条直线上，那么&lt;strong&gt;对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等&lt;/strong&gt;。也就是&lt;code&gt;(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)&lt;/code&gt;。为避免除法带来的浮点误差，用&lt;strong&gt;交叉相乘&lt;/strong&gt;验证更好。&lt;br&gt;&lt;em&gt;&lt;strong&gt;并且注意！&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;因为我的验证方法需要三个点，但是这道题有可&lt;code&gt;coordinates,length=2&lt;/code&gt;的情况，那就直接返回true，因为&lt;strong&gt;两点确定一条直线&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;完整代码-1&#34;&gt;&lt;a href=&#34;#完整代码-1&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    bool checkStraightLine(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; coordinates) &amp;#123;
        int x1,y1,x2,y2;
        x1=coordinates[0][0];
        y1=coordinates[0][1];
        x2=coordinates[1][0];
        y2=coordinates[1][1];
        if(coordinates.size()==2)&amp;#123;
            return true;
        &amp;#125;
        for(int i=2;i&amp;lt;coordinates.size();i++)&amp;#123;
            int x3=coordinates[i][0];
            int y3=coordinates[i][1];
            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&amp;#123;
                return false;
            &amp;#125;
        &amp;#125;
        return true;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2597-美丽子集的数目&#34;&gt;&lt;a href=&#34;#2597-美丽子集的数目&#34; class=&#34;headerlink&#34; title=&#34;2597.美丽子集的数目&#34;&gt;&lt;/a&gt;2597.美丽子集的数目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个由正整数组成的数组 nums 和一个 正 整数 k 。&lt;br&gt;如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。&lt;br&gt;返回数组 nums 中 非空 且 美丽 的子集数目。&lt;br&gt;nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 18&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i], k &amp;lt;&amp;#x3D; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-2&#34;&gt;&lt;a href=&#34;#解题思路-2&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;涉及&lt;strong&gt;子集&lt;/strong&gt;相关问题，一般有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回溯&lt;/li&gt;
&lt;li&gt;位运算&lt;br&gt;本题选择&lt;strong&gt;回溯&lt;/strong&gt;算法。因为该方法可在生成子集时&lt;strong&gt;剪枝&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设 nums &amp;#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;          dfs(0)
        /        \
    不选2        选2
     / \         /  \
  不选4  选4   不选4  选4
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码-2&#34;&gt;&lt;a href=&#34;#完整代码-2&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int ans=0;
    void dfs(int index,vector&amp;lt;int&amp;gt;&amp;amp; nums,unordered_map&amp;lt;int,int&amp;gt;&amp;amp; freq,int k)&amp;#123;
        if(index==nums.size())&amp;#123;
            ans++;
            return;
        &amp;#125;
        dfs(index+1,nums,freq,k);
        if(freq[nums[index]-k]==0 &amp;amp;&amp;amp; freq[nums[index]+k]==0)&amp;#123;
            freq[nums[index]]++;
            dfs(index+1,nums,freq,k);
            freq[nums[index]]--;
        &amp;#125;
    &amp;#125;
    int beautifulSubsets(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) &amp;#123;
        unordered_map&amp;lt;int,int&amp;gt; freq;
        dfs(0,nums,freq,k);
        return ans-1;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2070-每一个查询的最大美丽值&#34;&gt;&lt;a href=&#34;#2070-每一个查询的最大美丽值&#34; class=&#34;headerlink&#34; title=&#34;2070.每一个查询的最大美丽值&#34;&gt;&lt;/a&gt;2070.每一个查询的最大美丽值&lt;/h1&gt;&lt;p&gt;又美丽了家人们🤣&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个二维整数数组 items ，其中 items[i] &amp;#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。&lt;br&gt;同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。&lt;br&gt;请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;br&gt;-1 &amp;lt;&amp;#x3D; items.length, queries.length &amp;lt;&amp;#x3D; 105&lt;br&gt;-items[i].length &amp;#x3D;&amp;#x3D; 2&lt;br&gt;-1 &amp;lt;&amp;#x3D; pricei, beautyi, queries[j] &amp;lt;&amp;#x3D; 109&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-3&#34;&gt;&lt;a href=&#34;#解题思路-3&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h3 id=&#34;二分查找&#34;&gt;&lt;a href=&#34;#二分查找&#34; class=&#34;headerlink&#34; title=&#34;二分查找&#34;&gt;&lt;/a&gt;二分查找&lt;/h3&gt;&lt;p&gt;首先复习一下二分查找，我又忘了咋写。&lt;a href=&#34;https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/&#34;&gt;另一篇&lt;/a&gt;copy来的&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;要查找的目标&lt;code&gt;target&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;索引&lt;code&gt;index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;左、右指示符&lt;code&gt;left&lt;/code&gt;、&lt;code&gt;right&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中间指示符&lt;code&gt;mid&lt;/code&gt;&lt;br&gt;主要思路就是计算&lt;code&gt;mid&lt;/code&gt;的位置：&lt;br&gt;1️⃣&lt;code&gt;nums[mid] == target&lt;/code&gt; 🤭找到了&lt;br&gt;2️⃣&lt;code&gt;nums[mid] &amp;lt; target&lt;/code&gt; → target在left的右边 → left右移 👉️left&amp;#x3D;mid+1;&lt;br&gt;3️⃣&lt;code&gt;nums[mid] &amp;gt; target&lt;/code&gt; → target在right的左边 → right左移 👉️right&amp;#x3D;mid-1;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//形参：vector&amp;lt;int&amp;gt;nums,int target
int left=0;
int right=nums.size()-1;
while(left&amp;lt;=right)&amp;#123;
    int mid=left+(right-left)/2;
    if(nums[mid]=target)&amp;#123;
        return mid;
    &amp;#125;
    else if(nums[mid]&amp;lt;target)&amp;#123;
        left=mid+1;
    &amp;#125;
    else&amp;#123;
        right=mid-1;
    &amp;#125;
    return index;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;本题思路&#34;&gt;&lt;a href=&#34;#本题思路&#34; class=&#34;headerlink&#34; title=&#34;本题思路&#34;&gt;&lt;/a&gt;本题思路&lt;/h3&gt;&lt;h4 id=&#34;方法一&#34;&gt;&lt;a href=&#34;#方法一&#34; class=&#34;headerlink&#34; title=&#34;方法一&#34;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; maximumBeauty(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; items, vector&amp;lt;int&amp;gt;&amp;amp; queries) &amp;#123;
        vector&amp;lt;int&amp;gt; answer(queries.size(),0);
        for(int j=0;j&amp;lt;queries.size();j++)&amp;#123;
            int target=queries[j];
            int maxnum=0;
            for(int i=0;i&amp;lt;items.size();i++)&amp;#123;
                if(items[i][0]&amp;lt;=target)&amp;#123;
                    maxnum=max(maxnum,items[i][1]);
                &amp;#125;
            &amp;#125;
            answer[j]=maxnum;
        &amp;#125;
        return answer;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法二&#34;&gt;&lt;a href=&#34;#方法二&#34; class=&#34;headerlink&#34; title=&#34;方法二&#34;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;老老实实用二分。注意：二分查找的前提是&lt;strong&gt;有序&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先按照price递增排序;&lt;/li&gt;
&lt;li&gt;定义美丽数组;&lt;/li&gt;
&lt;li&gt;遍历items:&lt;strong&gt;存储当前遍历到的最大美丽值&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;定义答案数组;&lt;/li&gt;
&lt;li&gt;遍历querties：&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二分查找目标🤟&lt;code&gt;items[i][0] &amp;lt;= queries[j]&lt;/code&gt; 的最大 i&lt;br&gt;有点绕了，兄弟兄弟…&lt;/p&gt;
&lt;h2 id=&#34;完整代码-3&#34;&gt;&lt;a href=&#34;#完整代码-3&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; maximumBeauty(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; items, vector&amp;lt;int&amp;gt;&amp;amp; queries) &amp;#123;
        sort(items.begin(),items.end());
        vector&amp;lt;int&amp;gt;maxbeauty(items.size());
        maxbeauty[0]=items[0][1];
        for(int i=1;i&amp;lt;items.size();i++)&amp;#123;
            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);
        &amp;#125;
        vector&amp;lt;int&amp;gt;answer(queries.size(),0);
        for(int j=0;j&amp;lt;queries.size();j++)&amp;#123;
            int target=queries[j];
            int left=0;
            int right=items.size()-1;
            int index=-1;
            while(left&amp;lt;=right)&amp;#123;
                int mid=left+(right-left)/2;
                if(items[mid][0]&amp;lt;=target)&amp;#123;
                    index=mid;
                    left=mid+1;
                &amp;#125;
                else&amp;#123;
                    right=mid-1;
                &amp;#125;
            &amp;#125;
            if(index!=-1)&amp;#123;
                answer[j]=maxbeauty[index];
            &amp;#125;
        &amp;#125;
        return answer;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2269-找到一个数字的-K-美丽值&#34;&gt;&lt;a href=&#34;#2269-找到一个数字的-K-美丽值&#34; class=&#34;headerlink&#34; title=&#34;2269.找到一个数字的 K 美丽值&#34;&gt;&lt;/a&gt;2269.找到一个数字的 K 美丽值&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从0开始的整数数组nums。对于每个下标i（1 &amp;lt;&amp;#x3D; i &amp;lt;&amp;#x3D; nums.length - 2），nums[i] 的美丽值等于：&lt;br&gt;2，对于所有 0 &amp;lt;&amp;#x3D; j &amp;lt; i 且 i &amp;lt; k &amp;lt;&amp;#x3D; nums.length - 1 ，满足 nums[j] &amp;lt; nums[i] &amp;lt; nums[k]&lt;br&gt;1，如果满足 nums[i - 1] &amp;lt; nums[i] &amp;lt; nums[i + 1] ，且不满足前面的条件&lt;br&gt;0，如果上述条件全部不满足&lt;br&gt;返回符合 1 &amp;lt;&amp;#x3D; i &amp;lt;&amp;#x3D; nums.length - 2 的所有 nums[i] 的美丽值的总和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-4&#34;&gt;&lt;a href=&#34;#解题思路-4&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;难点在于nums[i]的美丽值为2的情况：&lt;/strong&gt;&lt;br&gt;突然想起来高中数学老师的口头禅：“大于大的，小于小的”。&lt;br&gt;nums[i]需要满足：比其左侧所有的nums[j]更大，以及&lt;em&gt;比其右侧所有的nums&lt;/em&gt;[k]更小。&lt;br&gt;即&lt;strong&gt;大于左侧最大值，小于右侧最小值&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*max_element(arr.begin(),arr.end())&lt;/code&gt;求数组最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*min_element(arr.begin(),arr.end())&lt;/code&gt;求数组最小值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;？超时了😇我还说想清楚了不难呢…&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int sumOfBeauties(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        int maxval,minval,ans=0;
        for(int i=1;i&amp;lt;nums.size()-1;i++)&amp;#123;
            maxval=*max_element(nums.begin(),nums.begin()+i);
            minval=*min_element(nums.begin()+i+1,nums.end());
            if(maxval&amp;lt;nums[i] &amp;amp;&amp;amp; minval&amp;gt;nums[i])&amp;#123;
                ans+=2;
            &amp;#125;
            else if(nums[i-1]&amp;lt;nums[i] &amp;amp;&amp;amp; nums[i+1]&amp;gt;nums[i])&amp;#123;
                ans+=1;
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进方法就是：左侧最大值和右侧最小值各自都用一个数组存起来所有i的情况，再进行条件判断。同时可以存一个，另一个随每次判断进行更新就好。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义左侧最大int数组leftMax;
遍历i从1到nums.size()：
    leftMax[i]=max(左侧最大数组[i-1],原数组[i-1]);
int 美丽值;
定义右侧最小int变量rightMin并初始化为原数组[length()-1];
遍历i从length()-2到0:
    如果（条件一）：
        美丽值+=2;
    否则如果（条件2）：
        美丽值+=1;
    更新右侧最小值=min（右侧最小值，原数组[i]）;
返回美丽值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整代码-4&#34;&gt;&lt;a href=&#34;#完整代码-4&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int sumOfBeauties(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        vector&amp;lt;int&amp;gt; leftMax(nums.size(),0);
        for(int i=1;i&amp;lt;nums.size();i++)&amp;#123;
            leftMax[i]=max(leftMax[i-1],nums[i-1]);
        &amp;#125;
        int ans=0;
        int rightMin=nums[nums.size()-1];
        for(int i=nums.size()-2;i&amp;gt;0;i--)&amp;#123;
            if(leftMax[i]&amp;lt;nums[i] &amp;amp;&amp;amp; nums[i]&amp;lt;rightMin)&amp;#123;
                ans+=2;
            &amp;#125;
            else if(nums[i-1]&amp;lt;nums[i] &amp;amp;&amp;amp; nums[i]&amp;lt;nums[i+1])&amp;#123;
                ans+=1;
            &amp;#125;
            rightMin=min(rightMin,nums[i]);
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;杨辉三角（一维数组版）&#34;&gt;&lt;a href=&#34;#杨辉三角（一维数组版）&#34; class=&#34;headerlink&#34; title=&#34;杨辉三角（一维数组版）&#34;&gt;&lt;/a&gt;杨辉三角（一维数组版）&lt;/h1&gt;&lt;h2 id=&#34;完整代码-5&#34;&gt;&lt;a href=&#34;#完整代码-5&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Print_TR(int n)&amp;#123;
    int arr[n]=&amp;#123;1&amp;#125;;
    for(int i=0;i&amp;lt;n;i++)&amp;#123;
        for(int j=i;j&amp;gt;0;j--)&amp;#123;
            arr[j]+=arr[j-1];
        &amp;#125;
        //打印
        for(int j=0;j&amp;lt;=i;j++)&amp;#123;
            printf(&amp;quot;%d &amp;quot;,arr[j]);
        &amp;#125;
        printf(&amp;quot;\n&amp;quot;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2610-转换二维数组&#34;&gt;&lt;a href=&#34;#2610-转换二维数组&#34; class=&#34;headerlink&#34; title=&#34;2610.转换二维数组&#34;&gt;&lt;/a&gt;2610.转换二维数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二维数组应该 只 包含数组 nums 中的元素。&lt;/li&gt;
&lt;li&gt;二维数组中的每一行都包含 不同 的整数。&lt;/li&gt;
&lt;li&gt;二维数组的行数应尽可能 少 。&lt;br&gt;返回结果数组。如果存在多种答案，则返回其中任何一种。&lt;br&gt;请注意，二维数组的每一行上可以存在不同数量的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 200&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; nums.length&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-5&#34;&gt;&lt;a href=&#34;#解题思路-5&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;用&lt;strong&gt;哈希表&lt;/strong&gt;！😎统计元素出现次数，定义一个一维数组存每行元素。每用一个元素。哈希表中该元素次数–（当次数为0时）从表中删除该元素。&lt;/p&gt;
&lt;p&gt;这里看题解 涉及到stl&lt;strong&gt;迭代器&lt;/strong&gt;&lt;code&gt;it&lt;/code&gt;的用法：对于定义一个哈希表:&lt;code&gt;unordered_map&amp;lt;int,int&amp;gt;cnt&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当用&lt;code&gt;auto:it&lt;/code&gt;遍历&lt;code&gt;cnt.begin()&lt;/code&gt;到&lt;code&gt;!=cnt.end()&lt;/code&gt;时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;it-&amp;gt;first&lt;/code&gt;即为哈希表键值对(key,value)中的&lt;code&gt;key&lt;/code&gt;。本题中即为&lt;strong&gt;元素本身&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;it-&amp;gt;second&lt;/code&gt;即为哈希表键值对(key,value)中的&lt;code&gt;value&lt;/code&gt;。本题中即为元素的&lt;strong&gt;出现次数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-6&#34;&gt;&lt;a href=&#34;#完整代码-6&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;p&gt;感谢&lt;a href=&#34;https://leetcode.cn/u/endlesscheng/&#34;&gt;灵神&lt;/a&gt;题解，教会我很多&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findMatrix(vector&amp;lt;int&amp;gt;&amp;amp; nums) &amp;#123;
        unordered_map&amp;lt;int,int&amp;gt; cnt;
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
        for(int x:nums)&amp;#123;
            cnt[x]++;
        &amp;#125;
        while(!cnt.empty())&amp;#123;
            vector&amp;lt;int&amp;gt;row;
            for(auto it=cnt.begin();it!=cnt.end();)&amp;#123;
                row.push_back(it-&amp;gt;first);
                if(--it-&amp;gt;second==0)&amp;#123;
                    it=cnt.erase(it);
                &amp;#125;
                else&amp;#123;
                    it++;
                &amp;#125;
            &amp;#125;
            ans.push_back(row);
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2643-一最多的行&#34;&gt;&lt;a href=&#34;#2643-一最多的行&#34; class=&#34;headerlink&#34; title=&#34;2643.一最多的行&#34;&gt;&lt;/a&gt;2643.一最多的行&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个大小为 m x n 的二进制矩阵 mat ，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。&lt;br&gt;如果有多行包含最多的 1 ，只需要选择 行下标最小 的那一行。&lt;br&gt;返回一个由行下标和该行中 1 的数量组成的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m &amp;#x3D;&amp;#x3D; mat.length &lt;/li&gt;
&lt;li&gt;n &amp;#x3D;&amp;#x3D; mat[i].length &lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; m, n &amp;lt;&amp;#x3D; 100 &lt;/li&gt;
&lt;li&gt;mat[i][j] 为 0 或 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-6&#34;&gt;&lt;a href=&#34;#解题思路-6&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;最轻松的一集😂但是我写的代码略史山，还有优化空间。&lt;/p&gt;
&lt;h2 id=&#34;完整代码-7&#34;&gt;&lt;a href=&#34;#完整代码-7&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;p&gt;这里直接用&lt;code&gt;int ones = count(mat[i].begin(), mat[i].end(), 1); &lt;/code&gt;统计1的个数可以减少一次遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; rowAndMaximumOnes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat) &amp;#123;
        vector&amp;lt;int&amp;gt; cnt(100,0),ans;
        int index=0;
        for(int i=0;i&amp;lt;mat.size();i++)&amp;#123;
            for(int j=0;j&amp;lt;mat[i].size();j++)&amp;#123;
                if(mat[i][j]==1)&amp;#123;
                    cnt[i]++;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        int maxnum=cnt[0];
        for(int i=0;i&amp;lt;cnt.size();i++)&amp;#123;
            if(cnt[i]&amp;gt;maxnum)&amp;#123;
                maxnum=cnt[i];
                index=i;
            &amp;#125;
        &amp;#125;
        ans.push_back(index);
        ans.push_back(cnt[index]);
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;661-图片平滑器&#34;&gt;&lt;a href=&#34;#661-图片平滑器&#34; class=&#34;headerlink&#34; title=&#34;661.图片平滑器&#34;&gt;&lt;/a&gt;661.图片平滑器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;图像平滑器&lt;/strong&gt;是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。&lt;br&gt;每个单元格的&lt;strong&gt;平均灰度&lt;/strong&gt;定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。&lt;br&gt;如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。&lt;br&gt;给你一个表示图像灰度的&lt;code&gt;m x n&lt;/code&gt;整数矩阵&lt;code&gt;img&lt;/code&gt;，返回对图像的每个单元格平滑处理后的图像 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m &amp;#x3D;&amp;#x3D; img.length&lt;/li&gt;
&lt;li&gt;n &amp;#x3D;&amp;#x3D; img[i].length&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; m, n &amp;lt;&amp;#x3D; 200&lt;/li&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; img[i][j] &amp;lt;&amp;#x3D; 255&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-7&#34;&gt;&lt;a href=&#34;#解题思路-7&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;关键知道矩阵边界，也就是不全加9个数的情况怎么算。我一开始还想着一个个情况穷举😂其实3*3区域安心两层遍历就行，对于这道题不会超时。&lt;br&gt;***刷题以来第一次碰到四层循环能通过的。。。***不看题解都不敢想像这个方法。&lt;/p&gt;
&lt;h2 id=&#34;完整代码-8&#34;&gt;&lt;a href=&#34;#完整代码-8&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; imageSmoother(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; img) &amp;#123;
        int m,n;
        m=img.size();
        n=img[0].size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;ans(m,vector&amp;lt;int&amp;gt;(n,0));
        for(int i=0;i&amp;lt;m;i++)&amp;#123;
            for(int j=0;j&amp;lt;n;j++)&amp;#123;
                int sum,cnt;
                sum=cnt=0;
                for(int r=i-1;r&amp;lt;=i+1;r++)&amp;#123;
                    for(int c=j-1;c&amp;lt;=j+1;c++)&amp;#123;
                        if(0&amp;lt;=r &amp;amp;&amp;amp; r&amp;lt;m &amp;amp;&amp;amp; 0&amp;lt;=c &amp;amp;&amp;amp; c&amp;lt;n)&amp;#123;
                            sum+=img[r][c];
                            cnt++;
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
                ans[i][j]=cnt&amp;gt;0?sum/cnt:img[i][j];
            &amp;#125;
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;27171-对角线上不同值的数量差&#34;&gt;&lt;a href=&#34;#27171-对角线上不同值的数量差&#34; class=&#34;headerlink&#34; title=&#34;27171.对角线上不同值的数量差&#34;&gt;&lt;/a&gt;27171.对角线上不同值的数量差&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从 0 开始、大小为 m x n 的二维矩阵 grid ，请你求解大小同样为 m x n 的答案矩阵 answer 。&lt;br&gt;矩阵 answer 中每个单元格 (r, c) 的值可以按下述方式进行计算：&lt;br&gt;令 topLeft[r][c] 为矩阵 grid 中单元格 (r, c) 左上角对角线上 不同值 的数量。&lt;br&gt;令 bottomRight[r][c] 为矩阵 grid 中单元格 (r, c) 右下角对角线上 不同值 的数量。&lt;br&gt;然后 answer[r][c] &amp;#x3D; |topLeft[r][c] - bottomRight[r][c]| 。&lt;br&gt;返回矩阵 answer 。&lt;br&gt;矩阵对角线 是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。&lt;br&gt;如果单元格 (r1, c1) 和单元格 (r, c) 属于同一条对角线且 r1 &amp;lt; r ，则单元格 (r1, c1) 属于单元格 (r, c) 的左上对角线。类似地，可以定义右下对角线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m &amp;#x3D;&amp;#x3D; grid.length&lt;/li&gt;
&lt;li&gt;n &amp;#x3D;&amp;#x3D; grid[i].length&lt;/li&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; m, n, grid[i][j] &amp;lt;&amp;#x3D; 50&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-8&#34;&gt;&lt;a href=&#34;#解题思路-8&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;几个地方思考的时候容易卡住：&lt;/p&gt;
&lt;p&gt;1️⃣&lt;strong&gt;不同值是什么意思？&lt;/strong&gt;&lt;br&gt;我一开始理解的是对于grid[i][j]，它的左对角线上和它不同的元素数量叫做topleft，右对角线上和它不同的元素数量叫做bottomright，然后就自以为大彻大悟☝️🤓&lt;del&gt;美美去打代码然后寄了&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;个人理解中，实际上这里的不同值的意思是：对于这半拉对角线上的所有元素而言的&lt;strong&gt;种类&lt;/strong&gt;数量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如全是1，那就1种，topleft&amp;#x3D;1；&lt;/li&gt;
&lt;li&gt;如果有1有0，那就是2种，topleft&amp;#x3D;2。&lt;br&gt;右对角线同理.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2️⃣&lt;strong&gt;如何统计“不同值”？&lt;/strong&gt;&lt;br&gt;这里选用基于红黑树的std::set而不是之前我们常用的unordered_map。因为对于本题，只需要判断「是否不同」而不需要记录「不同的次数」。&lt;br&gt;对于set&lt;int&gt;myset 而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果rfind.find(grid[r][c])&amp;#x3D;&amp;#x3D;rfind.end()即为不同值&lt;/li&gt;
&lt;li&gt;新的不同值用myset.insert()添加&lt;/li&gt;
&lt;li&gt;myset.size()获得不同值的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;完整代码-9&#34;&gt;&lt;a href=&#34;#完整代码-9&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; differenceOfDistinctValues(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) &amp;#123;
        int m,n;
        m=grid.size();
        n=grid[0].size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer(m,vector&amp;lt;int&amp;gt;(n,0));
        for(int i=0;i&amp;lt;m;i++)&amp;#123;
            for(int j=0;j&amp;lt;n;j++)&amp;#123;
                int lcnt,rcnt;
                lcnt=rcnt=0;
                set&amp;lt;int&amp;gt; lfind,rfind;
                //左对角线
                int r=i-1;
                int c=j-1;
                while(r&amp;gt;=0 &amp;amp;&amp;amp; c&amp;gt;=0)&amp;#123;
                    if(「」)&amp;#123;
                        lcnt++;
                    &amp;#125;
                    lfind.insert(grid[r][c]);
                    r--;
                    c--;
                &amp;#125;
                //右对角线
                r=i+1;
                c=j+1;
                while(r&amp;lt;m &amp;amp;&amp;amp; c&amp;lt;n)&amp;#123;
                    if(rfind.find(grid[r][c])==rfind.end())&amp;#123;
                        rcnt++;
                    &amp;#125;
                    rfind.insert(grid[r][c]);
                    r++;
                    c++;
                &amp;#125;
                answer[i][j]=abs(lcnt-rcnt);
            &amp;#125;
        &amp;#125;
        return answer;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3375-使数组的值全部为K的最少操作次数&#34;&gt;&lt;a href=&#34;#3375-使数组的值全部为K的最少操作次数&#34; class=&#34;headerlink&#34; title=&#34;3375.使数组的值全部为K的最少操作次数&#34;&gt;&lt;/a&gt;3375.使数组的值全部为K的最少操作次数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个整数数组 nums 和一个整数 k 。&lt;br&gt;如果一个数组中所有 严格大于 h 的整数值都 相等 ，那么我们称整数 h 是 合法的 。&lt;br&gt;比方说，如果 nums &amp;#x3D; [10, 8, 10, 8] ，那么 h &amp;#x3D; 9 是一个 合法 整数，因为所有满足 nums[i] &amp;gt; 9 的数都等于 10 ，但是 5 不是 合法 整数。&lt;br&gt;你可以对 nums 执行以下操作：&lt;br&gt;选择一个整数 h ，它对于 当前 nums 中的值是合法的。&lt;br&gt;对于每个下标 i ，如果它满足 nums[i] &amp;gt; h ，那么将 nums[i] 变为 h 。&lt;br&gt;你的目标是将 nums 中的所有元素都变为 k ，请你返回 最少 操作次数。如果无法将所有元素都变 k ，那么返回 -1 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-9&#34;&gt;&lt;a href=&#34;#解题思路-9&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;呃(⊙﹏⊙)自认为语文水平还不错，但是这题目着实看不懂…&lt;/p&gt;
&lt;p&gt;看了评论区&amp;amp;题解佬们的耐心讲解，我浅总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数返回&lt;br&gt;返回&lt;strong&gt;将nums所有元素变为k&lt;/strong&gt;的最少操作次数，变不了返回-1。&lt;/li&gt;
&lt;li&gt;元素变k的前提&lt;br&gt;nums中&amp;gt;k的所有元素都相等，将这些元素全变为k。&lt;/li&gt;
&lt;li&gt;无法满足返回-1是什么情况&lt;br&gt;如果nums中但凡有元素小于k，那么一定不中。&lt;/li&gt;
&lt;li&gt;最少操作次数&lt;br&gt;&lt;del&gt;关键来了&lt;/del&gt;数组中所有大于k的元素种类。对，就这样就行😅&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;完整代码-10&#34;&gt;&lt;a href=&#34;#完整代码-10&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution &amp;#123;
public:
    int minOperations(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) &amp;#123;
        int cnt=0;
        unordered_set&amp;lt;int&amp;gt;hashset;
        for(int num:nums)&amp;#123;
            if(num&amp;lt;k)&amp;#123;
                return -1;
            &amp;#125;
            else&amp;#123;
                if(hashset.find(num)==hashset.end() &amp;amp;&amp;amp; num&amp;gt;k)&amp;#123;
                    hashset.insert(num);
                    cnt++;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return cnt;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2563-统计公平数对的数目&#34;&gt;&lt;a href=&#34;#2563-统计公平数对的数目&#34; class=&#34;headerlink&#34; title=&#34;2563.统计公平数对的数目&#34;&gt;&lt;/a&gt;2563.统计公平数对的数目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。&lt;br&gt;如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;&amp;#x3D; i &amp;lt; j &amp;lt; n，且&lt;/li&gt;
&lt;li&gt;lower &amp;lt;&amp;#x3D; nums[i] + nums[j] &amp;lt;&amp;#x3D; upper&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;&amp;#x3D; nums.length &amp;lt;&amp;#x3D; 105&lt;/li&gt;
&lt;li&gt;nums.length &amp;#x3D;&amp;#x3D; n&lt;/li&gt;
&lt;li&gt;-109 &amp;lt;&amp;#x3D; nums[i] &amp;lt;&amp;#x3D; 109&lt;/li&gt;
&lt;li&gt;-109 &amp;lt;&amp;#x3D; lower &amp;lt;&amp;#x3D; upper &amp;lt;&amp;#x3D; 109&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;解题思路-10&#34;&gt;&lt;a href=&#34;#解题思路-10&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;p&gt;PS：因为实习鸽了五个工作日的我想了想又苟回来日更辣！！！现在是2025年4月19！等做到1000题再停更，主打一个保持编码的思维和手感😼&lt;del&gt;毕竟斥巨资开了力扣年卡不写一年也太亏了&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;完整代码-11&#34;&gt;&lt;a href=&#34;#完整代码-11&#34; class=&#34;headerlink&#34; title=&#34;完整代码&#34;&gt;&lt;/a&gt;完整代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
    </channel>
</rss>

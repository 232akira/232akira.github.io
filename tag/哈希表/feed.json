{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"哈希表\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "url": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "title": "专题1️⃣ 滑动窗口",
            "date_published": "2025-03-12T10:20:15.000Z",
            "content_html": "<p>今天照例每日一题，然后麻溜的看题解，发现又是一道滑动窗口题。所以开个专题归类一下。</p>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><p>今天字符串也要美丽了🆘</p>\n<blockquote>\n<p>一个整数num的k美丽值定义为num中符合以下条件的子字符串数目：</p>\n<ul>\n<li>子字符串长度为k。</li>\n<li>子字符串能整除num。<br>给你整数num和k，请你返回num的k美丽值。<br>注意：<br>允许有前缀0。<br>0不能整除任何值。<br>一个子字符串是一个字符串里的连续一段字符序列。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= num &lt;= 109</code></li>\n<li><code>1 &lt;= k &lt;= num.length</code> （将 num 视为字符串）</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我觉得这道的要点就是子串怎么得，剩下的就好判断了。偏偏我就栽在这儿了😅</p>\n<ul>\n<li><strong>int转string</strong> <code>to_string()</code>注意此函数需要赋给个string变量</li>\n<li><strong>string转int</strong> <code>stoi()</code>同样，需要赋给个int变量</li>\n<li><strong>获取长度为k的字符串</strong> <code>substr(i,k)</code>距离c++学这个函数已经过了一两年了，忘的一干二净，趁此好机会来总结一下。</li>\n</ul>\n<p>👇️ <em><strong>获取子串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>substr(pos,len)</code></td>\n<td align=\"center\">从pos开始，提取长度为len的子串</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>查找字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>find(str,pos)</code></td>\n<td align=\"center\">在pos之后查找str的位置，找不到返回string::pos</td>\n</tr>\n<tr>\n<td align=\"center\"><code>rfind(str,pos)</code></td>\n<td align=\"center\">逆向查找str,从pos开始向前找</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_first_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的第一次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_last_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的最后一次出现</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>替换字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>replace(pos,len,str)</code></td>\n<td align=\"center\">从pos开始，用str替换len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>erase(pos,len)</code></td>\n<td align=\"center\">删除从pos开始的len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>insert(pos,str)</code></td>\n<td align=\"center\">在pos位置插入str</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>大小写转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>toupper(c)</code></td>\n<td align=\"center\">将字符c转换为大写</td>\n</tr>\n<tr>\n<td align=\"center\"><code>tolower(c)</code></td>\n<td align=\"center\">将字符c转换为小写</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>数字与字符串转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>to_string(num)</code></td>\n<td align=\"center\">把num转换为字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stoi(str)</code></td>\n<td align=\"center\">把str转换为int</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stol(str)</code></td>\n<td align=\"center\">把str转换为long</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stod(str)</code></td>\n<td align=\"center\">把str转换为double</td>\n</tr>\n</tbody></table>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int divisorSubstrings(int num, int k) &#123;\n        int cnt=0;\n        string str=to_string(num);\n        for(int i=0;i&lt;=str.size()-k;i++)&#123;\n            string ans=str.substr(i,k);\n            int answer=stoi(ans);\n            if(answer!=0 &amp;&amp; num%answer==0)&#123;\n                cnt++;\n            &#125;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3305-元音辅音字符串计数Ⅰ\"><a href=\"#3305-元音辅音字符串计数Ⅰ\" class=\"headerlink\" title=\"3305.元音辅音字符串计数Ⅰ\"></a>3305.元音辅音字符串计数Ⅰ</h1><blockquote>\n<p>给你一个字符串word和一个非负整数 k。<br>返回word的子字符串中，每个元音字母（’a’、’e’、’i’、’o’、’u’）至少出现一次，并且恰好包含k个辅音字母的子字符串的总数。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>5 &lt;&#x3D; word.length &lt;&#x3D; 250</li>\n<li>word 仅由小写英文字母组成。</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; word.length - 5</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先试了试暴力😤循环套三层观感太差，不放上来。</p>\n<p><strong>正经解法</strong></p>\n<ul>\n<li>滑动窗口代替暴力循环</li>\n<li>哈希表统计元音出现次数</li>\n</ul>\n<p><strong>注意几个用法</strong><br><em><strong>1️⃣ 几个键值对容器</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键值对容器</th>\n<th align=\"center\">实现方式</th>\n<th align=\"center\">键值</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">是否有序</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unordered_map</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找键对应的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>map</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要有序键值对</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_set</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找元素是否存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>set</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要排序的集合</td>\n</tr>\n</tbody></table>\n<p><em><strong>2️⃣ 键值对容器+函数求的是什么？</strong></em></p>\n<ul>\n<li><code>unordered_map.size()</code>返回unordered_map中<strong>键值对的数量</strong>。</li>\n<li><code>unordered_set.count(x)</code>unordered_set中<strong>某个元素是否存在</strong>，返回1表示在，0表示不在。</li>\n</ul>\n<p>代码思路如下。这个方法时间空间上并非最优，后续需要调整思路。</p>\n<pre><code class=\"language-cpp\">定义n：word长度;\n定义unordered_map类型的vowel_cnt:元音出现次数;\n定义consonant_cnt:辅音个数;\n定义ans：统计最终答案;\n定义unordered_set类型的vowels:所有元音字母;\n定义左指针j=0;\n遍历word从下标0~word.size():\n    定义右元素right=word[i];\n    统计元音出现次数：\n        进行元/辅音计数;\n    当辅音数量超过k://收缩窗口左边界\n        定义左元素left=word[左指针];//取左边界字符\n        如果left是元音：\n            该元音出现次数--;\n            当元音的计数减少到0时：\n                将它从vowel_cnt中删除；\n        否则：\n            辅音个数--;\n        左指针右移;\n    如果包含所有元音且辅音个数为k:\n        //避免修改原窗口状态,思路整体与上半部分相同☝️\n        定义临时变量temp_vowel=vowel_cnt;\n        定义临时变量temp_consonant=consonant_cnt;\n        定义临时变量temp_j=j;\n        定义计数cnt=0;\n        当临时左下标&lt;=右下标:\n            如果包含所有临时元音且临时辅音个数为k:\n                cnt++;\n            否则:\n                退出该层循环;\n            定义c:word[临时左指针];\n            如果c是元音：\n                临时该元音出现次数--;\n                当临时元音的计数减少到0时：\n                    将它从临时vowel_cnt中删除;\n            否则:\n                临时辅音个数--;\n            临时左指针j右移;\n        ans+=cnt;\n返回ans;\n</code></pre>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countOfSubstrings(string word, int k) &#123;\n        int len=word.size();\n        unordered_map&lt;char,int&gt;vowel_cnt;\n        int consonant_cnt=0;\n        int ans=0;\n        unordered_set&lt;int&gt;vowels=&#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;&#125;;\n        int j=0;\n        for(int i=0;i&lt;len;i++)&#123;\n            char right=word[i];\n            if(vowels.count(right))&#123;\n                vowel_cnt[right]++;\n            &#125;\n            else&#123;\n                consonant_cnt++;\n            &#125;\n            while(consonant_cnt&gt;k)&#123;\n                char left=word[j];\n                if(vowels.count(left))&#123;\n                    vowel_cnt[left]--;\n                    if(vowel_cnt[left]==0)&#123;\n                        vowel_cnt.erase(left);\n                    &#125;\n                &#125;\n                else&#123;\n                    consonant_cnt--;\n                &#125;\n                j++;\n            &#125;\n            if(vowel_cnt.size()==5 &amp;&amp; consonant_cnt==k)&#123;\n                unordered_map&lt;char,int&gt;temp_vowel=vowel_cnt;\n                int temp_consonant=consonant_cnt;\n                int temp_j=j;\n                int cnt=0;\n                while(temp_j&lt;=i)&#123;\n                    if(temp_vowel.size()==5 &amp;&amp; temp_consonant==k)&#123;\n                        cnt++;\n                    &#125;\n                    else&#123;\n                        break;\n                    &#125;\n                    int c=word[temp_j];\n                    if(vowels.count(c))&#123;\n                        temp_vowel[c]--;\n                        if(temp_vowel[c]==0)&#123;\n                            temp_vowel.erase(c);\n                        &#125;\n                    &#125;\n                    else&#123;\n                        temp_consonant--;\n                    &#125;\n                    temp_j++;\n                &#125;\n                ans+=cnt;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3306-元音辅音字符串计数Ⅱ\"><a href=\"#3306-元音辅音字符串计数Ⅱ\" class=\"headerlink\" title=\"3306.元音辅音字符串计数Ⅱ\"></a>3306.元音辅音字符串计数Ⅱ</h1><p>不行，彻底懵了脑子转不动做梦都是元辅音😫先把copy的官方题解放这，过两天我再苟回来看。</p>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long countOfSubstrings(string word, int k) &#123;\n        set&lt;char&gt; vowels = &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;&#125;;\n        auto count = [&amp;](int m) -&gt; long long &#123;\n            int n = word.size(), consonants = 0;\n            long long res = 0;\n            map&lt;char, int&gt; occur;\n            for (int i = 0, j = 0; i &lt; n; i++) &#123;\n                while (j &lt; n &amp;&amp; (consonants &lt; m || occur.size() &lt; vowels.size())) &#123;\n                    if (vowels.count(word[j])) &#123;\n                        occur[word[j]]++;\n                    &#125; else &#123;\n                        consonants++;\n                    &#125;\n                    j++;\n                &#125;\n                if (consonants &gt;= m &amp;&amp; occur.size() == vowels.size()) &#123;\n                    res += n - j + 1;\n                &#125;\n                if (vowels.count(word[i])) &#123;\n                    occur[word[i]]--;\n                    if (occur[word[i]] == 0) &#123;\n                        occur.erase(word[i]);\n                    &#125;\n                &#125; else &#123;\n                    consonants--;\n                &#125;\n            &#125;\n            return res;\n        &#125;;\n        return count(k) - count(k + 1);\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "算法",
                "字符串",
                "滑动窗口",
                "力扣",
                "哈希表"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "url": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "title": "Leetcode数组",
            "date_published": "2025-03-04T11:15:05.000Z",
            "content_html": "<p>本来想一道题一篇文，但是做的大多是简单题所以按模块归类好复习一点。</p>\n<h1 id=\"1232-缀点成线\"><a href=\"#1232-缀点成线\" class=\"headerlink\" title=\"1232.缀点成线\"></a>1232.缀点成线</h1><blockquote>\n<p>给定一个数组 coordinates ，其中 coordinates[i] &#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n<ul>\n<li>2 &lt;&#x3D; coordinates.length &lt;&#x3D; 1000</li>\n<li>coordinates[i].length &#x3D;&#x3D; 2</li>\n<li>-10^4 &lt;&#x3D; coordinates[i][0], coordinates[i][1] &lt;&#x3D; 10^4</li>\n<li>coordinates 中不含重复的点</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我本来是想着soeasy，用y&#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…</p>\n<p>那么就不使用斜率，而是使用<strong>斜率交叉乘法</strong>：如果所有点都在同一条直线上，那么<strong>对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等</strong>。也就是<code>(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)</code>。为避免除法带来的浮点误差，用<strong>交叉相乘</strong>验证更好。<br><em><strong>并且注意！</strong></em><br>因为我的验证方法需要三个点，但是这道题有可<code>coordinates,length=2</code>的情况，那就直接返回true，因为<strong>两点确定一条直线</strong>。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;\n        int x1,y1,x2,y2;\n        x1=coordinates[0][0];\n        y1=coordinates[0][1];\n        x2=coordinates[1][0];\n        y2=coordinates[1][1];\n        if(coordinates.size()==2)&#123;\n            return true;\n        &#125;\n        for(int i=2;i&lt;coordinates.size();i++)&#123;\n            int x3=coordinates[i][0];\n            int y3=coordinates[i][1];\n            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2597-美丽子集的数目\"><a href=\"#2597-美丽子集的数目\" class=\"headerlink\" title=\"2597.美丽子集的数目\"></a>2597.美丽子集的数目</h1><blockquote>\n<p>给你一个由正整数组成的数组 nums 和一个 正 整数 k 。<br>如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。<br>返回数组 nums 中 非空 且 美丽 的子集数目。<br>nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 18</li>\n<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>涉及<strong>子集</strong>相关问题，一般有两种方法：</p>\n<ul>\n<li>回溯</li>\n<li>位运算<br>本题选择<strong>回溯</strong>算法。因为该方法可在生成子集时<strong>剪枝</strong>。</li>\n</ul>\n<p>假设 nums &#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：</p>\n<pre><code>          dfs(0)\n        /        \\\n    不选2        选2\n     / \\         /  \\\n  不选4  选4   不选4  选4\n  ...\n</code></pre>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int ans=0;\n    void dfs(int index,vector&lt;int&gt;&amp; nums,unordered_map&lt;int,int&gt;&amp; freq,int k)&#123;\n        if(index==nums.size())&#123;\n            ans++;\n            return;\n        &#125;\n        dfs(index+1,nums,freq,k);\n        if(freq[nums[index]-k]==0 &amp;&amp; freq[nums[index]+k]==0)&#123;\n            freq[nums[index]]++;\n            dfs(index+1,nums,freq,k);\n            freq[nums[index]]--;\n        &#125;\n    &#125;\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int,int&gt; freq;\n        dfs(0,nums,freq,k);\n        return ans-1;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2070-每一个查询的最大美丽值\"><a href=\"#2070-每一个查询的最大美丽值\" class=\"headerlink\" title=\"2070.每一个查询的最大美丽值\"></a>2070.每一个查询的最大美丽值</h1><p>又美丽了家人们🤣</p>\n<blockquote>\n<p>给你一个二维整数数组 items ，其中 items[i] &#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。<br>同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。<br>请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>-1 &lt;&#x3D; items.length, queries.length &lt;&#x3D; 105<br>-items[i].length &#x3D;&#x3D; 2<br>-1 &lt;&#x3D; pricei, beautyi, queries[j] &lt;&#x3D; 109</p>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>首先复习一下二分查找，我又忘了咋写。<a href=\"https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/\">另一篇</a>copy来的</p>\n<blockquote>\n<ul>\n<li>要查找的目标<code>target</code></li>\n<li>索引<code>index</code></li>\n<li>左、右指示符<code>left</code>、<code>right</code></li>\n<li>中间指示符<code>mid</code><br>主要思路就是计算<code>mid</code>的位置：<br>1️⃣<code>nums[mid] == target</code> 🤭找到了<br>2️⃣<code>nums[mid] &lt; target</code> → target在left的右边 → left右移 👉️left&#x3D;mid+1;<br>3️⃣<code>nums[mid] &gt; target</code> → target在right的左边 → right左移 👉️right&#x3D;mid-1;</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-cpp\">//形参：vector&lt;int&gt;nums,int target\nint left=0;\nint right=nums.size()-1;\nwhile(left&lt;=right)&#123;\n    int mid=left+(right-left)/2;\n    if(nums[mid]=target)&#123;\n        return mid;\n    &#125;\n    else if(nums[mid]&lt;target)&#123;\n        left=mid+1;\n    &#125;\n    else&#123;\n        right=mid-1;\n    &#125;\n    return index;\n&#125;\n</code></pre>\n<h3 id=\"本题思路\"><a href=\"#本题思路\" class=\"headerlink\" title=\"本题思路\"></a>本题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a><em><strong>方法一</strong></em></h4><p>完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        vector&lt;int&gt; answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int maxnum=0;\n            for(int i=0;i&lt;items.size();i++)&#123;\n                if(items[i][0]&lt;=target)&#123;\n                    maxnum=max(maxnum,items[i][1]);\n                &#125;\n            &#125;\n            answer[j]=maxnum;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a><em><strong>方法二</strong></em></h4><p>老老实实用二分。注意：二分查找的前提是<strong>有序</strong>。</p>\n<ul>\n<li>先按照price递增排序;</li>\n<li>定义美丽数组;</li>\n<li>遍历items:<strong>存储当前遍历到的最大美丽值</strong>;</li>\n<li>定义答案数组;</li>\n<li>遍历querties：<strong>二分查找</strong></li>\n</ul>\n<p>二分查找目标🤟<code>items[i][0] &lt;= queries[j]</code> 的最大 i<br>有点绕了，兄弟兄弟…</p>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        sort(items.begin(),items.end());\n        vector&lt;int&gt;maxbeauty(items.size());\n        maxbeauty[0]=items[0][1];\n        for(int i=1;i&lt;items.size();i++)&#123;\n            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);\n        &#125;\n        vector&lt;int&gt;answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int left=0;\n            int right=items.size()-1;\n            int index=-1;\n            while(left&lt;=right)&#123;\n                int mid=left+(right-left)/2;\n                if(items[mid][0]&lt;=target)&#123;\n                    index=mid;\n                    left=mid+1;\n                &#125;\n                else&#123;\n                    right=mid-1;\n                &#125;\n            &#125;\n            if(index!=-1)&#123;\n                answer[j]=maxbeauty[index];\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><blockquote>\n<p>给你一个下标从0开始的整数数组nums。对于每个下标i（1 &lt;&#x3D; i &lt;&#x3D; nums.length - 2），nums[i] 的美丽值等于：<br>2，对于所有 0 &lt;&#x3D; j &lt; i 且 i &lt; k &lt;&#x3D; nums.length - 1 ，满足 nums[j] &lt; nums[i] &lt; nums[k]<br>1，如果满足 nums[i - 1] &lt; nums[i] &lt; nums[i + 1] ，且不满足前面的条件<br>0，如果上述条件全部不满足<br>返回符合 1 &lt;&#x3D; i &lt;&#x3D; nums.length - 2 的所有 nums[i] 的美丽值的总和。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>3 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>难点在于nums[i]的美丽值为2的情况：</strong><br>突然想起来高中数学老师的口头禅：“大于大的，小于小的”。<br>nums[i]需要满足：比其左侧所有的nums[j]更大，以及<em>比其右侧所有的nums</em>[k]更小。<br>即<strong>大于左侧最大值，小于右侧最小值</strong>。</p>\n<ul>\n<li><code>*max_element(arr.begin(),arr.end())</code>求数组最大值</li>\n<li><code>*min_element(arr.begin(),arr.end())</code>求数组最小值</li>\n</ul>\n<p>？超时了😇我还说想清楚了不难呢…</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int sumOfBeauties(vector&lt;int&gt;&amp; nums) &#123;\n        int maxval,minval,ans=0;\n        for(int i=1;i&lt;nums.size()-1;i++)&#123;\n            maxval=*max_element(nums.begin(),nums.begin()+i);\n            minval=*min_element(nums.begin()+i+1,nums.end());\n            if(maxval&lt;nums[i] &amp;&amp; minval&gt;nums[i])&#123;\n                ans+=2;\n            &#125;\n            else if(nums[i-1]&lt;nums[i] &amp;&amp; nums[i+1]&gt;nums[i])&#123;\n                ans+=1;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>改进方法就是：左侧最大值和右侧最小值各自都用一个数组存起来所有i的情况，再进行条件判断。同时可以存一个，另一个随每次判断进行更新就好。</p>\n<pre><code>定义左侧最大int数组leftMax;\n遍历i从1到nums.size()：\n    leftMax[i]=max(左侧最大数组[i-1],原数组[i-1]);\nint 美丽值;\n定义右侧最小int变量rightMin并初始化为原数组[length()-1];\n遍历i从length()-2到0:\n    如果（条件一）：\n        美丽值+=2;\n    否则如果（条件2）：\n        美丽值+=1;\n    更新右侧最小值=min（右侧最小值，原数组[i]）;\n返回美丽值\n</code></pre>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int sumOfBeauties(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; leftMax(nums.size(),0);\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            leftMax[i]=max(leftMax[i-1],nums[i-1]);\n        &#125;\n        int ans=0;\n        int rightMin=nums[nums.size()-1];\n        for(int i=nums.size()-2;i&gt;0;i--)&#123;\n            if(leftMax[i]&lt;nums[i] &amp;&amp; nums[i]&lt;rightMin)&#123;\n                ans+=2;\n            &#125;\n            else if(nums[i-1]&lt;nums[i] &amp;&amp; nums[i]&lt;nums[i+1])&#123;\n                ans+=1;\n            &#125;\n            rightMin=min(rightMin,nums[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"杨辉三角（一维数组版）\"><a href=\"#杨辉三角（一维数组版）\" class=\"headerlink\" title=\"杨辉三角（一维数组版）\"></a>杨辉三角（一维数组版）</h1><h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-c\">void Print_TR(int n)&#123;\n    int arr[n]=&#123;1&#125;;\n    for(int i=0;i&lt;n;i++)&#123;\n        for(int j=i;j&gt;0;j--)&#123;\n            arr[j]+=arr[j-1];\n        &#125;\n        //打印\n        for(int j=0;j&lt;=i;j++)&#123;\n            printf(&quot;%d &quot;,arr[j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"53-最大子数组和\"><a href=\"#53-最大子数组和\" class=\"headerlink\" title=\"53.最大子数组和\"></a>53.最大子数组和</h1><blockquote>\n<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>经典解法：Kadane算法</strong>。核心思路是动态规划，通过遍历数组维护当前最大子数组和。整体思路如下：<br>1️⃣<strong>维护两个变量：</strong></p>\n<ul>\n<li><code>sum</code>当前最大子数组和</li>\n<li><code>maxsum</code>全局最大子数组和<br>2️⃣<strong>遍历数组，每次决定是否扩展当前子数组</strong></li>\n<li>如果<code>sum+nums[i] &lt; nums[i]</code> 从nums[i]重新开始（之前的子数组必定与最大和无关</li>\n<li>否则继续累加nums[i]<br>3️⃣<strong>每次更新<code>maxsum</code></strong></li>\n</ul>\n<h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int sum=nums[0];\n        int maxsum=nums[0];\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            sum=max(nums[i],sum+nums[i]);\n            maxsum=max(sum,maxsum);\n        &#125;\n        return maxsum;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"53-最大子数组和-1\"><a href=\"#53-最大子数组和-1\" class=\"headerlink\" title=\"53.最大子数组和\"></a>53.最大子数组和</h1><blockquote>\n<p>给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组：</p>\n<ul>\n<li>二维数组应该 只 包含数组 nums 中的元素。</li>\n<li>二维数组中的每一行都包含 不同 的整数。</li>\n<li>二维数组的行数应尽可能 少 。<br>返回结果数组。如果存在多种答案，则返回其中任何一种。<br>请注意，二维数组的每一行上可以存在不同数量的元素。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums.length</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>用<strong>哈希表</strong>！😎统计元素出现次数，定义一个一维数组存每行元素。每用一个元素。哈希表中该元素次数–（当次数为0时）从表中删除该元素。</p>\n<p>这里看题解 涉及到stl<strong>迭代器</strong><code>it</code>的用法：对于定义一个哈希表:<code>unordered_map&lt;int,int&gt;cnt</code></p>\n<ul>\n<li>当用<code>auto:it</code>遍历<code>cnt.begin()</code>到<code>!=cnt.end()</code>时</li>\n<li><code>it-&gt;first</code>即为哈希表键值对(key,value)中的<code>key</code>。本题中即为<strong>元素本身</strong></li>\n<li><code>it-&gt;second</code>即为哈希表键值对(key,value)中的<code>value</code>。本题中即为元素的<strong>出现次数</strong></li>\n</ul>\n<h2 id=\"完整代码-6\"><a href=\"#完整代码-6\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>感谢<a href=\"https://leetcode.cn/u/endlesscheng/\">灵神</a>题解，教会我很多</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findMatrix(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_map&lt;int,int&gt; cnt;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        for(int x:nums)&#123;\n            cnt[x]++;\n        &#125;\n        while(!cnt.empty())&#123;\n            vector&lt;int&gt;row;\n            for(auto it=cnt.begin();it!=cnt.end();)&#123;\n                row.push_back(it-&gt;first);\n                if(--it-&gt;second==0)&#123;\n                    it=cnt.erase(it);\n                &#125;\n                else&#123;\n                    it++;\n                &#125;\n            &#125;\n            ans.push_back(row);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "哈希表",
                "C++",
                "数组",
                "动态规划",
                "二分查找"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"二分查找\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "url": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "title": "Leetcode数组",
            "date_published": "2025-03-04T11:15:05.000Z",
            "content_html": "<p>本来想一道题一篇文，但是做的大多是简单题所以按模块归类好复习一点。</p>\n<h1 id=\"1232-缀点成线\"><a href=\"#1232-缀点成线\" class=\"headerlink\" title=\"1232.缀点成线\"></a>1232.缀点成线</h1><blockquote>\n<p>给定一个数组 coordinates ，其中 coordinates[i] &#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n<ul>\n<li>2 &lt;&#x3D; coordinates.length &lt;&#x3D; 1000</li>\n<li>coordinates[i].length &#x3D;&#x3D; 2</li>\n<li>-10^4 &lt;&#x3D; coordinates[i][0], coordinates[i][1] &lt;&#x3D; 10^4</li>\n<li>coordinates 中不含重复的点</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我本来是想着soeasy，用y&#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…</p>\n<p>那么就不使用斜率，而是使用<strong>斜率交叉乘法</strong>：如果所有点都在同一条直线上，那么<strong>对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等</strong>。也就是<code>(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)</code>。为避免除法带来的浮点误差，用<strong>交叉相乘</strong>验证更好。<br><em><strong>并且注意！</strong></em><br>因为我的验证方法需要三个点，但是这道题有可<code>coordinates,length=2</code>的情况，那就直接返回true，因为<strong>两点确定一条直线</strong>。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;\n        int x1,y1,x2,y2;\n        x1=coordinates[0][0];\n        y1=coordinates[0][1];\n        x2=coordinates[1][0];\n        y2=coordinates[1][1];\n        if(coordinates.size()==2)&#123;\n            return true;\n        &#125;\n        for(int i=2;i&lt;coordinates.size();i++)&#123;\n            int x3=coordinates[i][0];\n            int y3=coordinates[i][1];\n            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2597-美丽子集的数目\"><a href=\"#2597-美丽子集的数目\" class=\"headerlink\" title=\"2597.美丽子集的数目\"></a>2597.美丽子集的数目</h1><blockquote>\n<p>给你一个由正整数组成的数组 nums 和一个 正 整数 k 。<br>如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。<br>返回数组 nums 中 非空 且 美丽 的子集数目。<br>nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 18</li>\n<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>涉及<strong>子集</strong>相关问题，一般有两种方法：</p>\n<ul>\n<li>回溯</li>\n<li>位运算<br>本题选择<strong>回溯</strong>算法。因为该方法可在生成子集时<strong>剪枝</strong>。</li>\n</ul>\n<p>假设 nums &#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：</p>\n<pre><code>          dfs(0)\n        /        \\\n    不选2        选2\n     / \\         /  \\\n  不选4  选4   不选4  选4\n  ...\n</code></pre>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int ans=0;\n    void dfs(int index,vector&lt;int&gt;&amp; nums,unordered_map&lt;int,int&gt;&amp; freq,int k)&#123;\n        if(index==nums.size())&#123;\n            ans++;\n            return;\n        &#125;\n        dfs(index+1,nums,freq,k);\n        if(freq[nums[index]-k]==0 &amp;&amp; freq[nums[index]+k]==0)&#123;\n            freq[nums[index]]++;\n            dfs(index+1,nums,freq,k);\n            freq[nums[index]]--;\n        &#125;\n    &#125;\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int,int&gt; freq;\n        dfs(0,nums,freq,k);\n        return ans-1;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2070-每一个查询的最大美丽值\"><a href=\"#2070-每一个查询的最大美丽值\" class=\"headerlink\" title=\"2070.每一个查询的最大美丽值\"></a>2070.每一个查询的最大美丽值</h1><p>又美丽了家人们🤣</p>\n<blockquote>\n<p>给你一个二维整数数组 items ，其中 items[i] &#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。<br>同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。<br>请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>-1 &lt;&#x3D; items.length, queries.length &lt;&#x3D; 105<br>-items[i].length &#x3D;&#x3D; 2<br>-1 &lt;&#x3D; pricei, beautyi, queries[j] &lt;&#x3D; 109</p>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>首先复习一下二分查找，我又忘了咋写。<a href=\"https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/\">另一篇</a>copy来的</p>\n<blockquote>\n<ul>\n<li>要查找的目标<code>target</code></li>\n<li>索引<code>index</code></li>\n<li>左、右指示符<code>left</code>、<code>right</code></li>\n<li>中间指示符<code>mid</code><br>主要思路就是计算<code>mid</code>的位置：<br>1️⃣<code>nums[mid] == target</code> 🤭找到了<br>2️⃣<code>nums[mid] &lt; target</code> → target在left的右边 → left右移 👉️left&#x3D;mid+1;<br>3️⃣<code>nums[mid] &gt; target</code> → target在right的左边 → right左移 👉️right&#x3D;mid-1;</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-cpp\">//形参：vector&lt;int&gt;nums,int target\nint left=0;\nint right=nums.size()-1;\nwhile(left&lt;=right)&#123;\n    int mid=left+(right-left)/2;\n    if(nums[mid]=target)&#123;\n        return mid;\n    &#125;\n    else if(nums[mid]&lt;target)&#123;\n        left=mid+1;\n    &#125;\n    else&#123;\n        right=mid-1;\n    &#125;\n    return index;\n&#125;\n</code></pre>\n<h3 id=\"本题思路\"><a href=\"#本题思路\" class=\"headerlink\" title=\"本题思路\"></a>本题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a><em><strong>方法一</strong></em></h4><p>完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        vector&lt;int&gt; answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int maxnum=0;\n            for(int i=0;i&lt;items.size();i++)&#123;\n                if(items[i][0]&lt;=target)&#123;\n                    maxnum=max(maxnum,items[i][1]);\n                &#125;\n            &#125;\n            answer[j]=maxnum;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a><em><strong>方法二</strong></em></h4><p>老老实实用二分。注意：二分查找的前提是<strong>有序</strong>。</p>\n<ul>\n<li>先按照price递增排序;</li>\n<li>定义美丽数组;</li>\n<li>遍历items:<strong>存储当前遍历到的最大美丽值</strong>;</li>\n<li>定义答案数组;</li>\n<li>遍历querties：<strong>二分查找</strong></li>\n</ul>\n<p>二分查找目标🤟<code>items[i][0] &lt;= queries[j]</code> 的最大 i<br>有点绕了，兄弟兄弟…</p>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        sort(items.begin(),items.end());\n        vector&lt;int&gt;maxbeauty(items.size());\n        maxbeauty[0]=items[0][1];\n        for(int i=1;i&lt;items.size();i++)&#123;\n            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);\n        &#125;\n        vector&lt;int&gt;answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int left=0;\n            int right=items.size()-1;\n            int index=-1;\n            while(left&lt;=right)&#123;\n                int mid=left+(right-left)/2;\n                if(items[mid][0]&lt;=target)&#123;\n                    index=mid;\n                    left=mid+1;\n                &#125;\n                else&#123;\n                    right=mid-1;\n                &#125;\n            &#125;\n            if(index!=-1)&#123;\n                answer[j]=maxbeauty[index];\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "数组",
                "C++",
                "哈希表",
                "动态规划",
                "二分查找"
            ]
        }
    ]
}
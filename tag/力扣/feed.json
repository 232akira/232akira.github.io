{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"力扣\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/03/17/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/",
            "url": "https://232akira.github.io/2025/03/17/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/",
            "title": "算法备忘录",
            "date_published": "2025-03-17T07:29:31.000Z",
            "content_html": "<h1 id=\"基础算法问题\"><a href=\"#基础算法问题\" class=\"headerlink\" title=\"基础算法问题\"></a>基础算法问题</h1><p>这些题听着老熟了，一到写起来就主打一个略有耳闻🫠</p>\n<h2 id=\"题目一览\"><a href=\"#题目一览\" class=\"headerlink\" title=\"题目一览\"></a>题目一览</h2><p>省流表👇️</p>\n<blockquote>\n<p>题目并非只有表中那几个，可在<a href=\"https://leetcode.cn/problemset/\">此页</a>自行筛选。</p>\n</blockquote>\n<h3 id=\"1️⃣数组与数学类\"><a href=\"#1️⃣数组与数学类\" class=\"headerlink\" title=\"1️⃣数组与数学类\"></a><em><strong>1️⃣数组与数学类</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体 &#x2F; 要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">杨辉三角</td>\n<td align=\"center\"><code>[118/119]</code></td>\n<td align=\"center\">一维数组</td>\n</tr>\n<tr>\n<td align=\"center\">斐波那契数列</td>\n<td align=\"center\"><code>[509]</code></td>\n<td align=\"center\">爬楼梯问题<code>[70]</code>&#x2F;递归&#x2F;迭代&#x2F;动态规划</td>\n</tr>\n<tr>\n<td align=\"center\">两数之和</td>\n<td align=\"center\"><code>[1]</code></td>\n<td align=\"center\">哈希表优化时间复杂度到O(n)</td>\n</tr>\n<tr>\n<td align=\"center\">合并两个有序数组</td>\n<td align=\"center\"><code>[88]</code></td>\n<td align=\"center\">原地合并（从后向前填充）</td>\n</tr>\n<tr>\n<td align=\"center\">最大子数组和</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">动态规划</td>\n</tr>\n</tbody></table>\n<h3 id=\"2️⃣字符串操作类\"><a href=\"#2️⃣字符串操作类\" class=\"headerlink\" title=\"2️⃣字符串操作类\"></a><em><strong>2️⃣字符串操作类</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">反转字符串</td>\n<td align=\"center\"><code>[344]</code></td>\n<td align=\"center\">原地修改（双指针）</td>\n</tr>\n<tr>\n<td align=\"center\">有效的括号</td>\n<td align=\"center\"><code>[20]</code></td>\n<td align=\"center\">用栈实现括号匹配</td>\n</tr>\n<tr>\n<td align=\"center\">最长公共前缀</td>\n<td align=\"center\"><code>[14]</code></td>\n<td align=\"center\">纵向扫描&#x2F;分治</td>\n</tr>\n<tr>\n<td align=\"center\">字符串转整数</td>\n<td align=\"center\"><code>[8]</code></td>\n<td align=\"center\">处理边界（溢出&#x2F;符号&#x2F;空格）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3️⃣链表类\"><a href=\"#3️⃣链表类\" class=\"headerlink\" title=\"3️⃣链表类\"></a><em><strong>3️⃣链表类</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">反转链表</td>\n<td align=\"center\"><code>[206]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">环形链表</td>\n<td align=\"center\"><code>[141]</code></td>\n<td align=\"center\">快慢指针判环</td>\n</tr>\n<tr>\n<td align=\"center\">合并两个有序链表</td>\n<td align=\"center\"><code>[21]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">删除链表倒数第N个节点</td>\n<td align=\"center\"><code>[19]</code></td>\n<td align=\"center\">一趟扫描</td>\n</tr>\n</tbody></table>\n<h3 id=\"4️⃣树与递归\"><a href=\"#4️⃣树与递归\" class=\"headerlink\" title=\"4️⃣树与递归\"></a><em><strong>4️⃣树与递归</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">二叉树的最大深度</td>\n<td align=\"center\"><code>[104]</code></td>\n<td align=\"center\">迭代&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">对称二叉树</td>\n<td align=\"center\"><code>[101]</code></td>\n<td align=\"center\">迭代（队列&#x2F;栈）&#x2F;递归</td>\n</tr>\n<tr>\n<td align=\"center\">路径总和</td>\n<td align=\"center\"><code>[112]</code></td>\n<td align=\"center\">动回溯法</td>\n</tr>\n</tbody></table>\n<h3 id=\"5️⃣动态规划\"><a href=\"#5️⃣动态规划\" class=\"headerlink\" title=\"5️⃣动态规划\"></a><em><strong>5️⃣动态规划</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">打家劫舍</td>\n<td align=\"center\"><code>[198]</code></td>\n<td align=\"center\">状态转移方程推导</td>\n</tr>\n<tr>\n<td align=\"center\">零钱兑换</td>\n<td align=\"center\"><code>[322]</code></td>\n<td align=\"center\">完全背包问题解法</td>\n</tr>\n<tr>\n<td align=\"center\">最长递增子序列</td>\n<td align=\"center\"><code>[300]</code></td>\n<td align=\"center\">O(nlogn)优化解法</td>\n</tr>\n</tbody></table>\n<h3 id=\"6️⃣排序与查找\"><a href=\"#6️⃣排序与查找\" class=\"headerlink\" title=\"6️⃣排序与查找\"></a><em><strong>6️⃣排序与查找</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\"><code>力扣排序题均可</code></td>\n<td align=\"center\">手写递归和非递归版本</td>\n</tr>\n<tr>\n<td align=\"center\">二分查找</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">处理边界条件（左闭右闭&#x2F;左闭右开）</td>\n</tr>\n<tr>\n<td align=\"center\">寻找峰值</td>\n<td align=\"center\"><code>[53]</code></td>\n<td align=\"center\">二分法的特殊应用</td>\n</tr>\n</tbody></table>\n<h3 id=\"7️⃣其他高频\"><a href=\"#7️⃣其他高频\" class=\"headerlink\" title=\"7️⃣其他高频\"></a><em><strong>7️⃣其他高频</strong></em></h3><table>\n<thead>\n<tr>\n<th align=\"center\">题目</th>\n<th align=\"center\">力扣题号</th>\n<th align=\"center\">变体&#x2F;要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">LRU缓存</td>\n<td align=\"center\"><code>[146]</code></td>\n<td align=\"center\">手写递归和非递归版本</td>\n</tr>\n<tr>\n<td align=\"center\">实现队列&#x2F;栈</td>\n<td align=\"center\"><code>[232/225]</code></td>\n<td align=\"center\">处理边界条件（左闭右闭&#x2F;左闭右开）</td>\n</tr>\n<tr>\n<td align=\"center\">汉明距离</td>\n<td align=\"center\"><code>[461]</code></td>\n<td align=\"center\">二分法的特殊应用</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "算法",
                "力扣",
                "记录"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "url": "https://232akira.github.io/2025/03/12/%E4%B8%93%E9%A2%981-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
            "title": "专题1️⃣ 滑动窗口",
            "date_published": "2025-03-12T10:20:15.000Z",
            "content_html": "<p>今天照例每日一题，然后麻溜的看题解，发现又是一道滑动窗口题。所以开个专题归类一下。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><h2 id=\"基础算法精讲03-滑动窗口\"><a href=\"#基础算法精讲03-滑动窗口\" class=\"headerlink\" title=\"基础算法精讲03-滑动窗口\"></a><a href=\"https://www.bilibili.com/video/BV1hd4y1r7Gq/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">基础算法精讲03-滑动窗口</a></h2><p>👉️双指针的应用场景：</p>\n<ul>\n<li>单调性</li>\n</ul>\n<h1 id=\"713-乘积小于K的子数组\"><a href=\"#713-乘积小于K的子数组\" class=\"headerlink\" title=\"713.乘积小于K的子数组\"></a>713.乘积小于K的子数组</h1><blockquote>\n<p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p>\n</blockquote>\n<blockquote>\n<p>提示: </p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; 106</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3.无重复字符的最长子串\"></a>3.无重复字符的最长子串</h1><blockquote>\n<p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</li>\n<li>s 由英文字母、数字、符号和空格组成</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h1><blockquote>\n<p>给定一个含有n个正整数的数组和一个正整数target。<br>找出该数组中满足其总和大于等于target的长度最小的子数组 [numsl, numsl+1, …, numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; target &lt;&#x3D; 109</li>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>进阶：</p>\n<ul>\n<li>如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>在数组字串问题中，经常会用到<strong>双指针</strong>这一技巧。</p>\n<ol>\n<li><p>暴力方法 时间复杂度<code>O(n^2)</code></p>\n</li>\n<li><p>枚举右端点，收缩左端点 时间复杂度<code>O(n)</code></p>\n</li>\n</ol>\n<ul>\n<li>拿到数组的长度n</li>\n<li>答案ans初始化为n+1或者更大</li>\n<li>总和sum初始化为0</li>\n<li>左端点left初始化为0</li>\n<li>right右端点for循环(0~n-1)：sum+&#x3D;nums[right]</li>\n<li>for嵌套while(s-nums[left]):此时子数组的和减去左端点依旧&gt;&#x3D;target：sum-&#x3D;nums[left];left+&#x3D;1;(移掉左端点)</li>\n<li>如果sum&gt;&#x3D;target:更新答案最小值 ans&#x3D;min(ans,right-left+1)</li>\n<li>返回ans（&lt;&#x3D;n返回ans，否则返回0）</li>\n</ul>\n<p><em><strong>注意：此题不需要判断left和right两者间的大小关系。</strong></em><br>因为当left&#x3D;right时，s-nums[left]&#x3D;0，一定比target小（target为正整数），不满足while条件。</p>\n<ol start=\"3\">\n<li>在「2」的基础上，把ans的更新写到while里面</li>\n</ol>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;\n        int n,ans,sum,left;\n        n=nums.size();\n        ans=n+1;\n        sum=left=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            // sum+=nums[i];\n            // while(sum-nums[left]&gt;=target)&#123;\n            //     sum-=nums[left];\n            //     left++;\n            // &#125;\n            // if(sum&gt;=target)&#123;\n            //     ans=min(ans,i-left+1);\n            // &#125;\n            while(sum&gt;=target)&#123;\n                ans=min(ans,i-left+1);\n                sum-=nums[left++];\n            &#125;\n        &#125;\n        return ans&lt;=n?ans:0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><p>今天字符串也要美丽了🆘</p>\n<blockquote>\n<p>一个整数num的k美丽值定义为num中符合以下条件的子字符串数目：</p>\n<ul>\n<li>子字符串长度为k。</li>\n<li>子字符串能整除num。<br>给你整数num和k，请你返回num的k美丽值。<br>注意：<br>允许有前缀0。<br>0不能整除任何值。<br>一个子字符串是一个字符串里的连续一段字符序列。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= num &lt;= 109</code></li>\n<li><code>1 &lt;= k &lt;= num.length</code> （将 num 视为字符串）</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我觉得这道的要点就是子串怎么得，剩下的就好判断了。偏偏我就栽在这儿了😅</p>\n<ul>\n<li><strong>int转string</strong> <code>to_string()</code>注意此函数需要赋给个string变量</li>\n<li><strong>string转int</strong> <code>stoi()</code>同样，需要赋给个int变量</li>\n<li><strong>获取长度为k的字符串</strong> <code>substr(i,k)</code>距离c++学这个函数已经过了一两年了，忘的一干二净，趁此好机会来总结一下。</li>\n</ul>\n<p>👇️ <em><strong>获取子串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>substr(pos,len)</code></td>\n<td align=\"center\">从pos开始，提取长度为len的子串</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>查找字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>find(str,pos)</code></td>\n<td align=\"center\">在pos之后查找str的位置，找不到返回string::pos</td>\n</tr>\n<tr>\n<td align=\"center\"><code>rfind(str,pos)</code></td>\n<td align=\"center\">逆向查找str,从pos开始向前找</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_first_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的第一次出现</td>\n</tr>\n<tr>\n<td align=\"center\"><code>find_last_of(chars,pos)</code></td>\n<td align=\"center\">查找chars中的任意字符的最后一次出现</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>替换字符串</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>replace(pos,len,str)</code></td>\n<td align=\"center\">从pos开始，用str替换len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>erase(pos,len)</code></td>\n<td align=\"center\">删除从pos开始的len个字符</td>\n</tr>\n<tr>\n<td align=\"center\"><code>insert(pos,str)</code></td>\n<td align=\"center\">在pos位置插入str</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>大小写转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>toupper(c)</code></td>\n<td align=\"center\">将字符c转换为大写</td>\n</tr>\n<tr>\n<td align=\"center\"><code>tolower(c)</code></td>\n<td align=\"center\">将字符c转换为小写</td>\n</tr>\n</tbody></table>\n<p>👇️ <em><strong>数字与字符串转换</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">函数</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>to_string(num)</code></td>\n<td align=\"center\">把num转换为字符串</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stoi(str)</code></td>\n<td align=\"center\">把str转换为int</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stol(str)</code></td>\n<td align=\"center\">把str转换为long</td>\n</tr>\n<tr>\n<td align=\"center\"><code>stod(str)</code></td>\n<td align=\"center\">把str转换为double</td>\n</tr>\n</tbody></table>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int divisorSubstrings(int num, int k) &#123;\n        int cnt=0;\n        string str=to_string(num);\n        for(int i=0;i&lt;=str.size()-k;i++)&#123;\n            string ans=str.substr(i,k);\n            int answer=stoi(ans);\n            if(answer!=0 &amp;&amp; num%answer==0)&#123;\n                cnt++;\n            &#125;\n        &#125;\n        return cnt;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3305-元音辅音字符串计数Ⅰ\"><a href=\"#3305-元音辅音字符串计数Ⅰ\" class=\"headerlink\" title=\"3305.元音辅音字符串计数Ⅰ\"></a>3305.元音辅音字符串计数Ⅰ</h1><blockquote>\n<p>给你一个字符串word和一个非负整数 k。<br>返回word的子字符串中，每个元音字母（’a’、’e’、’i’、’o’、’u’）至少出现一次，并且恰好包含k个辅音字母的子字符串的总数。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>5 &lt;&#x3D; word.length &lt;&#x3D; 250</li>\n<li>word 仅由小写英文字母组成。</li>\n<li>0 &lt;&#x3D; k &lt;&#x3D; word.length - 5</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先试了试暴力😤循环套三层观感太差，不放上来。</p>\n<p><strong>正经解法</strong></p>\n<ul>\n<li>滑动窗口代替暴力循环</li>\n<li>哈希表统计元音出现次数</li>\n</ul>\n<p><strong>注意几个用法</strong><br><em><strong>1️⃣ 几个键值对容器</strong></em></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键值对容器</th>\n<th align=\"center\">实现方式</th>\n<th align=\"center\">键值</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">是否有序</th>\n<th align=\"center\">使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unordered_map</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找键对应的值</td>\n</tr>\n<tr>\n<td align=\"center\"><code>map</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键-值对</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要有序键值对</td>\n</tr>\n<tr>\n<td align=\"center\"><code>unordered_set</code></td>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">键</td>\n<td align=\"center\">平均O(1)</td>\n<td align=\"center\">无序</td>\n<td align=\"center\">快速查找元素是否存在</td>\n</tr>\n<tr>\n<td align=\"center\"><code>set</code></td>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">键</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">有序</td>\n<td align=\"center\">需要排序的集合</td>\n</tr>\n</tbody></table>\n<p><em><strong>2️⃣ 键值对容器+函数求的是什么？</strong></em></p>\n<ul>\n<li><code>unordered_map.size()</code>返回unordered_map中<strong>键值对的数量</strong>。</li>\n<li><code>unordered_set.count(x)</code>unordered_set中<strong>某个元素是否存在</strong>，返回1表示在，0表示不在。</li>\n</ul>\n<p>代码思路如下。这个方法时间空间上并非最优，后续需要调整思路。</p>\n<pre><code class=\"language-cpp\">定义n：word长度;\n定义unordered_map类型的vowel_cnt:元音出现次数;\n定义consonant_cnt:辅音个数;\n定义ans：统计最终答案;\n定义unordered_set类型的vowels:所有元音字母;\n定义左指针j=0;\n遍历word从下标0~word.size():\n    定义右元素right=word[i];\n    统计元音出现次数：\n        进行元/辅音计数;\n    当辅音数量超过k://收缩窗口左边界\n        定义左元素left=word[左指针];//取左边界字符\n        如果left是元音：\n            该元音出现次数--;\n            当元音的计数减少到0时：\n                将它从vowel_cnt中删除；\n        否则：\n            辅音个数--;\n        左指针右移;\n    如果包含所有元音且辅音个数为k:\n        //避免修改原窗口状态,思路整体与上半部分相同☝️\n        定义临时变量temp_vowel=vowel_cnt;\n        定义临时变量temp_consonant=consonant_cnt;\n        定义临时变量temp_j=j;\n        定义计数cnt=0;\n        当临时左下标&lt;=右下标:\n            如果包含所有临时元音且临时辅音个数为k:\n                cnt++;\n            否则:\n                退出该层循环;\n            定义c:word[临时左指针];\n            如果c是元音：\n                临时该元音出现次数--;\n                当临时元音的计数减少到0时：\n                    将它从临时vowel_cnt中删除;\n            否则:\n                临时辅音个数--;\n            临时左指针j右移;\n        ans+=cnt;\n返回ans;\n</code></pre>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int countOfSubstrings(string word, int k) &#123;\n        int len=word.size();\n        unordered_map&lt;char,int&gt;vowel_cnt;\n        int consonant_cnt=0;\n        int ans=0;\n        unordered_set&lt;int&gt;vowels=&#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;&#125;;\n        int j=0;\n        for(int i=0;i&lt;len;i++)&#123;\n            char right=word[i];\n            if(vowels.count(right))&#123;\n                vowel_cnt[right]++;\n            &#125;\n            else&#123;\n                consonant_cnt++;\n            &#125;\n            while(consonant_cnt&gt;k)&#123;\n                char left=word[j];\n                if(vowels.count(left))&#123;\n                    vowel_cnt[left]--;\n                    if(vowel_cnt[left]==0)&#123;\n                        vowel_cnt.erase(left);\n                    &#125;\n                &#125;\n                else&#123;\n                    consonant_cnt--;\n                &#125;\n                j++;\n            &#125;\n            if(vowel_cnt.size()==5 &amp;&amp; consonant_cnt==k)&#123;\n                unordered_map&lt;char,int&gt;temp_vowel=vowel_cnt;\n                int temp_consonant=consonant_cnt;\n                int temp_j=j;\n                int cnt=0;\n                while(temp_j&lt;=i)&#123;\n                    if(temp_vowel.size()==5 &amp;&amp; temp_consonant==k)&#123;\n                        cnt++;\n                    &#125;\n                    else&#123;\n                        break;\n                    &#125;\n                    int c=word[temp_j];\n                    if(vowels.count(c))&#123;\n                        temp_vowel[c]--;\n                        if(temp_vowel[c]==0)&#123;\n                            temp_vowel.erase(c);\n                        &#125;\n                    &#125;\n                    else&#123;\n                        temp_consonant--;\n                    &#125;\n                    temp_j++;\n                &#125;\n                ans+=cnt;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"3306-元音辅音字符串计数Ⅱ\"><a href=\"#3306-元音辅音字符串计数Ⅱ\" class=\"headerlink\" title=\"3306.元音辅音字符串计数Ⅱ\"></a>3306.元音辅音字符串计数Ⅱ</h1><p>不行，彻底懵了脑子转不动做梦都是元辅音😫先把copy的官方题解放这，过两天我再苟回来看。</p>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    long long countOfSubstrings(string word, int k) &#123;\n        set&lt;char&gt; vowels = &#123;&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;&#125;;\n        auto count = [&amp;](int m) -&gt; long long &#123;\n            int n = word.size(), consonants = 0;\n            long long res = 0;\n            map&lt;char, int&gt; occur;\n            for (int i = 0, j = 0; i &lt; n; i++) &#123;\n                while (j &lt; n &amp;&amp; (consonants &lt; m || occur.size() &lt; vowels.size())) &#123;\n                    if (vowels.count(word[j])) &#123;\n                        occur[word[j]]++;\n                    &#125; else &#123;\n                        consonants++;\n                    &#125;\n                    j++;\n                &#125;\n                if (consonants &gt;= m &amp;&amp; occur.size() == vowels.size()) &#123;\n                    res += n - j + 1;\n                &#125;\n                if (vowels.count(word[i])) &#123;\n                    occur[word[i]]--;\n                    if (occur[word[i]] == 0) &#123;\n                        occur.erase(word[i]);\n                    &#125;\n                &#125; else &#123;\n                    consonants--;\n                &#125;\n            &#125;\n            return res;\n        &#125;;\n        return count(k) - count(k + 1);\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "算法",
                "字符串",
                "滑动窗口",
                "力扣",
                "哈希表"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "url": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "title": "Leetcode链表",
            "date_published": "2025-03-06T02:25:28.000Z",
            "content_html": "<p>链表这东西真的学一阵忘一阵😂</p>\n<h1 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h1><h2 id=\"结构定义\"><a href=\"#结构定义\" class=\"headerlink\" title=\"结构定义\"></a>结构定义</h2><ul>\n<li>节点结构 <code>ListNode</code></li>\n<li>值 <code>data</code></li>\n<li>指向下一个节点的指针 <code>next</code></li>\n</ul>\n<pre><code class=\"language-cpp\">struct ListNode&#123;\n    int data;\n    ListNode* next;\n    ListNode(int x):data(x),next(nullptr)&#123;&#125;\n&#125;Node;\n</code></pre>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h3 id=\"创建链表\"><a href=\"#创建链表\" class=\"headerlink\" title=\"创建链表\"></a>创建链表</h3><p>定义单链表类，封装基本操作。下面的几个操作都在public里~</p>\n<pre><code class=\"language-cpp\">class LinkedList&#123;\npublic:\n    ListNode* head;\n    LinkedList():head(nullptr);\n&#125;\n</code></pre>\n<h3 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h3><ul>\n<li>头插法:新节点加到链表头部</li>\n</ul>\n<pre><code class=\"language-cpp\">void insertAtHead(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    newNode-&gt;next=head;\n    head=newNode;\n&#125;\n</code></pre>\n<ul>\n<li>尾插法：:新节点加到链表尾部</li>\n</ul>\n<pre><code class=\"language-cpp\">void insertAtTail(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    if(!head)&#123;\n        head=newNode;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    temp-&gt;next=newNode;\n&#125;\n</code></pre>\n<h3 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h3><pre><code class=\"language-cpp\">void deleteNode(int data)&#123;\n    if(!head)&#123;\n        return;\n    &#125;\n    if(head-&gt;data==data)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;val !=val)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    if(temp-&gt;next)&#123;\n        ListNode* delNode=temp-&gt;next;\n        temp-&gt;next=temp-&gt;next-&gt;next;\n        delete delNode;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"修改节点\"><a href=\"#修改节点\" class=\"headerlink\" title=\"修改节点\"></a>修改节点</h3><pre><code class=\"language-cpp\">void updateNode(int oldData,newData)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-data==oldData)&#123;\n            temp-&gt;data==oldData;\n            return;\n        &#125;\n        temp=temp-&gt;next;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h3><pre><code class=\"language-cpp\">bool searchNode(int data)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-&gt;data==data)&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h3 id=\"打印链表\"><a href=\"#打印链表\" class=\"headerlink\" title=\"打印链表\"></a>打印链表</h3><pre><code class=\"language-cpp\">void printList()&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        cout&lt;&lt;temp-&gt;val&lt;&lt;&quot;-&gt;&quot;;\n        temp=temp-&gt;next;\n    &#125;\n    cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl;\n&#125;\n</code></pre>\n<h3 id=\"释放链表内存\"><a href=\"#释放链表内存\" class=\"headerlink\" title=\"释放链表内存\"></a>释放链表内存</h3><pre><code class=\"language-cpp\">~LinkedList()&#123;\n    while(head)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21.合并两个有序链表\"></a>21.合并两个有序链表</h1><blockquote>\n<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>提示：</p>\n<ul>\n<li>两个链表的节点数目范围是 [0, 50]</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>l1和l2均按非递减顺序排列</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>👉️ <em><strong>终止条件</strong></em>：有链表为空</p>\n<ul>\n<li>list1为空，合并结果直接为list2</li>\n<li>list2为空，合并结果直接为list1</li>\n</ul>\n<p>👉️ <em><strong>递归调用</strong></em>：小的打头，每一步递归后返回的值链接到链表末尾</p>\n<ul>\n<li>如果<code>list1节点的值 &lt; list2</code>：寻找list1后面节点还有没有也比list2小的节点</li>\n</ul>\n<pre><code>让list1-&gt;next接上递归后合并的结果；\n返回当前较小的节点list1;\n</code></pre>\n<ul>\n<li>else：寻找list2后面节点还有没有也比list1小的节点</li>\n</ul>\n<pre><code>让list2-&gt;next接上递归后合并的结果；\n返回当前较小的节点list2;\n</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        if(list1==NULL || list2==NULL)&#123;\n            return list1==NULL ? list2:list1;\n        &#125;\n        if(list1-&gt;val &lt; list2-&gt;val)&#123;\n            list1-&gt;next = mergeTwoLists(list1-&gt;next,list2);\n            return list1;\n        &#125;\n        else&#123;\n            list2-&gt;next = mergeTwoLists(list1,list2-&gt;next);\n            return list2;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206.反转链表\"></a>206.反转链表</h1><p>又是一道经典中的经典题🙀</p>\n<blockquote>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点的数目范围是 [0, 5000]</li>\n<li>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>👉️ <em><strong>链表反转的本质</strong></em></p>\n<ul>\n<li>让当前节点<code>cur</code>指向它的前一个节点<code>pre</code>。而不是后一个节点next</li>\n<li>更新<code>pre</code>和<code>cur</code>，直到cur为空。此时pre为新的head节点</li>\n</ul>\n<p>这里模拟一下过程。<br>👉️ <em><strong>假设存在链表：1-&gt;2-&gt;3-&gt;4-&gt;nullptr</strong></em><br>初始状态：</p>\n<ul>\n<li>pre &#x3D; nullptr</li>\n<li>cur &#x3D; head<br>那么逐步变化如下：</li>\n</ul>\n<p>| <code>cur</code> | <code>tmp(cur-&gt;next)</code> | <code>cur-&gt;next=pre</code> | <code>pre=cur</code> | <code>cur=tmpS</code> |<br>| :–: | :–: | :–: |<br>| 1 | 2 | <code>1-&gt;nullptr</code> | <code>pre=1</code> | <code>cur=2</code> |<br>| 2 | 3 | <code>2-&gt;1</code> | <code>pre=2</code> | <code>cur=3</code> |<br>| 3 | 4 | <code>3-&gt;2</code> | <code>pre=3</code> | <code>cur=4</code> |<br>| 4 | nullptr | <code>4-&gt;3</code> | <code>pre=4</code> | <code>cur=nullptr</code>（结束） |</p>\n<p>最终pre变成4，即新的链表头头。<br><strong>此时链表结构为：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; nullptr</strong>。</p>\n<p>👉️ <em><strong>简单来说，关键步骤是</strong></em><br>1️⃣记录下一个节点<br>2️⃣反转指向<br>3️⃣更新pre（当前节点变成新的头）<br>4️⃣继续遍历</p>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* reverseList(ListNode* head) &#123;\n        ListNode* pre=nullptr;\n        ListNode* cur=head;\n        while(cur!=nullptr)&#123;\n            ListNode* tmp=cur-&gt;next;\n            cur-&gt;next=pre;\n            pre=cur;\n            cur=tmp;\n        &#125;\n        return pre;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2-两数相加\"><a href=\"#2-两数相加\" class=\"headerlink\" title=\"2.两数相加\"></a>2.两数相加</h1><blockquote>\n<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>每个链表中的节点数在范围 [1, 100] 内</li>\n<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>这道题着实难倒我🥹乖乖去看<a href=\"https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/\">题解</a></p>\n<ol>\n<li><p>链表<strong>逆序</strong>存储数字</p>\n</li>\n<li><p><code>两个链表的节点值 + 进位值</code>如果记为<code>a</code>：</p>\n</li>\n</ol>\n<ul>\n<li><code>a % 10</code>为当前节点保存的数位</li>\n<li><code>a / 10</code>为新的进位值</li>\n</ul>\n<ol start=\"3\">\n<li>递归思路</li>\n</ol>\n<ul>\n<li>如果l1、l2都为空且carry&#x3D;0，递归结束</li>\n<li>定义sum&#x3D;carry</li>\n<li>如果l1不为空，sum+&#x3D;l1-&gt;val，l1&#x3D;l1-&gt;next</li>\n<li>同理，如果l2不为空，sum+&#x3D;l2-&gt;val，l2&#x3D;l2-&gt;next</li>\n<li>new一个当前节点node：<code>ListNode* node=new ListNode(sum%10)</code></li>\n<li>递归调用处理node-&gt;next</li>\n<li>返回当前节点node</li>\n</ul>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2,int carry=0) &#123;\n        if(l1==nullptr &amp;&amp; l2==nullptr &amp;&amp; carry==0)&#123;\n            return nullptr;\n        &#125;\n        int sum=carry;\n        if(l1!=nullptr)&#123;\n            sum+=l1-&gt;val;\n            l1=l1-&gt;next;\n        &#125;\n        if(l2!=nullptr)&#123;\n            sum+=l2-&gt;val;\n            l2=l2-&gt;next;\n        &#125;\n        ListNode* node=new ListNode(sum%10);\n        carry=sum/10;\n        node-&gt;next=addTwoNumbers(l1,l2,carry);\n        return node;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"83-删除排序链表中的重复元素\"><a href=\"#83-删除排序链表中的重复元素\" class=\"headerlink\" title=\"83.删除排序链表中的重复元素\"></a>83.删除排序链表中的重复元素</h1><blockquote>\n<p>给定一个已排序的链表的头head，删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>链表中节点数目在范围 [0, 300] 内</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>题目数据保证链表已经按升序排列</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ol>\n<li>【如果】头节点&#x3D;空：直接返回该节点</li>\n<li>初始化一个当前节点变量&#x3D;头节点</li>\n<li>【只要】当前<code>节点-&gt;next</code>不为空</li>\n</ol>\n<ul>\n<li>「如果」<code>当前节点-&gt;next的值</code>&#x3D;<code>当前节点的值</code>： <code>当前节点-&gt;next</code>&#x3D;<code>当前节点-&gt;next-&gt;next</code></li>\n<li>「否则」<code>当前节点</code>&#x3D;<code>当前节点-&gt;next</code></li>\n</ul>\n<ol start=\"4\">\n<li>返回头节点</li>\n</ol>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* deleteDuplicates(ListNode* head) &#123;\n        if(head==nullptr)&#123;\n            return head;\n        &#125;\n        ListNode* cur=head;\n        while(cur-&gt;next!=nullptr)&#123;\n            if(cur-&gt;next-&gt;val==cur-&gt;val)&#123;\n                cur-&gt;next=cur-&gt;next-&gt;next;\n            &#125;\n            else&#123;\n                cur=cur-&gt;next;\n            &#125;\n        &#125;\n        return head;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "算法",
                "力扣",
                "链表"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "url": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "title": "Leetcode数组",
            "date_published": "2025-03-04T11:15:05.000Z",
            "content_html": "<h1 id=\"912-排序数组\"><a href=\"#912-排序数组\" class=\"headerlink\" title=\"912.排序数组\"></a>912.排序数组</h1><blockquote>\n<p>给你一个整数数组 nums，请你将该数组升序排列。<br>你必须在 不使用任何内置函数 的情况下解决问题，时间复杂度为 O(nlog(n))，并且空间复杂度尽可能小。</p>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先来总结一下</p>\n<h3 id=\"十大排序算法\"><a href=\"#十大排序算法\" class=\"headerlink\" title=\"十大排序算法~\"></a><a href=\"https://www.runoob.com/w3cnote/ten-sorting-algorithm.html\">十大排序算法</a>~</h3><table>\n<thead>\n<tr>\n<th align=\"center\">排序算法</th>\n<th align=\"center\">「平均」时间复杂度</th>\n<th align=\"center\">「最坏」时间复杂度</th>\n<th align=\"center\">「最好」时间复杂度</th>\n<th align=\"center\">空间复杂度</th>\n<th align=\"center\">稳定性</th>\n<th align=\"center\">适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>冒泡排序</strong></td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据量小、基本有序</td>\n</tr>\n<tr>\n<td align=\"center\">选择排序</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">数据量小</td>\n</tr>\n<tr>\n<td align=\"center\">插入排序</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据量小、基本有序</td>\n</tr>\n<tr>\n<td align=\"center\">希尔排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlog^2n)</td>\n<td align=\"center\">O(nlog^2n)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">大数据</td>\n</tr>\n<tr>\n<td align=\"center\">归并排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">链表排序</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>快速排序</strong></td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">处理大数据最常用</td>\n</tr>\n<tr>\n<td align=\"center\">堆排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n<td align=\"center\">优先队列</td>\n</tr>\n<tr>\n<td align=\"center\">计数排序</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(k)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据范围较小、整数分布集中</td>\n</tr>\n<tr>\n<td align=\"center\">桶排序</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">数据分布均匀</td>\n</tr>\n<tr>\n<td align=\"center\">基数排序</td>\n<td align=\"center\">O(n×k)</td>\n<td align=\"center\">O(n×k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">O(n+k)</td>\n<td align=\"center\">稳定</td>\n<td align=\"center\">非比较排序</td>\n</tr>\n</tbody></table>\n<h3 id=\"其他总结\"><a href=\"#其他总结\" class=\"headerlink\" title=\"其他总结\"></a>其他总结</h3><p>1️⃣按稳定性分类<br>在排序前后，相等元素的相对顺序是否保持不变，如果相对顺序不变，则该排序算法是稳定的，否则是不稳定的。</p>\n<ul>\n<li><strong>稳定排序</strong>：冒泡&#x2F;插入&#x2F;归并&#x2F;基数</li>\n<li><strong>不稳定排序</strong>：选择&#x2F;快速&#x2F;堆</li>\n</ul>\n<p>2️⃣排序算法优劣的<a href=\"https://blog.csdn.net/2203_75646004/article/details/135172906\">衡量标准</a>：<br>🔹 <strong>时间复杂度</strong> 排序速度（比较&amp;移动次数）<br>🔹 <strong>空间复杂度</strong> 占内存辅助空间的大小<br>🔹 <strong>稳定性</strong> A与B的关键字相等，排序后A、B的先后次序保持不变</p>\n<p>3️⃣按排序类别分类</p>\n<ul>\n<li><strong>插入</strong>：插入&#x2F;希尔</li>\n<li><strong>选择</strong>：选择&#x2F;堆</li>\n<li><strong>交换</strong>：冒泡&#x2F;快速</li>\n<li><strong>归并</strong>：归并</li>\n<li><strong>基数</strong>：基数</li>\n</ul>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>\n</code></pre>\n<h1 id=\"1232-缀点成线\"><a href=\"#1232-缀点成线\" class=\"headerlink\" title=\"1232.缀点成线\"></a>1232.缀点成线</h1><blockquote>\n<p>给定一个数组 coordinates ，其中 coordinates[i] &#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n<ul>\n<li>2 &lt;&#x3D; coordinates.length &lt;&#x3D; 1000</li>\n<li>coordinates[i].length &#x3D;&#x3D; 2</li>\n<li>-10^4 &lt;&#x3D; coordinates[i][0], coordinates[i][1] &lt;&#x3D; 10^4</li>\n<li>coordinates 中不含重复的点</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我本来是想着soeasy，用y&#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…</p>\n<p>那么就不使用斜率，而是使用<strong>斜率交叉乘法</strong>：如果所有点都在同一条直线上，那么<strong>对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等</strong>。也就是<code>(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)</code>。为避免除法带来的浮点误差，用<strong>交叉相乘</strong>验证更好。<br><em><strong>并且注意！</strong></em><br>因为我的验证方法需要三个点，但是这道题有可<code>coordinates,length=2</code>的情况，那就直接返回true，因为<strong>两点确定一条直线</strong>。</p>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;\n        int x1,y1,x2,y2;\n        x1=coordinates[0][0];\n        y1=coordinates[0][1];\n        x2=coordinates[1][0];\n        y2=coordinates[1][1];\n        if(coordinates.size()==2)&#123;\n            return true;\n        &#125;\n        for(int i=2;i&lt;coordinates.size();i++)&#123;\n            int x3=coordinates[i][0];\n            int y3=coordinates[i][1];\n            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2597-美丽子集的数目\"><a href=\"#2597-美丽子集的数目\" class=\"headerlink\" title=\"2597.美丽子集的数目\"></a>2597.美丽子集的数目</h1><blockquote>\n<p>给你一个由正整数组成的数组 nums 和一个 正 整数 k 。<br>如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。<br>返回数组 nums 中 非空 且 美丽 的子集数目。<br>nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 18</li>\n<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>涉及<strong>子集</strong>相关问题，一般有两种方法：</p>\n<ul>\n<li>回溯</li>\n<li>位运算<br>本题选择<strong>回溯</strong>算法。因为该方法可在生成子集时<strong>剪枝</strong>。</li>\n</ul>\n<p>假设 nums &#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：</p>\n<pre><code>          dfs(0)\n        /        \\\n    不选2        选2\n     / \\         /  \\\n  不选4  选4   不选4  选4\n  ...\n</code></pre>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int ans=0;\n    void dfs(int index,vector&lt;int&gt;&amp; nums,unordered_map&lt;int,int&gt;&amp; freq,int k)&#123;\n        if(index==nums.size())&#123;\n            ans++;\n            return;\n        &#125;\n        dfs(index+1,nums,freq,k);\n        if(freq[nums[index]-k]==0 &amp;&amp; freq[nums[index]+k]==0)&#123;\n            freq[nums[index]]++;\n            dfs(index+1,nums,freq,k);\n            freq[nums[index]]--;\n        &#125;\n    &#125;\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int,int&gt; freq;\n        dfs(0,nums,freq,k);\n        return ans-1;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2070-每一个查询的最大美丽值\"><a href=\"#2070-每一个查询的最大美丽值\" class=\"headerlink\" title=\"2070.每一个查询的最大美丽值\"></a>2070.每一个查询的最大美丽值</h1><p>又美丽了家人们🤣</p>\n<blockquote>\n<p>给你一个二维整数数组 items ，其中 items[i] &#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。<br>同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。<br>请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>-1 &lt;&#x3D; items.length, queries.length &lt;&#x3D; 105<br>-items[i].length &#x3D;&#x3D; 2<br>-1 &lt;&#x3D; pricei, beautyi, queries[j] &lt;&#x3D; 109</p>\n</blockquote>\n<h2 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>首先复习一下二分查找，我又忘了咋写。<a href=\"https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/\">另一篇</a>copy来的</p>\n<blockquote>\n<ul>\n<li>要查找的目标<code>target</code></li>\n<li>索引<code>index</code></li>\n<li>左、右指示符<code>left</code>、<code>right</code></li>\n<li>中间指示符<code>mid</code><br>主要思路就是计算<code>mid</code>的位置：<br>1️⃣<code>nums[mid] == target</code> 🤭找到了<br>2️⃣<code>nums[mid] &lt; target</code> → target在left的右边 → left右移 👉️left&#x3D;mid+1;<br>3️⃣<code>nums[mid] &gt; target</code> → target在right的左边 → right左移 👉️right&#x3D;mid-1;</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-cpp\">//形参：vector&lt;int&gt;nums,int target\nint left=0;\nint right=nums.size()-1;\nwhile(left&lt;=right)&#123;\n    int mid=left+(right-left)/2;\n    if(nums[mid]=target)&#123;\n        return mid;\n    &#125;\n    else if(nums[mid]&lt;target)&#123;\n        left=mid+1;\n    &#125;\n    else&#123;\n        right=mid-1;\n    &#125;\n    return index;\n&#125;\n</code></pre>\n<h3 id=\"本题思路\"><a href=\"#本题思路\" class=\"headerlink\" title=\"本题思路\"></a>本题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a><em><strong>方法一</strong></em></h4><p>完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        vector&lt;int&gt; answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int maxnum=0;\n            for(int i=0;i&lt;items.size();i++)&#123;\n                if(items[i][0]&lt;=target)&#123;\n                    maxnum=max(maxnum,items[i][1]);\n                &#125;\n            &#125;\n            answer[j]=maxnum;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a><em><strong>方法二</strong></em></h4><p>老老实实用二分。注意：二分查找的前提是<strong>有序</strong>。</p>\n<ul>\n<li>先按照price递增排序;</li>\n<li>定义美丽数组;</li>\n<li>遍历items:<strong>存储当前遍历到的最大美丽值</strong>;</li>\n<li>定义答案数组;</li>\n<li>遍历querties：<strong>二分查找</strong></li>\n</ul>\n<p>二分查找目标🤟<code>items[i][0] &lt;= queries[j]</code> 的最大 i<br>有点绕了，兄弟兄弟…</p>\n<h2 id=\"完整代码-3\"><a href=\"#完整代码-3\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        sort(items.begin(),items.end());\n        vector&lt;int&gt;maxbeauty(items.size());\n        maxbeauty[0]=items[0][1];\n        for(int i=1;i&lt;items.size();i++)&#123;\n            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);\n        &#125;\n        vector&lt;int&gt;answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int left=0;\n            int right=items.size()-1;\n            int index=-1;\n            while(left&lt;=right)&#123;\n                int mid=left+(right-left)/2;\n                if(items[mid][0]&lt;=target)&#123;\n                    index=mid;\n                    left=mid+1;\n                &#125;\n                else&#123;\n                    right=mid-1;\n                &#125;\n            &#125;\n            if(index!=-1)&#123;\n                answer[j]=maxbeauty[index];\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2269-找到一个数字的-K-美丽值\"><a href=\"#2269-找到一个数字的-K-美丽值\" class=\"headerlink\" title=\"2269.找到一个数字的 K 美丽值\"></a>2269.找到一个数字的 K 美丽值</h1><blockquote>\n<p>给你一个下标从0开始的整数数组nums。对于每个下标i（1 &lt;&#x3D; i &lt;&#x3D; nums.length - 2），nums[i] 的美丽值等于：<br>2，对于所有 0 &lt;&#x3D; j &lt; i 且 i &lt; k &lt;&#x3D; nums.length - 1 ，满足 nums[j] &lt; nums[i] &lt; nums[k]<br>1，如果满足 nums[i - 1] &lt; nums[i] &lt; nums[i + 1] ，且不满足前面的条件<br>0，如果上述条件全部不满足<br>返回符合 1 &lt;&#x3D; i &lt;&#x3D; nums.length - 2 的所有 nums[i] 的美丽值的总和。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>3 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-4\"><a href=\"#解题思路-4\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>难点在于nums[i]的美丽值为2的情况：</strong><br>突然想起来高中数学老师的口头禅：“大于大的，小于小的”。<br>nums[i]需要满足：比其左侧所有的nums[j]更大，以及<em>比其右侧所有的nums</em>[k]更小。<br>即<strong>大于左侧最大值，小于右侧最小值</strong>。</p>\n<ul>\n<li><code>*max_element(arr.begin(),arr.end())</code>求数组最大值</li>\n<li><code>*min_element(arr.begin(),arr.end())</code>求数组最小值</li>\n</ul>\n<p>？超时了😇我还说想清楚了不难呢…</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int sumOfBeauties(vector&lt;int&gt;&amp; nums) &#123;\n        int maxval,minval,ans=0;\n        for(int i=1;i&lt;nums.size()-1;i++)&#123;\n            maxval=*max_element(nums.begin(),nums.begin()+i);\n            minval=*min_element(nums.begin()+i+1,nums.end());\n            if(maxval&lt;nums[i] &amp;&amp; minval&gt;nums[i])&#123;\n                ans+=2;\n            &#125;\n            else if(nums[i-1]&lt;nums[i] &amp;&amp; nums[i+1]&gt;nums[i])&#123;\n                ans+=1;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>改进方法就是：左侧最大值和右侧最小值各自都用一个数组存起来所有i的情况，再进行条件判断。同时可以存一个，另一个随每次判断进行更新就好。</p>\n<pre><code>定义左侧最大int数组leftMax;\n遍历i从1到nums.size()：\n    leftMax[i]=max(左侧最大数组[i-1],原数组[i-1]);\nint 美丽值;\n定义右侧最小int变量rightMin并初始化为原数组[length()-1];\n遍历i从length()-2到0:\n    如果（条件一）：\n        美丽值+=2;\n    否则如果（条件2）：\n        美丽值+=1;\n    更新右侧最小值=min（右侧最小值，原数组[i]）;\n返回美丽值\n</code></pre>\n<h2 id=\"完整代码-4\"><a href=\"#完整代码-4\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int sumOfBeauties(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;int&gt; leftMax(nums.size(),0);\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            leftMax[i]=max(leftMax[i-1],nums[i-1]);\n        &#125;\n        int ans=0;\n        int rightMin=nums[nums.size()-1];\n        for(int i=nums.size()-2;i&gt;0;i--)&#123;\n            if(leftMax[i]&lt;nums[i] &amp;&amp; nums[i]&lt;rightMin)&#123;\n                ans+=2;\n            &#125;\n            else if(nums[i-1]&lt;nums[i] &amp;&amp; nums[i]&lt;nums[i+1])&#123;\n                ans+=1;\n            &#125;\n            rightMin=min(rightMin,nums[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"杨辉三角（一维数组版）\"><a href=\"#杨辉三角（一维数组版）\" class=\"headerlink\" title=\"杨辉三角（一维数组版）\"></a>杨辉三角（一维数组版）</h1><h2 id=\"完整代码-5\"><a href=\"#完整代码-5\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-c\">void Print_TR(int n)&#123;\n    int arr[n]=&#123;1&#125;;\n    for(int i=0;i&lt;n;i++)&#123;\n        for(int j=i;j&gt;0;j--)&#123;\n            arr[j]+=arr[j-1];\n        &#125;\n        //打印\n        for(int j=0;j&lt;=i;j++)&#123;\n            printf(&quot;%d &quot;,arr[j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"53-最大子数组和\"><a href=\"#53-最大子数组和\" class=\"headerlink\" title=\"53.最大子数组和\"></a>53.最大子数组和</h1><blockquote>\n<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li>\n<li>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-5\"><a href=\"#解题思路-5\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p><strong>经典解法：Kadane算法</strong>。核心思路是动态规划，通过遍历数组维护当前最大子数组和。整体思路如下：<br>1️⃣<strong>维护两个变量：</strong></p>\n<ul>\n<li><code>sum</code>当前最大子数组和</li>\n<li><code>maxsum</code>全局最大子数组和<br>2️⃣<strong>遍历数组，每次决定是否扩展当前子数组</strong></li>\n<li>如果<code>sum+nums[i] &lt; nums[i]</code> 从nums[i]重新开始（之前的子数组必定与最大和无关</li>\n<li>否则继续累加nums[i]<br>3️⃣<strong>每次更新<code>maxsum</code></strong></li>\n</ul>\n<h2 id=\"完整代码-6\"><a href=\"#完整代码-6\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int sum=nums[0];\n        int maxsum=nums[0];\n        for(int i=1;i&lt;nums.size();i++)&#123;\n            sum=max(nums[i],sum+nums[i]);\n            maxsum=max(sum,maxsum);\n        &#125;\n        return maxsum;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2610-转换二维数组\"><a href=\"#2610-转换二维数组\" class=\"headerlink\" title=\"2610.转换二维数组\"></a>2610.转换二维数组</h1><blockquote>\n<p>给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组：</p>\n<ul>\n<li>二维数组应该 只 包含数组 nums 中的元素。</li>\n<li>二维数组中的每一行都包含 不同 的整数。</li>\n<li>二维数组的行数应尽可能 少 。<br>返回结果数组。如果存在多种答案，则返回其中任何一种。<br>请注意，二维数组的每一行上可以存在不同数量的元素。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>\n<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums.length</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-6\"><a href=\"#解题思路-6\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>用<strong>哈希表</strong>！😎统计元素出现次数，定义一个一维数组存每行元素。每用一个元素。哈希表中该元素次数–（当次数为0时）从表中删除该元素。</p>\n<p>这里看题解 涉及到stl<strong>迭代器</strong><code>it</code>的用法：对于定义一个哈希表:<code>unordered_map&lt;int,int&gt;cnt</code></p>\n<ul>\n<li>当用<code>auto:it</code>遍历<code>cnt.begin()</code>到<code>!=cnt.end()</code>时</li>\n<li><code>it-&gt;first</code>即为哈希表键值对(key,value)中的<code>key</code>。本题中即为<strong>元素本身</strong></li>\n<li><code>it-&gt;second</code>即为哈希表键值对(key,value)中的<code>value</code>。本题中即为元素的<strong>出现次数</strong></li>\n</ul>\n<h2 id=\"完整代码-7\"><a href=\"#完整代码-7\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>感谢<a href=\"https://leetcode.cn/u/endlesscheng/\">灵神</a>题解，教会我很多</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findMatrix(vector&lt;int&gt;&amp; nums) &#123;\n        unordered_map&lt;int,int&gt; cnt;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        for(int x:nums)&#123;\n            cnt[x]++;\n        &#125;\n        while(!cnt.empty())&#123;\n            vector&lt;int&gt;row;\n            for(auto it=cnt.begin();it!=cnt.end();)&#123;\n                row.push_back(it-&gt;first);\n                if(--it-&gt;second==0)&#123;\n                    it=cnt.erase(it);\n                &#125;\n                else&#123;\n                    it++;\n                &#125;\n            &#125;\n            ans.push_back(row);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2643-一最多的行\"><a href=\"#2643-一最多的行\" class=\"headerlink\" title=\"2643.一最多的行\"></a>2643.一最多的行</h1><blockquote>\n<p>给你一个大小为 m x n 的二进制矩阵 mat ，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。<br>如果有多行包含最多的 1 ，只需要选择 行下标最小 的那一行。<br>返回一个由行下标和该行中 1 的数量组成的数组。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>m &#x3D;&#x3D; mat.length </li>\n<li>n &#x3D;&#x3D; mat[i].length </li>\n<li>1 &lt;&#x3D; m, n &lt;&#x3D; 100 </li>\n<li>mat[i][j] 为 0 或 1</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-7\"><a href=\"#解题思路-7\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>最轻松的一集😂但是我写的代码略史山，还有优化空间。</p>\n<h2 id=\"完整代码-8\"><a href=\"#完整代码-8\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>这里直接用<code>int ones = count(mat[i].begin(), mat[i].end(), 1); </code>统计1的个数可以减少一次遍历。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; rowAndMaximumOnes(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;\n        vector&lt;int&gt; cnt(100,0),ans;\n        int index=0;\n        for(int i=0;i&lt;mat.size();i++)&#123;\n            for(int j=0;j&lt;mat[i].size();j++)&#123;\n                if(mat[i][j]==1)&#123;\n                    cnt[i]++;\n                &#125;\n            &#125;\n        &#125;\n        int maxnum=cnt[0];\n        for(int i=0;i&lt;cnt.size();i++)&#123;\n            if(cnt[i]&gt;maxnum)&#123;\n                maxnum=cnt[i];\n                index=i;\n            &#125;\n        &#125;\n        ans.push_back(index);\n        ans.push_back(cnt[index]);\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"661-图片平滑器\"><a href=\"#661-图片平滑器\" class=\"headerlink\" title=\"661.图片平滑器\"></a>661.图片平滑器</h1><blockquote>\n<p><strong>图像平滑器</strong>是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。<br>每个单元格的<strong>平均灰度</strong>定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。<br>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。<br>给你一个表示图像灰度的<code>m x n</code>整数矩阵<code>img</code>，返回对图像的每个单元格平滑处理后的图像 。</p>\n</blockquote>\n<blockquote>\n<p>提示:</p>\n<ul>\n<li>m &#x3D;&#x3D; img.length</li>\n<li>n &#x3D;&#x3D; img[i].length</li>\n<li>1 &lt;&#x3D; m, n &lt;&#x3D; 200</li>\n<li>0 &lt;&#x3D; img[i][j] &lt;&#x3D; 255</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-8\"><a href=\"#解题思路-8\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>关键知道矩阵边界，也就是不全加9个数的情况怎么算。我一开始还想着一个个情况穷举😂其实3*3区域安心两层遍历就行，对于这道题不会超时。<br>***刷题以来第一次碰到四层循环能通过的。。。***不看题解都不敢想像这个方法。</p>\n<h2 id=\"完整代码-9\"><a href=\"#完整代码-9\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; img) &#123;\n        int m,n;\n        m=img.size();\n        n=img[0].size();\n        vector&lt;vector&lt;int&gt;&gt;ans(m,vector&lt;int&gt;(n,0));\n        for(int i=0;i&lt;m;i++)&#123;\n            for(int j=0;j&lt;n;j++)&#123;\n                int sum,cnt;\n                sum=cnt=0;\n                for(int r=i-1;r&lt;=i+1;r++)&#123;\n                    for(int c=j-1;c&lt;=j+1;c++)&#123;\n                        if(0&lt;=r &amp;&amp; r&lt;m &amp;&amp; 0&lt;=c &amp;&amp; c&lt;n)&#123;\n                            sum+=img[r][c];\n                            cnt++;\n                        &#125;\n                    &#125;\n                &#125;\n                ans[i][j]=cnt&gt;0?sum/cnt:img[i][j];\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"27171-对角线上不同值的数量差\"><a href=\"#27171-对角线上不同值的数量差\" class=\"headerlink\" title=\"27171.对角线上不同值的数量差\"></a>27171.对角线上不同值的数量差</h1><blockquote>\n<p>给你一个下标从 0 开始、大小为 m x n 的二维矩阵 grid ，请你求解大小同样为 m x n 的答案矩阵 answer 。<br>矩阵 answer 中每个单元格 (r, c) 的值可以按下述方式进行计算：<br>令 topLeft[r][c] 为矩阵 grid 中单元格 (r, c) 左上角对角线上 不同值 的数量。<br>令 bottomRight[r][c] 为矩阵 grid 中单元格 (r, c) 右下角对角线上 不同值 的数量。<br>然后 answer[r][c] &#x3D; |topLeft[r][c] - bottomRight[r][c]| 。<br>返回矩阵 answer 。<br>矩阵对角线 是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。<br>如果单元格 (r1, c1) 和单元格 (r, c) 属于同一条对角线且 r1 &lt; r ，则单元格 (r1, c1) 属于单元格 (r, c) 的左上对角线。类似地，可以定义右下对角线。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>m &#x3D;&#x3D; grid.length</li>\n<li>n &#x3D;&#x3D; grid[i].length</li>\n<li>1 &lt;&#x3D; m, n, grid[i][j] &lt;&#x3D; 50</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-9\"><a href=\"#解题思路-9\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>几个地方思考的时候容易卡住：</p>\n<p>1️⃣<strong>不同值是什么意思？</strong><br>我一开始理解的是对于grid[i][j]，它的左对角线上和它不同的元素数量叫做topleft，右对角线上和它不同的元素数量叫做bottomright，然后就自以为大彻大悟☝️🤓<del>美美去打代码然后寄了</del>。</p>\n<p>个人理解中，实际上这里的不同值的意思是：对于这半拉对角线上的所有元素而言的<strong>种类</strong>数量。</p>\n<ul>\n<li>比如全是1，那就1种，topleft&#x3D;1；</li>\n<li>如果有1有0，那就是2种，topleft&#x3D;2。<br>右对角线同理.</li>\n</ul>\n<p>2️⃣<strong>如何统计“不同值”？</strong><br>这里选用基于红黑树的std::set而不是之前我们常用的unordered_map。因为对于本题，只需要判断「是否不同」而不需要记录「不同的次数」。<br>对于set<int>myset 而言：</p>\n<ul>\n<li>如果rfind.find(grid[r][c])&#x3D;&#x3D;rfind.end()即为不同值</li>\n<li>新的不同值用myset.insert()添加</li>\n<li>myset.size()获得不同值的数量</li>\n</ul>\n<h2 id=\"完整代码-10\"><a href=\"#完整代码-10\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; differenceOfDistinctValues(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int m,n;\n        m=grid.size();\n        n=grid[0].size();\n        vector&lt;vector&lt;int&gt;&gt; answer(m,vector&lt;int&gt;(n,0));\n        for(int i=0;i&lt;m;i++)&#123;\n            for(int j=0;j&lt;n;j++)&#123;\n                int lcnt,rcnt;\n                lcnt=rcnt=0;\n                set&lt;int&gt; lfind,rfind;\n                //左对角线\n                int r=i-1;\n                int c=j-1;\n                while(r&gt;=0 &amp;&amp; c&gt;=0)&#123;\n                    if(「」)&#123;\n                        lcnt++;\n                    &#125;\n                    lfind.insert(grid[r][c]);\n                    r--;\n                    c--;\n                &#125;\n                //右对角线\n                r=i+1;\n                c=j+1;\n                while(r&lt;m &amp;&amp; c&lt;n)&#123;\n                    if(rfind.find(grid[r][c])==rfind.end())&#123;\n                        rcnt++;\n                    &#125;\n                    rfind.insert(grid[r][c]);\n                    r++;\n                    c++;\n                &#125;\n                answer[i][j]=abs(lcnt-rcnt);\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "数组",
                "C++",
                "哈希表",
                "动态规划",
                "二分查找"
            ]
        }
    ]
}
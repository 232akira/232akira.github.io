{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"力扣\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "url": "https://232akira.github.io/2025/03/06/Leetcode%E9%93%BE%E8%A1%A8/",
            "title": "Leetcode链表",
            "date_published": "2025-03-06T02:25:28.000Z",
            "content_html": "<p>链表这东西真的学一阵忘一阵😂</p>\n<h1 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h1><h2 id=\"结构定义\"><a href=\"#结构定义\" class=\"headerlink\" title=\"结构定义\"></a>结构定义</h2><ul>\n<li>节点结构 <code>ListNode</code></li>\n<li>值 <code>data</code></li>\n<li>指向下一个节点的指针 <code>next</code></li>\n</ul>\n<pre><code class=\"language-cpp\">struct ListNode&#123;\n    int data;\n    ListNode* next;\n    ListNode(int x):data(x),next(nullptr)&#123;&#125;\n&#125;Node;\n</code></pre>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h3 id=\"创建链表\"><a href=\"#创建链表\" class=\"headerlink\" title=\"创建链表\"></a>创建链表</h3><p>定义单链表类，封装基本操作。下面的几个操作都在public里~</p>\n<pre><code>class LinkedList&#123;\npublic:\n    ListNode* head;\n    LinkedList():head(nullptr);\n&#125;\n</code></pre>\n<h3 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h3><ul>\n<li>头插法:新节点加到链表头部</li>\n</ul>\n<pre><code>void insertAtHead(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    newNode-&gt;next=head;\n    head=newNode;\n&#125;\n</code></pre>\n<ul>\n<li>尾插法：:新节点加到链表尾部</li>\n</ul>\n<pre><code>void insertAtTail(int data)&#123;\n    ListNode* newNode=new ListNode(data);\n    if(!head)&#123;\n        head=newNode;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    temp-&gt;next=newNode;\n&#125;\n</code></pre>\n<h3 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h3><pre><code>void deleteNode(int data)&#123;\n    if(!head)&#123;\n        return;\n    &#125;\n    if(head-&gt;data==data)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n        return;\n    &#125;\n    ListNode* temp=head;\n    while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;val !=val)&#123;\n        temp=temp-&gt;next;\n    &#125;\n    if(temp-&gt;next)&#123;\n        ListNode* delNode=temp-&gt;next;\n        temp-&gt;next=temp-&gt;next-&gt;next;\n        delete delNode;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"修改节点\"><a href=\"#修改节点\" class=\"headerlink\" title=\"修改节点\"></a>修改节点</h3><pre><code>void updateNode(int oldData,newData)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-data==oldData)&#123;\n            temp-&gt;data==oldData;\n            return;\n        &#125;\n        temp=temp-&gt;next;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"查找节点\"><a href=\"#查找节点\" class=\"headerlink\" title=\"查找节点\"></a>查找节点</h3><pre><code>bool searchNode(int data)&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        if(temp-&gt;data==data)&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<h3 id=\"打印链表\"><a href=\"#打印链表\" class=\"headerlink\" title=\"打印链表\"></a>打印链表</h3><pre><code>void printList()&#123;\n    ListNode* temp=head;\n    while(temp)&#123;\n        cout&lt;&lt;temp-&gt;val&lt;&lt;&quot;-&gt;&quot;;\n        temp=temp-&gt;next;\n    &#125;\n    cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl;\n&#125;\n</code></pre>\n<h3 id=\"释放链表内存\"><a href=\"#释放链表内存\" class=\"headerlink\" title=\"释放链表内存\"></a>释放链表内存</h3><pre><code>~LinkedList()&#123;\n    while(head)&#123;\n        ListNode* temp=head;\n        head=head-&gt;next;\n        delete temp;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21.合并两个有序链表\"></a>21.合并两个有序链表</h1><blockquote>\n<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>提示：</p>\n<ul>\n<li>两个链表的节点数目范围是 [0, 50]</li>\n<li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>\n<li>l1和l2均按非递减顺序排列</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>👉️ <em><strong>终止条件</strong></em>：有链表为空</p>\n<ul>\n<li>list1为空，合并结果直接为list2</li>\n<li>list2为空，合并结果直接为list1</li>\n</ul>\n<p>👉️ <em><strong>递归调用</strong></em>：小的打头，每一步递归后返回的值链接到链表末尾</p>\n<ul>\n<li>如果<code>list1节点的值 &lt; list2</code>：寻找list1后面节点还有没有也比list2小的节点</li>\n</ul>\n<pre><code>让list1-&gt;next接上递归后合并的结果；\n返回当前较小的节点list1;\n</code></pre>\n<ul>\n<li>else：寻找list2后面节点还有没有也比list1小的节点</li>\n</ul>\n<pre><code>让list2-&gt;next接上递归后合并的结果；\n返回当前较小的节点list2;\n</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;\n        if(list1==NULL || list2==NULL)&#123;\n            return list1==NULL ? list2:list1;\n        &#125;\n        if(list1-&gt;val &lt; list2-&gt;val)&#123;\n            list1-&gt;next = mergeTwoLists(list1-&gt;next,list2);\n            return list1;\n        &#125;\n        else&#123;\n            list2-&gt;next = mergeTwoLists(list1,list2-&gt;next);\n            return list2;\n        &#125;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "算法",
                "链表"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "url": "https://232akira.github.io/2025/03/04/Leetcode%E6%95%B0%E7%BB%84/",
            "title": "Leetcode数组",
            "date_published": "2025-03-04T11:15:05.000Z",
            "content_html": "<p>本来想一道题一篇文，但是做的大多是简单题所以按模块归类好复习一点。</p>\n<h1 id=\"1232-缀点成线\"><a href=\"#1232-缀点成线\" class=\"headerlink\" title=\"1232.缀点成线\"></a>1232.缀点成线</h1><blockquote>\n<p>给定一个数组 coordinates ，其中 coordinates[i] &#x3D; [x, y] ， [x, y] 表示横坐标为 x、纵坐标为 y 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n<ul>\n<li>2 &lt;&#x3D; coordinates.length &lt;&#x3D; 1000</li>\n<li>coordinates[i].length &#x3D;&#x3D; 2</li>\n<li>-10^4 &lt;&#x3D; coordinates[i][0], coordinates[i][1] &lt;&#x3D; 10^4</li>\n<li>coordinates 中不含重复的点</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我本来是想着soeasy，用y&#x2F;x对比斜率就行了，然后发现部分样例通不过。定睛一看，发现直线不一定过原点…</p>\n<p>那么就不使用斜率，而是使用<strong>斜率交叉乘法</strong>：如果所有点都在同一条直线上，那么<strong>对于任意两点P1(x1,y1)、P2(x2,y2)、P3(x3,y3)之间的斜率必须相等</strong>。也就是<code>(y2-y1)/(x2-x1)=(y3-y1)/(x3-x1)</code>。为避免除法带来的浮点误差，用<strong>交叉相乘</strong>验证更好。<br><em><strong>并且注意！</strong></em><br>因为我的验证方法需要三个点，但是这道题有可<code>coordinates,length=2</code>的情况，那就直接返回true，因为<strong>两点确定一条直线</strong>。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;\n        int x1,y1,x2,y2;\n        x1=coordinates[0][0];\n        y1=coordinates[0][1];\n        x2=coordinates[1][0];\n        y2=coordinates[1][1];\n        if(coordinates.size()==2)&#123;\n            return true;\n        &#125;\n        for(int i=2;i&lt;coordinates.size();i++)&#123;\n            int x3=coordinates[i][0];\n            int y3=coordinates[i][1];\n            if((y2-y1)*(x3-x1)!=(x2-x1)*(y3-y1))&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2597-美丽子集的数目\"><a href=\"#2597-美丽子集的数目\" class=\"headerlink\" title=\"2597.美丽子集的数目\"></a>2597.美丽子集的数目</h1><blockquote>\n<p>给你一个由正整数组成的数组 nums 和一个 正 整数 k 。<br>如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。<br>返回数组 nums 中 非空 且 美丽 的子集数目。<br>nums 的子集定义为：可以经由 nums 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 18</li>\n<li>1 &lt;&#x3D; nums[i], k &lt;&#x3D; 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>涉及<strong>子集</strong>相关问题，一般有两种方法：</p>\n<ul>\n<li><em><strong>回溯</strong></em></li>\n<li><em><strong>位运算</strong><br>本题选择</em><em>回溯<strong>算法。因为该方法可在生成子集时</strong>剪枝*</em>。</li>\n</ul>\n<p>假设 nums &#x3D; [2, 4, 6]，我们希望生成所有子集,那么回溯的选择路径如下：</p>\n<pre><code>          dfs(0)\n        /        \\\n    不选2        选2\n     / \\         /  \\\n  不选4  选4   不选4  选4\n  ...\n</code></pre>\n<h2 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    int ans=0;\n    void dfs(int index,vector&lt;int&gt;&amp; nums,unordered_map&lt;int,int&gt;&amp; freq,int k)&#123;\n        if(index==nums.size())&#123;\n            ans++;\n            return;\n        &#125;\n        dfs(index+1,nums,freq,k);\n        if(freq[nums[index]-k]==0 &amp;&amp; freq[nums[index]+k]==0)&#123;\n            freq[nums[index]]++;\n            dfs(index+1,nums,freq,k);\n            freq[nums[index]]--;\n        &#125;\n    &#125;\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;\n        unordered_map&lt;int,int&gt; freq;\n        dfs(0,nums,freq,k);\n        return ans-1;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"2070-每一个查询的最大美丽值\"><a href=\"#2070-每一个查询的最大美丽值\" class=\"headerlink\" title=\"2070.每一个查询的最大美丽值\"></a>2070.每一个查询的最大美丽值</h1><p>又美丽了家人们🤣</p>\n<blockquote>\n<p>给你一个二维整数数组 items ，其中 items[i] &#x3D; [pricei, beautyi] 分别表示每一个物品的价格和美丽值 。<br>同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。<br>请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。</p>\n</blockquote>\n<blockquote>\n<p>提示：<br>-1 &lt;&#x3D; items.length, queries.length &lt;&#x3D; 105<br>-items[i].length &#x3D;&#x3D; 2<br>-1 &lt;&#x3D; pricei, beautyi, queries[j] &lt;&#x3D; 109</p>\n</blockquote>\n<h2 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>首先复习一下二分查找，我又忘了咋写。<a href=\"https://232akira.github.io/2025/03/02/%E5%8A%9B%E6%89%A3%E5%A4%87%E5%BF%98%E5%BD%95/\">另一篇</a>copy来的</p>\n<blockquote>\n<ul>\n<li>要查找的目标<code>target</code></li>\n<li>索引<code>index</code></li>\n<li>左、右指示符<code>left</code>、<code>right</code></li>\n<li>中间指示符<code>mid</code><br>主要思路就是计算<code>mid</code>的位置：<br>1️⃣<code>nums[mid] == target</code> 🤭找到了<br>2️⃣<code>nums[mid] &lt; target</code> → target在left的右边 → left右移 👉️left&#x3D;mid+1;<br>3️⃣<code>nums[mid] &gt; target</code> → target在right的左边 → right左移 👉️right&#x3D;mid-1;</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-cpp\">//形参：vector&lt;int&gt;nums,int target\nint left=0;\nint right=nums.size()-1;\nwhile(left&lt;=right)&#123;\n    int mid=left+(right-left)/2;\n    if(nums[mid]=target)&#123;\n        return mid;\n    &#125;\n    else if(nums[mid]&lt;target)&#123;\n        left=mid+1;\n    &#125;\n    else&#123;\n        right=mid-1;\n    &#125;\n    return index;\n&#125;\n</code></pre>\n<h3 id=\"本题思路\"><a href=\"#本题思路\" class=\"headerlink\" title=\"本题思路\"></a>本题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a><em><strong>方法一</strong></em></h4><p>完球，力扣的急速判题卡死了😂第一个方法直观而且没用二分，美美超时。</p>\n<pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        vector&lt;int&gt; answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int maxnum=0;\n            for(int i=0;i&lt;items.size();i++)&#123;\n                if(items[i][0]&lt;=target)&#123;\n                    maxnum=max(maxnum,items[i][1]);\n                &#125;\n            &#125;\n            answer[j]=maxnum;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a><em><strong>方法二</strong></em></h4><p>老老实实用二分。注意：二分查找的前提是<strong>有序</strong>。</p>\n<ul>\n<li>先按照price递增排序;</li>\n<li>定义美丽数组;</li>\n<li>遍历items:<strong>存储当前遍历到的最大美丽值</strong>。的最大美丽值;</li>\n<li>定义答案数组;</li>\n<li>遍历querties：<strong>二分查找</strong></li>\n</ul>\n<p>二分查找目标🤟<code>items[i][0] &lt;= queries[j]</code> 的最大 i<br>有点绕了，兄弟兄弟…</p>\n<h2 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"language-cpp\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) &#123;\n        sort(items.begin(),items.end());\n        vector&lt;int&gt;maxbeauty(items.size());\n        maxbeauty[0]=items[0][1];\n        for(int i=1;i&lt;items.size();i++)&#123;\n            maxbeauty[i]=max(maxbeauty[i-1],items[i][1]);\n        &#125;\n        vector&lt;int&gt;answer(queries.size(),0);\n        for(int j=0;j&lt;queries.size();j++)&#123;\n            int target=queries[j];\n            int left=0;\n            int right=items.size()-1;\n            int index=-1;\n            while(left&lt;=right)&#123;\n                int mid=left+(right-left)/2;\n                if(items[mid][0]&lt;=target)&#123;\n                    index=mid;\n                    left=mid+1;\n                &#125;\n                else&#123;\n                    right=mid-1;\n                &#125;\n            &#125;\n            if(index!=-1)&#123;\n                answer[j]=maxbeauty[index];\n            &#125;\n        &#125;\n        return answer;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "力扣",
                "数组",
                "C++",
                "哈希表",
                "动态规划",
                "二分查找"
            ]
        }
    ]
}
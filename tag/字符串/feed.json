{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"字符串\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/03/05/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://232akira.github.io/2025/03/05/Leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "Leetcode字符串",
            "date_published": "2025-03-05T07:22:48.000Z",
            "content_html": "<h1 id=\"58-最后一个单词的长度\"><a href=\"#58-最后一个单词的长度\" class=\"headerlink\" title=\"58.最后一个单词的长度\"></a>58.最后一个单词的长度</h1><blockquote>\n<p><strong>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</strong></p>\n</blockquote>\n<p>KMP有点难理解了对我而言…看不懂就放两天继续钻，再多看看大佬博客的不同理解，效果会更好。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><ul>\n<li>参考链接：<br><a href=\"https://www.cnblogs.com/dusf/p/kmp.html\">1️⃣</a><br><a href=\"https://blog.csdn.net/yyzsir/article/details/89462339?ops_request_misc=%257B%2522request%255Fid%2522%253A%252292dce769a412320e26ef79eb85ca18cd%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=92dce769a412320e26ef79eb85ca18cd&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-89462339-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=yyzsir%20kmp&spm=1018.2226.3001.4187\">2️⃣</a></li>\n</ul>\n<hr>\n<h3 id=\"朴素模式匹配BF\"><a href=\"#朴素模式匹配BF\" class=\"headerlink\" title=\"朴素模式匹配BF\"></a>朴素模式匹配<code>BF</code></h3><p>首先来个<strong>暴力</strong>方法：不匹配模式串就右挪一位。</p>\n<pre><code>//暴力模式匹配\nint 主串位置i；\nint 模式串位置j；\nint 主串长度；\nint 子串长度；\n\n当（主串位置 &lt;= 主串长度 &amp;&amp; 模式串位置&lt;模式串长度）:\n    如果（该主串位置的主串字符 == 该模式串位置的模式串字符）：\n        i++；\n        j++；\n    否则：\n        i后退至上一轮匹配开始位置的后一位；\n        j归零；\n如果（模式串位置 == 模式串长度）：\n    匹配成功，返回出现位置；\n否则\n    匹配失败，返回-1；\n</code></pre>\n<h3 id=\"优化模式匹配KMP\"><a href=\"#优化模式匹配KMP\" class=\"headerlink\" title=\"优化模式匹配KMP\"></a>优化模式匹配<code>KMP</code></h3><p>即利用<strong>已经部分匹配</strong>这个信息，保持<strong>i指针不回溯</strong>，并通过j指针让<strong>模式串</strong>尽可能移动到<strong>更有效的位置</strong>。</p>\n<p>那么有几个要点：</p>\n<ul>\n<li><p><em><strong>前缀(Prefix)和后缀（Suffix）</strong></em><br>举个🌰，给定一个字符串s:<code>“abcab”</code>,那么:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">s的子串</th>\n<th align=\"center\"><strong>前缀</strong></th>\n<th align=\"center\"><strong>后缀</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">ab</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n</tr>\n<tr>\n<td align=\"center\">abc</td>\n<td align=\"center\">a,ab</td>\n<td align=\"center\">c,bc</td>\n</tr>\n<tr>\n<td align=\"center\">abca</td>\n<td align=\"center\">a,ab,abc</td>\n<td align=\"center\">a,ca,bca</td>\n</tr>\n<tr>\n<td align=\"center\">abcab</td>\n<td align=\"center\">a,ab,abc,abca</td>\n<td align=\"center\">b,ab,cab,bcab</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><em><strong>公共前后缀最长长度</strong></em><br>从上面的前后缀不难看出，对于s的子串，存在部分前后缀重复的情况，我们需要的正是重复子串的最大长度。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">s的子串</th>\n<th align=\"center\">前缀</th>\n<th align=\"center\">后缀</th>\n<th align=\"center\"><strong>公共前后缀最长长度</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">ab</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">abc</td>\n<td align=\"center\">a,ab</td>\n<td align=\"center\">c,bc</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">abca</td>\n<td align=\"center\"><code>a</code>,ab,abc</td>\n<td align=\"center\"><code>a</code>,ca,bca</td>\n<td align=\"center\"><code>1</code></td>\n</tr>\n<tr>\n<td align=\"center\">abcab</td>\n<td align=\"center\">a,<code>ab</code>,abc,abca</td>\n<td align=\"center\">b,<code>ab</code>,cab,bcab</td>\n<td align=\"center\"><code>2</code></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><em><strong>next数组（部分匹配表）</strong></em><br>KMP的next数组告诉我们：当模式串中的某个字符跟主串中的某个字符失配时，模式串下一步应该跳到哪个位置。</p>\n</li>\n</ul>\n<p>对于s的<strong>每个字符</strong>而言，当这个字符作为子串的最后一位时，公共前后缀最长长度为：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符（标红部分）</th>\n<th align=\"center\">公共前后缀最长长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>a</code>bcab</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">a<code>b</code>cab</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">ab<code>c</code>ab</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">abc<code>a</code>b</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">abca<code>b</code></td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<p>那么全部右移一位，令next[0]&#x3D;-1：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">字符</th>\n<th align=\"center\">i</th>\n<th align=\"center\">next[i]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">0</td>\n<td align=\"center\">-1</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">a</td>\n<td align=\"center\">3</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p><strong>实际匹配过程中，j移动到子串p的next[j]位置，p相对s向右移动j-next[j]位置。</strong></p>\n<ul>\n<li><strong>迭代法求p的next数组</strong><br>我们知道：</li>\n</ul>\n<pre><code>next[0]=-1;\nnext[1]=0;\n</code></pre>\n<p>并且<code>next[j]</code>代表p[0…j-1]的子串公共前后缀最长长度。<br>∴ 变量定义如下：<br><code>j</code>：当前子串指针<br><code>k</code>：当前匹配的前后缀长度（&#x3D;next[j-1]）<br><code>next[j]=k</code>：next[0]&#x3D;-1 即当p[0]都匹配失败时，只能回到j&#x3D;0重新匹配。</p>\n<pre><code>void GetNext(char p[], int next[])\n&#123;\n    int j = 0, k = -1;\n    next[j] = k;\n    while (p[j] != &#39;\\0&#39;)             //遍历整个子串p\n    &#123;\n        if (k == -1 || p[j] == p[k]) //匹配成功😀或者k=-1（刚匹配到字串的第一个）\n        &#123;\n            j++;                     //j指针后移\n            k++;\n            next[j] = k;             //记录当前前后缀匹配长度\n        &#125; \n        else \n        &#123;\n            k = next[k];             //匹配失败😭，回溯到next[k]寻找更短的前后缀\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>KMP主算法<br>得到next数组的方法<code>GetNext()</code>，就可以完整的写出KMP函数。这里写成一个函数：</li>\n</ul>\n<pre><code>int KMP(string s,string p)&#123;\n    int m=s.size();\n    int n=p.size();\n    if(m==0)&#123;\n        return 0;\n    &#125;\n    //⬇️计算next数组\n    vector&lt;int&gt;next;\n    int j=0;\n    for(int i=0;i&lt;n;i++)&#123;\n        while(j&gt;0 &amp;&amp; p[i]!=p[j])&#123;\n            j=next[j-1];\n        &#125;\n        if(p[i]==p[j])&#123;\n            j++;\n        &#125;\n        next[i]=j;\n    &#125;\n    //⬇️KMP搜索匹配\n    int j=0;\n    for(int i=0;i&lt;m;i++)&#123;\n        while(j&gt;0 &amp;&amp; s[i]!=p[j])&#123;\n            j=next[j-1];\n        &#125;\n        if(s[i]==p[j])&#123;\n            j++;\n        &#125;\n        if(j==n)&#123;\n            return i-n+1;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n</code></pre>\n<p>说实话，后半部分现在不能完全理解，让我再多磕几天。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2>",
            "tags": [
                "算法",
                "字符串"
            ]
        }
    ]
}
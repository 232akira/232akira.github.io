{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"笔记\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/11/04/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Function%20calling/",
            "url": "https://232akira.github.io/2025/11/04/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Function%20calling/",
            "title": "笔记🗒️ ⋮ Function calling",
            "date_published": "2025-11-04T13:48:12.000Z",
            "content_html": "<blockquote>\n<p>这篇主要整理一下openai和国内（dashscope、gitee等）模型平台的function calling的格式区别。</p>\n</blockquote>\n<p>仅总结<strong>可调用工具列表</strong>的定义方式，即：“如何定义工具列表”。</p>\n<h3 id=\"OpenAI\"><a href=\"#OpenAI\" class=\"headerlink\" title=\"OpenAI\"></a>OpenAI</h3><pre><code class=\"language-json\">tools = [\n    &#123;\n        &quot;type&quot;: &quot;function&quot;,\n        &quot;name&quot;: &quot;get_horoscope&quot;,\n        &quot;description&quot;: &quot;Get today&#39;s horoscope for an astrological sign.&quot;,\n        &quot;parameters&quot;: &#123;\n            &quot;type&quot;: &quot;object&quot;,\n            &quot;properties&quot;: &#123;\n                &quot;sign&quot;: &#123;\n                    &quot;type&quot;: &quot;string&quot;,\n                    &quot;description&quot;: &quot;An astrological sign like Taurus or Aquarius&quot;,\n                &#125;,\n            &#125;,\n            &quot;required&quot;: [&quot;sign&quot;],\n        &#125;,\n    &#125;,\n]\n</code></pre>\n<h3 id=\"DashScope\"><a href=\"#DashScope\" class=\"headerlink\" title=\"DashScope\"></a>DashScope</h3><pre><code class=\"language-json\">tools = [\n    &#123;\n        &quot;type&quot;: &quot;function&quot;,\n        &quot;function&quot;: &#123;\n            &quot;name&quot;: &quot;get_current_weather&quot;,\n            &quot;description&quot;: &quot;当你想查询指定城市的天气时非常有用。&quot;,\n            &quot;parameters&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;location&quot;: &#123;\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;城市或县区，比如北京市、杭州市、余杭区等。&quot;,\n                    &#125;\n                &#125;,\n                &quot;required&quot;: [&quot;location&quot;],\n            &#125;,\n        &#125;,\n    &#125;,\n]\n</code></pre>\n<h2 id=\"Gitee-AI\"><a href=\"#Gitee-AI\" class=\"headerlink\" title=\"Gitee AI\"></a>Gitee AI</h2><pre><code class=\"language-json\">tools = [\n    &#123;\n        &quot;type&quot;: &quot;function&quot;,\n        &quot;function&quot;: &#123;\n            &quot;name&quot;: &quot;get_current_weather&quot;,\n            &quot;description&quot;: &quot;通过城市名和日期获取地点的天气情况，包括温度、天气状况等信息&quot;,\n            &quot;parameters&quot;: &#123;\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: &#123;\n                    &quot;city&quot;: &#123;\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;用户想要查询天气的城市名称&quot;,\n                    &#125;,\n                    &quot;date&quot;: &#123;\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;想要查询的日期，如&#39;今天&#39;、&#39;明天&#39;或具体日期&#39;2023-10-01&#39;&quot;,\n                    &#125;\n                &#125;,\n                &quot;required&quot;: [&quot;city&quot;, &quot;date&quot;],\n            &#125;,\n        &#125;\n    &#125;\n]\n</code></pre>\n<h3 id=\"Function-Calling-工具定义格式对比\"><a href=\"#Function-Calling-工具定义格式对比\" class=\"headerlink\" title=\"Function Calling 工具定义格式对比\"></a>Function Calling 工具定义格式对比</h3><blockquote>\n<p>这个表是g老师写的，等我二次审核。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>工具定义结构</th>\n<th>关键字段层级</th>\n<th>特点说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OpenAI</strong></td>\n<td><code>&#123;&quot;type&quot;: &quot;function&quot;, &quot;name&quot;: &quot;...&quot;, &quot;description&quot;: &quot;...&quot;, &quot;parameters&quot;: &#123;...&#125;&#125;</code></td>\n<td><code>name</code>、<code>description</code>、<code>parameters</code> 直接位于最外层</td>\n<td>结构更简洁；无 <code>&quot;function&quot;</code> 嵌套层。</td>\n</tr>\n<tr>\n<td><strong>DashScope（阿里云百炼）</strong></td>\n<td><code>&#123;&quot;type&quot;: &quot;function&quot;, &quot;function&quot;: &#123;&quot;name&quot;: &quot;...&quot;, &quot;description&quot;: &quot;...&quot;, &quot;parameters&quot;: &#123;...&#125;&#125;&#125;</code></td>\n<td>多一层 <code>&quot;function&quot;</code> 包裹内部定义</td>\n<td>函数信息嵌套在 <code>&quot;function&quot;</code> 字段中。</td>\n</tr>\n<tr>\n<td><strong>Gitee AI（模力方舟）</strong></td>\n<td><code>&#123;&quot;type&quot;: &quot;function&quot;, &quot;function&quot;: &#123;&quot;name&quot;: &quot;...&quot;, &quot;description&quot;: &quot;...&quot;, &quot;parameters&quot;: &#123;...&#125;&#125;&#125;</code></td>\n<td>与 DashScope 相同</td>\n<td>结构几乎一致，字段名完全相同，说明文字不同。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>✅ <strong>总结</strong>：OpenAI 与国内平台的主要区别在于是否包裹 <code>&quot;function&quot;</code> 层；DashScope 与 Gitee AI 的结构基本一致。</p>\n</blockquote>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ol>\n<li><a href=\"https://platform.openai.com/docs/guides/function-calling\">Function calling - OpenAI API</a></li>\n<li><a href=\"https://help.aliyun.com/zh/model-studio/qwen-function-calling?spm=5176.30275541.J_ZGek9Blx07Hclc3Ddt9dg.14.5f8e2f3ds4Wskn&scm=20140722.S_help@@%E6%96%87%E6%A1%A3@@2862208._.ID_help@@%E6%96%87%E6%A1%A3@@2862208-RL_functioncall-LOC_2024HSPAllResult-OR_ser-PAR1_213e012917629402469488248ea3d7-V_4-PAR3_o-RE_new10-P0_0-P1_0\">大模型调用外部工具解决问题-Function Calling-大模型服务平台百炼-阿里云</a></li>\n<li><a href=\"https://ai.gitee.com/docs/products/apis/texts/function-calling\">函数调用 (Function Calling) | 模力方舟</a></li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/11/02/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Docker/",
            "url": "https://232akira.github.io/2025/11/02/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Docker/",
            "title": "笔记🗒️ ⋮ Docker",
            "date_published": "2025-11-02T13:48:12.000Z",
            "content_html": "<blockquote>\n<p>最近做的开源项目复现越来越多，发现自己在项目部署方面的实践太浅薄，平时往往就是编个码注重功能实现。<br>于是决定好好学习一下<code>Docker</code>。这篇基本完成后会开启<code>K8s</code>笔记。</p>\n</blockquote>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p>容器化能让我们快速部署、隔离环境和复现项目的运行条件，那么就不能不提到<strong>Docker</strong>。</p>\n<p>那么先理解三个概念：</p>\n<ol>\n<li><p><strong>Image</strong>（镜像）<br>类似一个系统模板，包含运行程序的所有依赖。</p>\n</li>\n<li><p><strong>Container</strong>（容器）<br>一个实际运行中的项目环境。</p>\n</li>\n<li><p><strong>Dockerfile</strong><br>描述镜像怎么构建。</p>\n</li>\n</ol>\n<h2 id=\"安全合规的Docker使用方案\"><a href=\"#安全合规的Docker使用方案\" class=\"headerlink\" title=\"安全合规的Docker使用方案\"></a>安全合规的Docker使用方案</h2><blockquote>\n<p>公司电脑是装不上Docker Desktop的：一是有权限限制，二是Docker Desktop License不允许公司企业免费使用。</p>\n<p>但是公司提供了<strong>内网镜像源</strong>和<strong>Docker CE安装仓库</strong>。</p>\n</blockquote>\n<h3 id=\"理解Docker的整体工作流程\"><a href=\"#理解Docker的整体工作流程\" class=\"headerlink\" title=\"理解Docker的整体工作流程\"></a>理解Docker的整体工作流程</h3><p>比如你的项目想在Docker里跑，需要：</p>\n<ol>\n<li>写一个Dockerfile（告诉Dockers环境和依赖）</li>\n<li>用<code>docker build</code>打包成镜像</li>\n<li>用<code>docker run</code>启动容器</li>\n<li>用<code>docker exec -it</code>进去调试</li>\n</ol>\n<h3 id=\"在虚拟机中安装Docker\"><a href=\"#在虚拟机中安装Docker\" class=\"headerlink\" title=\"在虚拟机中安装Docker\"></a>在虚拟机中安装Docker</h3><h4 id=\"1-创建虚拟机\"><a href=\"#1-创建虚拟机\" class=\"headerlink\" title=\"1. 创建虚拟机\"></a>1. 创建虚拟机</h4><blockquote>\n<p><strong>目的</strong>：获得可控的Linux环境。</p>\n</blockquote>\n<p>我安装的是<strong>Oracle VM VirtualBox</strong>。花了将近一周纠缠在装Ubuntu上😶</p>\n<ul>\n<li>虚拟机系统镜像来自Ubuntu官网：<a href=\"https://ubuntu.com/download/desktop](https://ubuntu.com/download/desktop\">https://ubuntu.com/download/desktop](https://ubuntu.com/download/desktop</a></li>\n<li>VirtualBoxVM-&gt;光驱-&gt;选择官网下载的镜像文件（.iso）</li>\n<li>打开VM-&gt;Try or Install Ubuntu</li>\n<li>Ubuntu<strong>安装</strong>时<strong>非常非常容易卡死</strong>在复制文件&#x2F;安装系统的步骤。这里建议一是：把镜像文件放在全英文目录下；二是：VM默认联网没问题，但在点击最后一个安装的选项前，断掉你的本机网络。</li>\n</ul>\n<p><strong>安装完成</strong>。登录VM并打开终端界面，执行：</p>\n<pre><code class=\"language-bash\"># 更新系统并安装常用工具\nsudo apt update &amp;&amp; sudo apt upgrade -y\nsudo apt install -y curl wget git ca-certificates gnupg lsb-release apt-transport-https\n</code></pre>\n<hr>\n<p><em><strong>之后的部分内命令非企业外公开，因此后期会二次整理成文字描述形式~</strong></em></p>\n<h4 id=\"2-安装Docker-CE\"><a href=\"#2-安装Docker-CE\" class=\"headerlink\" title=\"2. 安装Docker CE\"></a>2. 安装Docker CE</h4><blockquote>\n<p><strong>目的</strong>：获取Docker环境。</p>\n</blockquote>\n<p>也就是进行换源+安装Docker CE企业版。</p>\n<ol>\n<li>添加公司Docker CE GPG Key并添加镜像仓库（公司内网）</li>\n</ol>\n<pre><code class=\"language-bash\">待整理\n</code></pre>\n<ol start=\"2\">\n<li>（可选）更新并移除旧版本</li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-get update\nsudo apt-get remove -y docker docker-engine docker.io containerd runc || true\n</code></pre>\n<ol start=\"3\">\n<li>安装docker-ce （这步下了至少一个小时……😭</li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n</code></pre>\n<ol start=\"4\">\n<li>启动并设置开机自启</li>\n</ol>\n<pre><code class=\"language-bash\">sudo systemctl enable --now docker\n</code></pre>\n<h4 id=\"3-配置镜像代理仓库\"><a href=\"#3-配置镜像代理仓库\" class=\"headerlink\" title=\"3. 配置镜像代理仓库\"></a>3. 配置镜像代理仓库</h4><blockquote>\n<p><strong>目的</strong>：确保从公司内网拉取镜像，不受外网限制。</p>\n</blockquote>\n<ol>\n<li>编辑<code>/etc/docker/daemon.json</code>：</li>\n</ol>\n<ul>\n<li>打开</li>\n</ul>\n<pre><code class=\"language-bash\">sudo nano /etc/docker/daemon.json\n</code></pre>\n<ul>\n<li>编辑：<code>Ctrl + O</code>、<code>回车</code>、<code>Ctrl + X</code></li>\n</ul>\n<pre><code class=\"language-bash\">待整理\n</code></pre>\n<ol start=\"3\">\n<li>重启Docker</li>\n</ol>\n<pre><code class=\"language-bash\">sudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<h4 id=\"4-测试Docker是否能正常拉取镜像\"><a href=\"#4-测试Docker是否能正常拉取镜像\" class=\"headerlink\" title=\"4. 测试Docker是否能正常拉取镜像\"></a>4. 测试Docker是否能正常拉取镜像</h4><blockquote>\n<p><strong>目的</strong>：确认内网镜像访问权限与代理配置无误。</p>\n</blockquote>\n<ol>\n<li>登录公司私有仓库</li>\n</ol>\n<pre><code class=\"language-bash\">待整理\n</code></pre>\n<ol start=\"2\">\n<li>测试拉取</li>\n</ol>\n<pre><code class=\"language-bash\">待整理\n</code></pre>\n<ol start=\"3\">\n<li>查看输出</li>\n</ol>\n<pre><code># 类似如下格式则表示拉取成功\nStatus: Downloaded newer image for ……\n</code></pre>\n<h4 id=\"5-（可选）给当前用户添加Docker权限\"><a href=\"#5-（可选）给当前用户添加Docker权限\" class=\"headerlink\" title=\"5. （可选）给当前用户添加Docker权限\"></a>5. （可选）给当前用户添加Docker权限</h4><blockquote>\n<p><strong>目的</strong>：避免每次都要sudo。</p>\n</blockquote>\n<pre><code class=\"language-bash\">sudo usermod -aG docker $USER\nnewgrp docker\n</code></pre>\n<h4 id=\"6-启动容器-运行项目\"><a href=\"#6-启动容器-运行项目\" class=\"headerlink\" title=\"6. 启动容器 运行项目\"></a>6. 启动容器 运行项目</h4><blockquote>\n<p><strong>目的</strong>：实际部署&#x2F;运行镜像中的项目。</p>\n</blockquote>\n<p>举例：</p>\n<pre><code class=\"language-bash\">待整理\n</code></pre>\n<h4 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a><strong>补充</strong></h4><p>为了优化我们在Ubuntu的使用体验，可以安装增强功能（Guest Additions）：<br><a href=\"https://download.virtualbox.org/virtualbox/7.2.0/\">点此安装iso镜像文件</a></p>\n<ol>\n<li><p>上方任务栏 -&gt; <strong>设备</strong> -&gt; 安装增强功能。</p>\n</li>\n<li><p>启动<strong>终端</strong>，安装前置包。</p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-get install gcc make perl\n</code></pre>\n<ol start=\"3\">\n<li><p>点击左侧边栏的<strong>光盘图标</strong> -&gt; VboxWindowsAdditions.exe （我这里是VBox_GAs_7.2.0）-&gt; 选择运行软件：<br>终端此时会自动执行安装命令。</p>\n</li>\n<li><p>重启再<strong>验证</strong>：</p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">sudo reboot\nlsmod | grep vbox\n</code></pre>\n<ol start=\"5\">\n<li><p>如果出现<strong>vboxguest</strong>、vboxvideo等等：<br>那就是安装成功了！<br>缺少你需要的功能或是没有成功，那就多安装几次试试；sudo命令安装方法同理。</p>\n</li>\n<li><p>VirtualBox+Ubuntu<strong>全屏显示</strong><br>前五步完成后自动全屏显示了。</p>\n</li>\n<li><p>主机与虚拟机之间的<strong>复制粘贴</strong></p>\n<blockquote>\n<p>Oracle VirtualBox管理器 -&gt; 设置 -&gt; 常规 -&gt; Features&#x2F;高级</p>\n</blockquote>\n</li>\n</ol>\n<p>把Shared Clipboard（共享粘贴板）和Drag-and-Drop（拖放）都设置为双向。</p>\n<p>如果你装了很久都没能复制粘贴……😭请一定要注意：<em><strong>桌面环境可直接Ctr+C&#x2F;V，但是终端需要Ctrl+Shift+C&#x2F;V！！！</strong></em></p>\n<h2 id=\"参考教程\"><a href=\"#参考教程\" class=\"headerlink\" title=\"参考教程\"></a>参考教程</h2><ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/1892960016316748037\">(14 封私信 &#x2F; 78 条消息) Docker入门教程（非常详细）从零基础入门到精通，看完这一篇就够了 - 知乎</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/weixin_74135521/article/details/145969933\">安装Ubuntu遇见正在复制文件卡住时，仅需断网即可-CSDN博客</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/wanghuizhao/p/16923829.html\">VirtualBox-Ubuntu-主机和虚拟机实现互相复制粘贴 - 夏夜星空晚风 - 博客园</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/weixin_41812346/article/details/150585718?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-150585718-blog-48729471.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-150585718-blog-48729471.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=6\">VirtualBox下载安装-创建Ubuntu虚拟机-增强功能（共享剪切板，共享文件夹）-中文输入法ibus(pinyin)-Chrome_virtualbox7.2 guest additions-CSDN博客</a></p>\n</li>\n<li><p>公司善良IT大佬の建议</p>\n</li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/10/25/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Git%20&%20GitHub%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/",
            "url": "https://232akira.github.io/2025/10/25/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Git%20&%20GitHub%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/",
            "title": "笔记🗒️ ⋮ Git相关",
            "date_published": "2025-10-25T05:12:12.000Z",
            "content_html": "<p>Git相关补充也可访问：</p>\n<ul>\n<li>指南🧭 ⋮ 开源贡献</li>\n<li>指南🧭 ⋮ Obsidian Git同步</li>\n</ul>\n<h3 id=\"Repo\"><a href=\"#Repo\" class=\"headerlink\" title=\"Repo\"></a>Repo</h3><p>repository，代码仓库</p>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><p>分叉</p>\n<h3 id=\"Clone\"><a href=\"#Clone\" class=\"headerlink\" title=\"Clone\"></a>Clone</h3><p>克隆</p>\n<h3 id=\"Issues\"><a href=\"#Issues\" class=\"headerlink\" title=\"Issues\"></a>Issues</h3><p>议题</p>\n<h3 id=\"PR（Pull-Requests）\"><a href=\"#PR（Pull-Requests）\" class=\"headerlink\" title=\"PR（Pull Requests）\"></a>PR（Pull Requests）</h3><p>合并申请。请求原作者把你fork仓库里的某个branch的改动，merge进他们的主仓库。</p>\n<h3 id=\"Wiki\"><a href=\"#Wiki\" class=\"headerlink\" title=\"Wiki\"></a>Wiki</h3><h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><p>分支</p>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h3><p>合并</p>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h3><p>提交</p>\n<h3 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h3><p>Frequently Asked Questions，常见问题解答。</p>\n<h3 id=\"Issue状态\"><a href=\"#Issue状态\" class=\"headerlink\" title=\"Issue状态\"></a>Issue状态</h3><ul>\n<li>open（开启）</li>\n<li>closed（关闭）</li>\n<li>reopened（重新开启）</li>\n</ul>\n<h3 id=\"任务状态\"><a href=\"#任务状态\" class=\"headerlink\" title=\"任务状态\"></a>任务状态</h3><p>（Task Status，看板状态）</p>\n<ul>\n<li>TODO（待办）</li>\n<li>WIP（Work In Progress，进行中）</li>\n<li>Done（已完成）</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ol>\n<li><p>一个Issue可关联多个任务，每个任务有自己的<span style=\"border-bottom:2px dashed pink;\">任务状态</span>，每个Issue有自己的<span style=\"border-bottom:2px dashed pink;\">issue状态</span>。</p>\n</li>\n<li><p>画了张图：<br><a href=\"https://imgchr.com/i/pVvWksU\"><img loading=\"lazy\" data-src=\"https://s21.ax1x.com/2025/10/26/pVvWksU.png\" alt=\"常用Git关系\"></a></p>\n</li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/09/29/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/",
            "url": "https://232akira.github.io/2025/09/29/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/",
            "title": "笔记🗒️ ⋮ AI Agent",
            "date_published": "2025-09-29T08:30:01.000Z",
            "content_html": "<h3 id=\"Agent\"><a href=\"#Agent\" class=\"headerlink\" title=\"Agent\"></a>Agent</h3><blockquote>\n<p><strong>长期以来</strong>，通用人工智能（Artificial General Intelligence，<strong>AGI</strong>）<strong>一直被人类所追求</strong>。<br>从1950年代Alan Turing的设想开始，Agent技术从早期的构想阶段逐渐成熟并落地，在2020年至今进入了爆发期——大模型Agent时代。</p>\n</blockquote>\n<p><strong>AI Agent</strong>（Agent&#x2F;代理&#x2F;智能体…）更具备“人类”的思维方式，可以识别任务的需求分析、执行规划和问题决策。</p>\n<p><strong>有一种说法……💭</strong><br>AI Agent是prompt工程的一种升级。而当下的商业产品也确实在走着<code>Chatbot</code>-&gt;<code>Copilot</code>-&gt;<code>Agent</code>的演变路径。</p>\n<h3 id=\"基于LLM驱动的AI-Agent\"><a href=\"#基于LLM驱动的AI-Agent\" class=\"headerlink\" title=\"基于LLM驱动的AI Agent\"></a>基于LLM驱动的AI Agent</h3><p><a href=\"https://imgchr.com/i/pVyvhy6\"><img loading=\"lazy\" data-src=\"https://s21.ax1x.com/2025/08/27/pVyvhy6.png\" alt=\"pVyvhy6.png\"></a></p>\n<p>当下，我们常见的<strong>Agent</strong>往往就是<strong>基于LLM驱动的</strong>AI Agent。在其体系中，LLM作为智能体的“大脑”（🧠），其他能力，如规划（Planning）、记忆（Memory）、工具使用（Tools）等作为补充。</p>\n<h4 id=\"1️⃣规划能力（Planning）\"><a href=\"#1️⃣规划能力（Planning）\" class=\"headerlink\" title=\"1️⃣规划能力（Planning）\"></a>1️⃣规划能力（Planning）</h4><p><strong>1.  任务拆解</strong></p>\n<ul>\n<li><p><strong>CoT（Chain of Thought）思维链</strong><br>告知模型要“step by step”，也就是去尝试把复杂任务拆解成更小的、更简单的任务列表。其使模型的思考过程更可解释。</p>\n</li>\n<li><p><strong>ToT（Tree of Thoughts）思维树</strong><br>ToT继承了CoT，并在CoT的基础上做了扩展：进一步要求LLM对子步骤生成更多思考，形成思维树。其结果的搜索可以是<code>BFS</code>（breadth-first search）或<code>DFS</code>(depth-first search)。</p>\n</li>\n</ul>\n<p><strong>2.  自我反思</strong></p>\n<ul>\n<li><strong>ReAct（Reasoning and Acting）</strong><blockquote>\n<p><strong>注意</strong>：是<a href=\"https://arxiv.org/pdf/2210.03629\">ReAct</a>不是前端框架React！</p>\n</blockquote>\n</li>\n</ul>\n<p>即<strong>推理与行动</strong>：追踪LLM的生成过程（与外部系统交互、思考等）。相当于用自然语言做logging。</p>\n<ul>\n<li><p><strong>Reflexion</strong><br>即<strong>反思</strong>：给agents装备动态记忆和自我反省能力，以增强推理能力的框架。</p>\n<blockquote>\n<p><strong>注意</strong>：区别<code>reflection</code>与<code>reflexion</code>!</p>\n</blockquote>\n</li>\n<li><p><strong>CoH（Chain of Hindsight）后见链</strong><br>让模型学习人类是如何根据反馈（尤其是负面反馈）来逐步改进和修正其输出的。其本质上是一种模型训练方法&#x2F;推理策略，而不是像CoT、ToT、ReAct那样的<a href=\"\">Prompt Engineering</a>。</p>\n</li>\n</ul>\n<h4 id=\"2️⃣记忆能力（Memory）\"><a href=\"#2️⃣记忆能力（Memory）\" class=\"headerlink\" title=\"2️⃣记忆能力（Memory）\"></a>2️⃣记忆能力（Memory）</h4><p>记忆可以被定义为获取、存储、保留、事后取回等针对信息的流程。一定程度上可与人类的记忆类型进行映射。</p>\n<p><a href=\"https://imgchr.com/i/pVyzlVS\"><img loading=\"lazy\" data-src=\"https://s21.ax1x.com/2025/08/27/pVyzlVS.jpg\" alt=\"pVyzlVS.jpg\"></a></p>\n<p>这里就不照搬<a href=\"https://lilianweng.github.io/posts/2023-06-23-agent/\">原文</a>了，简单拉个表总结一下👇</p>\n<table>\n<thead>\n<tr>\n<th>记忆类型</th>\n<th>英文名</th>\n<th>时长</th>\n<th>人类记忆</th>\n<th>映射到Agent</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>感觉记忆</td>\n<td><strong>Sensory</strong> Memory</td>\n<td>几秒</td>\n<td>瞬间的原始感官输入</td>\n<td>对原始输入做Embedding</td>\n</tr>\n<tr>\n<td>短期记忆</td>\n<td><strong>Short-Term</strong> Memory</td>\n<td>20~30秒</td>\n<td>临时存储少量信息</td>\n<td>上下文学习（In-Context Learning）</td>\n</tr>\n<tr>\n<td>长期记忆</td>\n<td><strong>Long-Term</strong> Memory</td>\n<td>几天~几十年</td>\n<td>长期存储大量信息</td>\n<td>外部的向量数据库</td>\n</tr>\n</tbody></table>\n<h4 id=\"3️⃣工具使用（Tool-use）\"><a href=\"#3️⃣工具使用（Tool-use）\" class=\"headerlink\" title=\"3️⃣工具使用（Tool use）\"></a>3️⃣工具使用（Tool use）</h4><p><strong>调用外部API</strong></p>\n<p><strong>1. function call：</strong></p>\n<ul>\n<li>函数调用</li>\n</ul>\n<p><strong>2. mcp（model context protocol）：</strong></p>\n<ul>\n<li>模型上下文协议</li>\n</ul>\n<h2 id=\"开源框架\"><a href=\"#开源框架\" class=\"headerlink\" title=\"开源框架\"></a>开源框架</h2><h3 id=\"CrewAI\"><a href=\"#CrewAI\" class=\"headerlink\" title=\"CrewAI\"></a>CrewAI</h3><p><a href=\"https://crewai.org.cn/\">CrewAI官网戳此</a></p>\n<ul>\n<li>Multi-Agent</li>\n<li>Orchestration</li>\n<li>Collaboration</li>\n<li>Crews</li>\n<li>Process</li>\n</ul>\n<h3 id=\"LangGraph\"><a href=\"#LangGraph\" class=\"headerlink\" title=\"LangGraph\"></a>LangGraph</h3><p><a href=\"https://www.langchain.com/langgraph\">LangGraph官网戳此</a></p>\n<ul>\n<li>Stateful</li>\n<li>Workflows</li>\n<li>Cycles</li>\n<li>Graph</li>\n<li>Control Flow</li>\n</ul>\n<h3 id=\"LlamaIndex\"><a href=\"#LlamaIndex\" class=\"headerlink\" title=\"LlamaIndex\"></a>LlamaIndex</h3><p><a href=\"https://docs.llamaindex.ai/en/stable/\">LlamaIndex官网戳此</a></p>\n<ul>\n<li>Data</li>\n<li>RAG</li>\n<li>Retrieval</li>\n<li>Querying</li>\n</ul>\n<h3 id=\"Strands-Agents\"><a href=\"#Strands-Agents\" class=\"headerlink\" title=\"Strands Agents\"></a>Strands Agents</h3><p><a href=\"https://strandsagents.com/latest/\">Strands Agents官网戳此</a></p>\n<ul>\n<li>Financial</li>\n<li>Data Analysis</li>\n<li>Pre-built</li>\n<li>Domain-Specific</li>\n</ul>\n<h2 id=\"Agent-Infra\"><a href=\"#Agent-Infra\" class=\"headerlink\" title=\"Agent Infra\"></a>Agent Infra</h2><ul>\n<li>即AI Agentic基础设施</li>\n</ul>\n<h3 id=\"AgentCore\"><a href=\"#AgentCore\" class=\"headerlink\" title=\"AgentCore\"></a>AgentCore</h3><ul>\n<li>即Amazon Bedrock AgentCore</li>\n</ul>\n<blockquote>\n<p><em><strong>未完待续……</strong></em></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><p><strong><a href=\"https://lilianweng.github.io/posts/2023-06-23-agent/\">LLM Powered Autonomous Agents | Lil’Log</a> ⭐</strong></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/641322714\">LLM Powered Autonomous Agents（中翻+insight） - 知乎</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/678046050\">7000长文：一文读懂Agent，大模型的下一站 - 知乎</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/2401_84204207/article/details/147516308\">380篇文献！首份Agentic大模型最新技术综述_agentic+llm-CSDN博客</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/2532014\">【科普篇】LLM、GPT、AIGC、AI Agent、Agentic AI 到底是个啥？-腾讯云开发者社区-腾讯云</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/641322714\">(9 封私信) LLM Powered Autonomous Agents（中翻+insight） - 知乎</a></p>\n</li>\n<li><p><a href=\"https://www.woshipm.com/ai/6246084.html\">万字Agent详解：Agent的发展和应用 | 人人都是产品经理</a></p>\n</li>\n<li><p><a href=\"https://react-lm.github.io/\">ReAct: Synergizing Reasoning and Acting in Language Models</a></p>\n</li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/09/14/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/",
            "url": "https://232akira.github.io/2025/09/14/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/",
            "title": "笔记🗒️ ⋮ 评论系统配置",
            "date_published": "2025-09-14T13:38:03.000Z",
            "content_html": "<blockquote>\n<p>先叨叨一下心路历程。一开始在死磕<strong>waline</strong>的配置（+vercle），结果就是前端有评论模块，但是点击提交评论就会报错<code>Failed to fetch</code>，历经多月绞尽脑汁最终惨败。<br>今天突发奇想换成<strong>twikoo</strong>试一下，结果跟着官方教程一遍过了😭特别感动！！！</p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li>本博客的美丽主题来自👉<a href=\"https://github.com/theme-shoka-x/hexo-theme-shokaX\">ShokaX</a></li>\n<li>美丽主题的评论系统配置<a href=\"https://docs.shokax.kaitaku.xyz/features/comments/\">戳此</a></li>\n<li>Twikoo快速上手<a href=\"https://twikoo.js.org/quick-start.html\">戳此</a></li>\n</ul>\n<h2 id=\"开始配置\"><a href=\"#开始配置\" class=\"headerlink\" title=\"开始配置\"></a>开始配置</h2><p>此博客用的是shokax官方推荐的<code>云函数部署</code>-&gt;<code>Vercel部署</code>的方式。</p>\n<p>主要在<strong>两个网站</strong>上操作：</p>\n<ol>\n<li><code>MongoDB Atlas</code>：云端数据库托管服务</li>\n<li><code>Vercel</code>：云端部署平台</li>\n</ol>\n<p><code>MongoDB Atlas</code>、<code>Vercel</code>、<code>用户评论</code><strong>三者的关系</strong>可以理解为：</p>\n<pre><code class=\"language-bash\">用户评论 -- Vercel --&gt; MongoDB（长期保存）\n</code></pre>\n<h3 id=\"MongoDB-Atlas\"><a href=\"#MongoDB-Atlas\" class=\"headerlink\" title=\"MongoDB Atlas\"></a>MongoDB Atlas</h3><p>官方教程<a href=\"https://twikoo.js.org/mongodb-atlas.html\">戳此</a>。</p>\n<ol>\n<li>注册账号</li>\n<li>新建数据库（区域选择AWS）</li>\n<li>Database Access-&gt;新建权限为Admin的用户并记住账号密码</li>\n<li>Network Access-&gt;添加网络白名单（0.0.0.0&#x2F;0）</li>\n<li>Database-&gt;Connect-&gt;Drivers</li>\n<li>复制<code>数据库连接字符串</code>（<code>&lt;username&gt;:&lt;passname&gt;</code>修改为<code>用户名：密码</code>）</li>\n</ol>\n<p>⚠注意替换用户名密码时把原尖括号删掉！！！</p>\n<h3 id=\"Vercel\"><a href=\"#Vercel\" class=\"headerlink\" title=\"Vercel\"></a>Vercel</h3><p>官方教程<a href=\"https://twikoo.js.org/backend.html#vercel-%E9%83%A8%E7%BD%B2\">戳此</a>。</p>\n<ol>\n<li>注册账号</li>\n<li>将twikoo<a href=\"https://vercel.com/import/project?template=https://github.com/twikoojs/twikoo/tree/main/src/server/vercel-min\">一键部署</a>到vercel</li>\n<li>进入你上一步部署的repo-&gt;settings</li>\n<li>settings-&gt;Environment Variables-&gt;添加环境变量（NAME:<code>MONGODB_URI</code>；VALUE：<code>数据库连接字符串</code>）</li>\n<li>弹窗-&gt;Redeploy</li>\n<li>settings-&gt;Deployment Protection-&gt;<code>Vercel Authentication</code>设置为<code>Disabled</code></li>\n<li>弹窗-&gt;Redeploy</li>\n<li>Overview-&gt;visit-&gt;Twikoo云函数运行正常</li>\n<li>复制<code>visit跳转的网址</code></li>\n</ol>\n<h3 id=\"config-shokax-yml\"><a href=\"#config-shokax-yml\" class=\"headerlink\" title=\"_config.shokax.yml\"></a>_config.shokax.yml</h3><pre><code class=\"language-bash\">#twikoo评论配置\ntwikoo:\n  enable: true # 是否开启\n  mode: vercel # vercel(私有部署) 或 tencent\n  envId: &quot;visit跳转的网址&quot; # twikoo 环境 ID,vercel 和私有部署填地址\n  region: # vercel 和私有部署不填，腾讯云见 twikoo 文档\n</code></pre>\n<hr>\n<p>评论系统就这样配好了！欢迎宝宝们友好交流！！o(<em>￣▽￣</em>)ブ~♥</p>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20MCP%EF%BC%88Model%20Context%20Protocol%EF%BC%89/",
            "url": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20MCP%EF%BC%88Model%20Context%20Protocol%EF%BC%89/",
            "title": "笔记🗒️ ⋮ MCP（Model Context Protocol）",
            "date_published": "2025-08-24T08:30:03.000Z",
            "content_html": "<h2 id=\"应用背景\"><a href=\"#应用背景\" class=\"headerlink\" title=\"应用背景\"></a>应用背景</h2><blockquote>\n<p>你是否向大模型提问过：“现在几点了？”“我这里的天气怎么样？”的问题？那么它能够正确回答吗？</p>\n<p>目前来看——一般会回答错误。</p>\n</blockquote>\n<p>当下，LLM的能力早已不局限于“文本生成”，而是能够通过外部工具的调用变得“手眼通天”：脱离原有的封闭环境，获得了<strong>与外部环境交互</strong>的能力。</p>\n<p>相当于给大模型加上了手脚🧐</p>\n<p><strong>与外部环境交互</strong>通过<code>MCP</code>进行工具调用的规范化，通过<code>A2A</code>实现Agent与Agent之间交互的规范化。</p>\n<h2 id=\"Function-Calling-MCP\"><a href=\"#Function-Calling-MCP\" class=\"headerlink\" title=\"Function Calling-&gt;MCP\"></a>Function Calling-&gt;MCP</h2><p>工具调用基于<code>function calling</code>实现并被广泛用于商业API交互，目前国产的主流LLM大多已支持。<br>而Ahthropic推出的<strong>MCP</strong>（Model Context Protocol）正是针对“工具调用接口的规范化”应运而生的协议。</p>\n<blockquote>\n<p>调用的过程其实是让大模型理解我们需求的过程。</p>\n</blockquote>\n<p>这里按个人理解写一下MCP应用流程：</p>\n<pre><code>用户通过配置MCP服务-&gt;提供工具调用的相关函数及其对应的传参要求，\n\n模型在\n  - 理解用户需求\n  - 学会函数对应参数的攥写格式\n的基础上，\n判断函数是否调用、如何调用、拿到返回的结果后如何分析。\n</code></pre>\n<blockquote>\n<p>Function Calling和MCP是当前技术落地的核心方式。前者侧重模型原生能力，后者强调协议标准化。</p>\n</blockquote>\n<p>那么AI Agent（人工智能代理&#x2F;智能体）则为更高阶的形态，其融合了自主决策+工具调用，能够更加适用于复杂场景。</p>\n<h2 id=\"MCP-A2A\"><a href=\"#MCP-A2A\" class=\"headerlink\" title=\"MCP-&gt;A2A\"></a>MCP-&gt;A2A</h2><p>若再视野拓展至MAS（Multi-Agent Systems）的多智能体系统协作领域，我们就不能不提起<strong>A2A</strong>（Agent-to-Agent Protocol,代理间通信协议）。</p>\n<p>到这里可以将上文提到的三个概念搭建为三层级的技术栈模型：</p>\n<pre><code>       【A2A】         // Agent与Agent~协作网络\n          ↑\n       【MCP】         // Agent与工具~资源与会话管理\n          ↑\n 【Function Calling】  //模型原生能力\n</code></pre>\n<p>Google将A2A比作互联网早期的HTTP协议</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/1916821381879931822\">(7 封私信) 深度研究报告：大模型工具调用（Tool-use）的技术演进与协议生态分析 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/hwhsong/article/details/147244842\">【AI学习】大模型调用外部工具的主流方式对比_大模型工具调用-CSDN博客</a></li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20LangChain/",
            "url": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20LangChain/",
            "title": "笔记🗒️ ⋮ LangChain",
            "date_published": "2025-08-24T08:30:02.000Z",
            "content_html": "<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p><strong>LangChain是一个</strong>用于开发由语言模型驱动的应用程序的<strong>框架</strong>。也就是可以将LLM、向量数据库、交互层prompt、外部知识和外部工具等整合到一起</p>\n<h2 id=\"六大组件\"><a href=\"#六大组件\" class=\"headerlink\" title=\"六大组件\"></a>六大组件</h2><p>LangChain的六大组件分别是：</p>\n<ul>\n<li>Model I&#x2F;O</li>\n<li>Data Connection</li>\n<li>Chains</li>\n<li>Memory</li>\n<li>Agent</li>\n<li>Callback</li>\n</ul>\n<h3 id=\"1-Model-I-O\"><a href=\"#1-Model-I-O\" class=\"headerlink\" title=\"1. Model I&#x2F;O\"></a>1. Model I&#x2F;O</h3><blockquote>\n<p>模型输入输出</p>\n</blockquote>\n<h3 id=\"2-Data-Connection\"><a href=\"#2-Data-Connection\" class=\"headerlink\" title=\"2. Data Connection\"></a>2. Data Connection</h3><blockquote>\n<p>数据连接&#x2F;增强</p>\n</blockquote>\n<p>提供文档加载、转换、存储和查询数据的构建块。</p>\n<h3 id=\"3-Chains\"><a href=\"#3-Chains\" class=\"headerlink\" title=\"3. Chains\"></a><strong>3. Chains</strong></h3><blockquote>\n<p>链</p>\n</blockquote>\n<p>多个LLM模型包装器或其他组件进行链式连接。</p>\n<h3 id=\"4-Memory\"><a href=\"#4-Memory\" class=\"headerlink\" title=\"4. Memory\"></a>4. Memory</h3><blockquote>\n<p>记忆</p>\n</blockquote>\n<p>支持读取和写入记忆模块，可独立使用或集成到链。</p>\n<h3 id=\"5-Agent\"><a href=\"#5-Agent\" class=\"headerlink\" title=\"5. Agent\"></a><strong>5. Agent</strong></h3><blockquote>\n<p>代理</p>\n</blockquote>\n<p>利用LLM选择操作序列而非硬编码。</p>\n<h3 id=\"6-Callback\"><a href=\"#6-Callback\" class=\"headerlink\" title=\"6. Callback\"></a>6. Callback</h3><blockquote>\n<p>回调</p>\n</blockquote>\n<p>允许开发者在LLM应用的各个阶段对状态进行干预。</p>\n<h2 id=\"ReAct\"><a href=\"#ReAct\" class=\"headerlink\" title=\"ReAct\"></a>ReAct</h2><p>在<a href=\"https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/\">笔记🗒️ ⋮ AI Agent</a>中也有提到。这里详细说明一下LangChain</p>\n<blockquote>\n<p><em><strong>未完待续……</strong></em></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><p><a href=\"https://python.langchain.com/docs/get_started/introduction\">https://python.langchain.com/docs/get_started/introduction</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/2301_81940605/article/details/138605789\">全网最全：一文入门最热的LLM应用开发框架LangChain_langchain开发-CSDN博客</a></p>\n</li>\n<li></li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/",
            "url": "https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/",
            "title": "笔记🗒️ ⋮ 游戏开发",
            "date_published": "2025-04-06T14:22:22.000Z",
            "content_html": "<p>👌当下主要学习<strong>图形</strong>方向，具体细节可以查看<a href=\"https://docs.unity3d.com/cn/current/Manual/Graphics.html\">Unity官方文档</a>。</p>\n<pre><code>渲染管线\n摄像机\n光照\n模型\n网格\n纹理\n着色器\n材质\nVisual effects\n天空\n颜色\n图形API\nGraphics performance and profiling\n</code></pre>\n<blockquote>\n<p>虽然自己程序方面更擅长C++而且现在用UE也是个趋势，但是Unity普及度更高而且教程更多，UE蓝图也摒弃了传统的纯程序开发路线，所以打好这方面基础是现在最需要做的。如果有任何建议和想法需要交流欢迎联系我！不断试错不断学习中🤗</p>\n</blockquote>\n<p>笔记内容90%来自视频原话，其他内容个人补充，欢迎勘误。<br>学习内容大多来自b站佬们的教程（先三连之后看的！）🤟参考链接点击标题跳转</p>\n<h1 id=\"项目实战-Uinty\"><a href=\"#项目实战-Uinty\" class=\"headerlink\" title=\"项目实战-Uinty\"></a>项目实战-Uinty</h1><h2 id=\"Shader代码基础\"><a href=\"#Shader代码基础\" class=\"headerlink\" title=\"Shader代码基础\"></a><a href=\"https://www.bilibili.com/video/BV1Xu4y1S7LF/?spm_id_from=333.1387.favlist.content.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">Shader代码基础</a></h2><h3 id=\"PART1\"><a href=\"#PART1\" class=\"headerlink\" title=\"PART1\"></a>PART1</h3><h4 id=\"Shader代码基本架构\"><a href=\"#Shader代码基本架构\" class=\"headerlink\" title=\"Shader代码基本架构\"></a>Shader代码基本架构</h4><pre><code class=\"language-c#\">Shader&quot;1️⃣&quot;\n&#123;\n    Properties\n    &#123;\n    2️⃣\n    &#125;\n    SubShader\n    &#123;\n    ️3️⃣\n        Pass\n        &#123;\n        4️⃣\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>1️⃣Shader名称</strong></p>\n<p><strong>2️⃣定义变量位置</strong><br>常见的五种变量类型:</p>\n<ul>\n<li>Float</li>\n<li>Range</li>\n<li>Vector</li>\n<li>Color</li>\n<li>Texture</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        //常用的五种数据类型\n        _Float(&quot;Float&quot;,Float)=0.0\n        _Range(&quot;Range&quot;,Range(0.0,1.0))=0.0\n        _Vector(&quot;Vector&quot;,Vector)=(1,1,1,1)\n        _Color(&quot;Color&quot;,Color)=(0.5,0.5,0.5,0.5)\n        _Texture(&quot;Texture&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n</code></pre>\n<p><strong>3️⃣主要Shader代码部分</strong><br>可以理解成一个Pass等于一个完整的GPU渲染管线，SubShader里可以写多个Pass，写几个代表会被重复渲染几次，而且每次调用的Shader都不一样。</p>\n<pre><code class=\"language-c#\">            CGPROGRAM\n            //中间的任何代码都属于unity cg的范围\n            ENDCG\n</code></pre>\n<ol>\n<li>这里对于<code>float</code>类型<a href=\"https://docs.unity3d.com/cn/current/Manual/SL-VertexProgramInputs.html\">补充</a>一点：</li>\n</ol>\n<ul>\n<li>‌<code>float‌</code>：用于表示单个浮点数，常用于颜色通道、位置坐标等。</li>\n<li>‌<code>float2‌</code>（Vector2）：用于表示二维向量，如二维坐标、UV坐标等。</li>\n<li>‌<code>float3‌</code>（Vector3）：用于表示三维向量，如位置、法线等。</li>\n<li>‌<code>float4‌</code>（Vector4）：用于表示四维向量，如颜色、四元数等。</li>\n</ul>\n<ol start=\"2\">\n<li><p>在unity中，一个模型最多有四套UV</p>\n</li>\n<li><p>float&#x2F;half&#x2F;fixed的区别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">位宽</th>\n<th align=\"center\">适用范围</th>\n<th align=\"center\">常见用途</th>\n<th align=\"center\">精度</th>\n<th align=\"center\">现代GPU支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32-bit</td>\n<td align=\"center\">大</td>\n<td align=\"center\">位置、物理计算、PBR</td>\n<td align=\"center\">高</td>\n<td align=\"center\">强烈推荐</td>\n</tr>\n<tr>\n<td align=\"center\">half</td>\n<td align=\"center\">16-bit</td>\n<td align=\"center\">中</td>\n<td align=\"center\">颜色计算、法线、屏幕后处理</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">推荐（移动端优化）</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">10-bit</td>\n<td align=\"center\">小</td>\n<td align=\"center\">颜色计算（老设备）</td>\n<td align=\"center\">低</td>\n<td align=\"center\">几乎淘汰</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"GPU渲染管线\"><a href=\"#GPU渲染管线\" class=\"headerlink\" title=\"GPU渲染管线\"></a>GPU渲染管线</h4><p><strong>基本结构</strong>：</p>\n<pre><code class=\"language-bash\">【模型数据】 -&gt; 1️⃣【顶点Shader】 -&gt; 2️⃣【图元装配及光栅化】 -&gt; 3️⃣【片元Shader】 -&gt; 4️⃣【输出合并】\n            |-----------------------------GPU渲染管线---------------------------------------|\n</code></pre>\n<p><strong>1️⃣顶点Shader</strong>：</p>\n<ul>\n<li>将模型数据的模型空间坐标转换到对应的裁剪空间，即输出在裁剪空间下的顶点坐标</li>\n<li>【模型空间】 -&gt; 世界空间 -&gt; 相机空间 -&gt; 【裁剪空间】，中间经过三个矩阵（Model,View,Projection）操作</li>\n</ul>\n<p><strong>2️⃣图元装配及光栅化</strong></p>\n<ul>\n<li>硬件阶段</li>\n<li>生成片元并进行光栅化插值</li>\n</ul>\n<p><strong>3️⃣片元Shader</strong></p>\n<ul>\n<li>每个片元调用片元shader给自身着色</li>\n<li>计算对应的颜色后输出</li>\n</ul>\n<p><strong>4️⃣输出合并</strong></p>\n<ul>\n<li>输出到对应的帧缓冲区</li>\n</ul>\n<p><em><strong>一个完整的Shader通常由顶点Shader和片段Shader共同组成。</strong></em></p>\n<h4 id=\"完整Shader代码\"><a href=\"#完整Shader代码\" class=\"headerlink\" title=\"完整Shader代码\"></a>完整Shader代码</h4><pre><code class=\"language-c#\">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;\n// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;\nShader &quot;CS0102/shader&quot;\n&#123;\n    Properties\n    &#123;\n        // 常用的五种数据类型\n        _Float(&quot;Float&quot;, Float) = 0.0\n        _Range(&quot;Range&quot;, Range(0.0, 1.0)) = 0.0\n        _Vector(&quot;Vector&quot;, Vector) = (1,1,1,1)\n        _Color(&quot;Color&quot;, Color) = (0.5,0.5,0.5,0.5)\n        //_Texture(&quot;Texture&quot;, 2D) = &quot;black&quot; &#123;&#125; \n        _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            // Shader 主要代码部分\n            CGPROGRAM\n            #pragma vertex vert // 指定一个顶点 Shader：vert\n            #pragma fragment frag // 指定一个片元 Shader：frag\n            #include &quot;UnityCG.cginc&quot; // 头文件\n\n            // 从 CPU 端获取模型数据\n            struct appdata &#123;\n                float4 vertex : POSITION;  // 模型顶点坐标\n                // 第一套uv，共4个可用（TEXCOORD0~TEXCOORD3）\n                float2 uv : TEXCOORD0; \n                float3 normal : NORMAL;    // 法线\n                float4 color : COLOR;      // 顶点色\n            &#125;;\n            // 输出结构体定义\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                //通用储存器（插值器），共16个可用（TEXCOORD0~TEXCOORD15）\n                float2 uv:TEXCOORD0;\n            &#125;;\n            float4 _Color;\n            sampler2D _MainTex;\n            float4 _MainTex_ST;//动态链接四个参数\n            // 顶点 Shader\n            v2f vert(appdata v) &#123;\n                v2f o;\n                //float4 pos_world = mul(unity_ObjectToWorld, v.vertex); // 模型空间转世界空间\n                //float4 pos_clip = mul(UNITY_MATRIX_VP, pos_world); // 世界空间直接变换到裁剪空间\n                //o.pos = pos_clip;\n                //或者直接合成一个mvp操作\n                o.pos=UnityObjectToClipPos(v.vertex);\n                //输出uv值\n                //o.uv=v.uv;\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            // 片元 Shader\n            float4 frag(v2f i) : SV_Target &#123;\n                //贴图采样\n                float4 col=tex2D(_MainTex,i.uv);\n                return col;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"PART2\"><a href=\"#PART2\" class=\"headerlink\" title=\"PART2\"></a>PART2</h3><h4 id=\"背面剔除（Backface-Culling）\"><a href=\"#背面剔除（Backface-Culling）\" class=\"headerlink\" title=\"背面剔除（Backface Culling）\"></a>背面剔除（Backface Culling）</h4><p>背面剔除在硬件阶段、NDC空间之后进行，Unity默认使用背面剔除（只渲染正面）。</p>\n<ol>\n<li>Shader代码控制:直接显示出渲染结果</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull Off  //1️⃣不剔除\n            Cull Back //2️⃣默认剔除背面\n            Cull Front//3️⃣剔除正面\n            //注意在CGPROGRAM之前\n            CGPROGRAM\n            ...\n            ENDCG\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>材质球控制：物体材质球处出现可选项：Off&#x2F;Front&#x2F;Back</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull [_CullMode]\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"PART3-纹理映射\"><a href=\"#PART3-纹理映射\" class=\"headerlink\" title=\"PART3 纹理映射\"></a>PART3 纹理映射</h3><h4 id=\"正面纹理采样设定\"><a href=\"#正面纹理采样设定\" class=\"headerlink\" title=\"正面纹理采样设定\"></a>正面纹理采样设定</h4><p>这里用XY坐标值采样贴图，即uv按模型本身的XY展开。<br>代码如下：</p>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                ...\n                float2 pos_uv:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                ...\n                o.pos_uv=v.vertex.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.pos_uv);\n                return col;\n            &#125;\n</code></pre>\n<p>👉️补充：</p>\n<ul>\n<li>正面 XY平面</li>\n<li>侧面 ZY平面</li>\n<li>俯视 XZ平面</li>\n</ul>\n<p>总结：纹理映射的来源不一定是单纯的o.uv的uv坐标，也可以是上面写的o.pos_uv（世界坐标pos_world也可）这种自己设定的值。</p>\n<p>另，如果想三平面都能够完美覆盖涉及到：<strong>三平面映射</strong>。up在此链接中有提到，所以查了其他教程补充在这里。</p>\n<h4 id=\"三平面映射\"><a href=\"#三平面映射\" class=\"headerlink\" title=\"三平面映射\"></a><a href=\"https://www.bilibili.com/opus/814269127492370548\">三平面映射</a></h4><ol>\n<li>**目的：**防止”纹理拉伸”</li>\n</ol>\n<p>防止纹理拉伸传统思路可以手动展开uv坐标以贴合模型起伏，但是难以适应实时渲染的要求，因此引入这一方法：三平面映射。</p>\n<ol start=\"2\">\n<li><p>**应用：**普通网格地形、瀑布、程序化建模的地形、水池的焦散效果</p>\n</li>\n<li><p><strong>实现步骤</strong></p>\n</li>\n</ol>\n<ul>\n<li>根据顶点的世界空间坐标计算对应的UV坐标</li>\n</ul>\n<pre><code class=\"language-c#\">//取每个片元在三个方向的uv坐标\nhalf2 yUV=IN.worldPos.xz/_TextureScale;\nhalf2 xUV=IN.worldPos.yz/_TextureScale;\nhalf2 zUV=IN.worldPos.xy/_TextureScale;\n</code></pre>\n<ul>\n<li>从x&#x2F;y&#x2F;z三个方向对漫反射贴图进行采样</li>\n</ul>\n<pre><code class=\"language-c#\">half3 yDiff=tex2D(_DiffuseMap,yUV);\nhalf3 xDiff=tex2D(_DiffuseMap,xUV);\nhalf3 zDiff=tex2D(_DiffuseMap,zUV);\n</code></pre>\n<ul>\n<li>调整三平面边界过渡的锐利度</li>\n</ul>\n<pre><code class=\"language-c#\">//用法线方向作为从三个方向采样的权重值\n//额外解决纹理接缝问题（法线是连续过渡的）\nhalf3 blendWeights=pow(abs(In.worldNormal),_TriplanarBlendSharpness);\n</code></pre>\n<ul>\n<li>将混合权重值单位化</li>\n</ul>\n<pre><code class=\"language-c#\">//第三步pow锐化三平面边界后，得到的法线值可能偏小\n//重新单位化\nblendWeights=blendWeights/(blendWeights.x+blendWeights.y+blendWeights.z);\n</code></pre>\n<ul>\n<li>按三个面的混合权重，将采样颜色混合在一起</li>\n</ul>\n<pre><code class=\"language-c#\">//根据混合系数混合\np.Albedo=xDiff*blendWeights.x+yDiff*blendWeights.y+zDiff*blendWeights.z;\n</code></pre>\n<p>更多相关内容<a href=\"https://www.bilibili.com/video/BV1AM4y1Y78D/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h4 id=\"渲染扭曲问题\"><a href=\"#渲染扭曲问题\" class=\"headerlink\" title=\"渲染扭曲问题\"></a>渲染扭曲问题</h4><p>打印uv坐标：</p>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.uv);\n                return float4(i.uv,0.0,0.0);\n            &#125;\n</code></pre>\n<p>若uv存在不连续的情况，则会导致贴图采样时引起纹理图像的失真问题。</p>\n<p><strong>👉️为什么会有uv不连续的现象？</strong><br>光栅化过程产生。光栅化时根据三角面的进行，每个三角按照每个三角面进行一个插值。而对于模型而言，其三角网排列就会造成一定程度上的问题。<br>解决方式：</p>\n<ul>\n<li>uv展开并缩放到0~1之间</li>\n<li>模型加面</li>\n<li>手动在片元shader中重新计算uv</li>\n</ul>\n<h3 id=\"PART4-透明度测试-Alpha-test\"><a href=\"#PART4-透明度测试-Alpha-test\" class=\"headerlink\" title=\"PART4 透明度测试 Alpha-test\"></a>PART4 透明度测试 Alpha-test</h3><p>参考链接<a href=\"https://docs.unity3d.com/cn/2020.2/Manual/SL-AlphaTest.html\">1️⃣</a><a href=\"https://blog.csdn.net/qq_34697930/article/details/136530909\">2️⃣</a></p>\n<h4 id=\"输出合并\"><a href=\"#输出合并\" class=\"headerlink\" title=\"输出合并\"></a>输出合并</h4><p>对于<strong>输出合并</strong>阶段，可以细分为：</p>\n<pre><code>【片元数据】Color,Depth\n    ↓\n【Alpha测试】\n    ↓\n【模板测试】Stencil Test\n    ↓\n【深度测试】Depth test\n    ↓\n【混合】Blending\n    ↓\n【帧缓冲区】Color,Depth,Stencil\n</code></pre>\n<h4 id=\"Alpha-test\"><a href=\"#Alpha-test\" class=\"headerlink\" title=\"Alpha-test\"></a>Alpha-test</h4><p>**Alpha 测试是拒绝将像素写入屏幕的最后机会。**在计算出最终输出颜色之后，颜色可选择性地将其 Alpha 值与固定值进行比较。如果测试失败，则不会将像素写入显示屏。</p>\n<p>当下在Shader中，很少会直接用alpha test这个指令。一般用的是更好用、更可控的指令：<code>clip</code>“裁剪”。</p>\n<p>如果clip()括号中的值&lt;0，整个模型将不显示。</p>\n<ol>\n<li>模型的一部分被裁剪掉</li>\n</ol>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 gradient=tex2D(_MainTex,i.uv);\n                clip(gradient-0.1);\n                return gradient.xxx;\n            &#125;\n</code></pre>\n<ol start=\"2\">\n<li>设置一个值实现动态控制<br>好神奇😂我这里模型用的球，Cutout调到0.5变成吃豆人了</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n         _Cutout(&quot;Cutout&quot;,Range(-0.1,1.1))=0.0\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv).r;\n                clip(gradient-_Cutout);\n                return gradient.xxxx;\n                //gradient.xxxx等价于float4(gradient,gradient,gradient,gradient);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>对UV进行动画处理</li>\n</ol>\n<pre><code class=\"language-c#\">                half gradient=tex2D(_MainTex,i.uv+_Time.y).r;\n</code></pre>\n<ol start=\"4\">\n<li>对UV进行动画速度的处理</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _Speed(&quot;Speed&quot;,Vector)=(1,1,0,0)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _Speed;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>noise贴图控制<br>适当的模型+贴图可以实现波形扩散效果</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _NoiseTex(&quot;Noise Tex&quot;,2D)=&quot;white&quot;&#123;&#125;\n         //_MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _NoiseTex_ST;\n            //float4 _MainColor;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n                half noise=tex2D(_NoiseTex,i.uv+_Time.y*_Speed.zw).r;\n                clip(gradient-noise-_Cutout);\n                return noise.xxxx;\n                //return _MainColor;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p><strong>综上</strong> alpha-test可以用来做溶解相关的效果。</p>\n<h3 id=\"PART5-半透明混合-Blending\"><a href=\"#PART5-半透明混合-Blending\" class=\"headerlink\" title=\"PART5 半透明混合 Blending\"></a>PART5 半透明混合 Blending</h3><p>参考链接<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/\">1️⃣</a><a href=\"https://blog.csdn.net/weixin_34505326/article/details/112181270\">2️⃣</a></p>\n<ol>\n<li>实现半透明混合</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;saturate\n    SubShader\n    &#123;\n        Blend SrcAlpha OneMinusSrcAlpha//注意此句在CGPROGRAM之前\n        float4 _MainColor;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half4 col=tex2D(_MainTex,i.uv)*_MainColor;\n                return col;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>关闭ZWrite深度写入<br>半透明混合的使用要注意排序问题：<code>ZWrite Off</code></li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>渲染队列问题<br>先前我们的材质球的Render Queue为2000，处于不透明的渲染队列中。使用半透明效果必须记得使用<code>Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</code>+关掉<code>ZWrite</code>（部分情况下ZWrite需要开启）</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"4\">\n<li>贴图半透效果</li>\n</ol>\n<ul>\n<li>当前贴图无alpha通道，所以只能用其灰度值来做一个半透效果。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz;\n                half alpha=tex2D(_MainTex,i.uv).r*_MainColor.a;\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<p>做出来的球像透明泡泡🤗好好看~</p>\n<ul>\n<li>增加显示强度<blockquote>\n<p>此处要确保alpha值在0~1的范围内，否则开HDR的时候就很容易出问题</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _Emiss(&quot;Emiss&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        float _Emiss;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz*_Emiss;\n\n                half alpha=saturate(tex2D(_MainTex,i.uv).r*_MainColor.a*_Emiss);\n                return float4(col,alpha);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>其他混合模式<br>常用的柔和叠加模式：<code>Blend SrcAlpha One</code></li>\n</ol>\n<h3 id=\"PART6-边缘光\"><a href=\"#PART6-边缘光\" class=\"headerlink\" title=\"PART6 边缘光\"></a>PART6 边缘光</h3><ol>\n<li>得到normal_world</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            struct appdata &#123;\n                float3 normal : NORMAL;\n            &#125;;\n            struct v2f &#123;\n                float3 normal_world:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos=UnityObjectToClipPos(v.vertex);\n                o.normal_world=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz);\n                //\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>得到view_world</li>\n</ol>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                float3 view_world:TEXCOORD2;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                float3 pos_world=mul(unity_ObjectToWorld,v.vertex).xyz;\n                o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);\n            &#125;\n</code></pre>\n<ol start=\"3\">\n<li>在片元Shader中把数据承接过来</li>\n</ol>\n<ul>\n<li><code>dot(a,b)</code>：a向量与b向量进行点乘。<br>两个向量越重合就越接近1；180°为-1。[-1,1]👉️dot结果在[-1,1]</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 normal_world=normalize(i.normal_world);\n                //光栅化的过程会导致向量的长度变化\n                float3 view_world=normalize(i.view_world);\n                float NdoV=saturate(dot(normal_world,view_world));\n                float rim=1.0-NdoV;\n                return NdoV.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"4\">\n<li>得到边缘光效果</li>\n</ol>\n<ul>\n<li>（来自弹幕佬的解释）边缘处的法线和视角方向接近垂直，dot&#x3D;0,1-dot进行取反，边缘就显示出颜色，其他部分就较为透明。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                ...\n                float rim=1.0-NdoV;\n                return rim.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"5\">\n<li>边缘光改色</li>\n</ol>\n<ul>\n<li>也可以用alpha通道调：<code>float alpha=saturate((1.0-NdoV)*_Emiss);</code></li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 col=_MainColor.xyz*_Emiss;//乘倍增系数，Inspector可调\n                ...\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<ol start=\"6\">\n<li>边缘光对比度调节</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _RimPower(&quot;_RimPower&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float _RimPower;\n            half4 frag(v2f i) : SV_Target &#123;\n               float NdoV=pow(saturate(dot(normal_world,view_world)),RimPower);\n               float fresnel=pow((1.0-NdoV),_RimPower);\n               float alpha=saturate(fresnel*_Emiss);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"7\">\n<li>模型透过问题：预先写深度<br>经过上面的步骤，模型能够看到内部的透过结构。如何避免这种现象？</li>\n</ol>\n<p>☝「打开ZWrite」<code>ZWrite On</code>。此时效果其实不算特别完美</p>\n<p>✌「再加一个&#96;Pass」预写一遍深度，代码如下：</p>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass\n        &#123;\n            Cull Of\n            ZWrite On\n            ColorMask 0\n            CGPROGRAM\n            float4 _Color;\n            #pragma vertex vert\n            #pragma fragment frag\n            float4 vert(float4 veryexPos:POSITION):SV_POSITION\n            &#123;\n                return UnityObjectToClipPos(vertexPos);\n            &#125;\n            float4 frag(void):COLOR\n            &#123;\n                return _Color;\n            &#125;\n            ENDCG\n        &#125;\n        Pass\n        &#123;\n            ...\n        &#125;\n    &#125;\n</code></pre>\n<ul>\n<li>把最靠前的三角形的片元的深度预先<code>ZWrite On</code>写好</li>\n<li><code>Color Mask</code>的操作：只写深度，不写任何的颜色信息</li>\n<li>到了第二遍pass绘制的时候，这些片元就通过深度测试，默认把背后的像素剔除</li>\n</ul>\n<p>👉️ASE中有对应的功能，此处仅为简单演示。</p>\n<p>🤯🤯🤯断断续续一个多星期终于把这一小时的视频啃完辣！！！休息休息继续战斗！</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"其他参考链接\"><a href=\"#其他参考链接\" class=\"headerlink\" title=\"其他参考链接\"></a>其他参考链接</h1><p>反射探针：<br><a href=\"https://zhuanlan.zhihu.com/p/438022045\">https://zhuanlan.zhihu.com/p/438022045</a><br>三大Shader编程语言：<br><a href=\"https://blog.csdn.net/weixin_56516170/article/details/135266277\">https://blog.csdn.net/weixin_56516170/article/details/135266277</a><br>《Shader入门精要》源代码:<br><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\">https://github.com/candycat1992/Unity_Shaders_Book</a><br>法线贴图：<br><a href=\"https://blog.csdn.net/weixin_49427945/article/details/136458398\">https://blog.csdn.net/weixin_49427945/article/details/136458398</a><br><a href=\"https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html\">https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html</a></p>\n",
            "tags": [
                "笔记"
            ]
        }
    ]
}
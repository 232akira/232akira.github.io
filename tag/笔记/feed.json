{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"笔记\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/",
            "url": "https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/",
            "title": "笔记 | 游戏开发",
            "date_published": "2025-04-06T14:22:22.000Z",
            "content_html": "<p>👌当下主要学习<strong>图形</strong>方向，具体细节可以查看<a href=\"https://docs.unity3d.com/cn/current/Manual/Graphics.html\">Unity官方文档</a>。</p>\n<pre><code>渲染管线\n摄像机\n光照\n模型\n网格\n纹理\n着色器\n材质\nVisual effects\n天空\n颜色\n图形API\nGraphics performance and profiling\n</code></pre>\n<blockquote>\n<p>虽然自己程序方面更擅长C++而且现在用UE也是个趋势，但是Unity普及度更高而且教程更多，UE蓝图也摒弃了传统的纯程序开发路线，所以打好这方面基础是现在最需要做的。如果有任何建议和想法需要交流欢迎联系我！不断试错不断学习中🤗</p>\n</blockquote>\n<p>笔记内容90%来自视频原话，其他内容个人补充，欢迎勘误。<br>学习内容大多来自b站佬们的教程（先三连之后看的！）🤟参考链接点击标题跳转</p>\n<h1 id=\"项目实战-Uinty\"><a href=\"#项目实战-Uinty\" class=\"headerlink\" title=\"项目实战-Uinty\"></a>项目实战-Uinty</h1><h2 id=\"Shader代码基础\"><a href=\"#Shader代码基础\" class=\"headerlink\" title=\"Shader代码基础\"></a><a href=\"https://www.bilibili.com/video/BV1Xu4y1S7LF/?spm_id_from=333.1387.favlist.content.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">Shader代码基础</a></h2><h3 id=\"PART1\"><a href=\"#PART1\" class=\"headerlink\" title=\"PART1\"></a>PART1</h3><h4 id=\"Shader代码基本架构\"><a href=\"#Shader代码基本架构\" class=\"headerlink\" title=\"Shader代码基本架构\"></a>Shader代码基本架构</h4><pre><code class=\"language-c#\">Shader&quot;1️⃣&quot;\n&#123;\n    Properties\n    &#123;\n    2️⃣\n    &#125;\n    SubShader\n    &#123;\n    ️3️⃣\n        Pass\n        &#123;\n        4️⃣\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>1️⃣Shader名称</strong></p>\n<p><strong>2️⃣定义变量位置</strong><br>常见的五种变量类型:</p>\n<ul>\n<li>Float</li>\n<li>Range</li>\n<li>Vector</li>\n<li>Color</li>\n<li>Texture</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        //常用的五种数据类型\n        _Float(&quot;Float&quot;,Float)=0.0\n        _Range(&quot;Range&quot;,Range(0.0,1.0))=0.0\n        _Vector(&quot;Vector&quot;,Vector)=(1,1,1,1)\n        _Color(&quot;Color&quot;,Color)=(0.5,0.5,0.5,0.5)\n        _Texture(&quot;Texture&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n</code></pre>\n<p><strong>3️⃣主要Shader代码部分</strong><br>可以理解成一个Pass等于一个完整的GPU渲染管线，SubShader里可以写多个Pass，写几个代表会被重复渲染几次，而且每次调用的Shader都不一样。</p>\n<pre><code class=\"language-c#\">            CGPROGRAM\n            //中间的任何代码都属于unity cg的范围\n            ENDCG\n</code></pre>\n<ol>\n<li>这里对于<code>float</code>类型<a href=\"https://docs.unity3d.com/cn/current/Manual/SL-VertexProgramInputs.html\">补充</a>一点：</li>\n</ol>\n<ul>\n<li>‌<code>float‌</code>：用于表示单个浮点数，常用于颜色通道、位置坐标等。</li>\n<li>‌<code>float2‌</code>（Vector2）：用于表示二维向量，如二维坐标、UV坐标等。</li>\n<li>‌<code>float3‌</code>（Vector3）：用于表示三维向量，如位置、法线等。</li>\n<li>‌<code>float4‌</code>（Vector4）：用于表示四维向量，如颜色、四元数等。</li>\n</ul>\n<ol start=\"2\">\n<li><p>在unity中，一个模型最多有四套UV</p>\n</li>\n<li><p>float&#x2F;half&#x2F;fixed的区别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">位宽</th>\n<th align=\"center\">适用范围</th>\n<th align=\"center\">常见用途</th>\n<th align=\"center\">精度</th>\n<th align=\"center\">现代GPU支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32-bit</td>\n<td align=\"center\">大</td>\n<td align=\"center\">位置、物理计算、PBR</td>\n<td align=\"center\">高</td>\n<td align=\"center\">强烈推荐</td>\n</tr>\n<tr>\n<td align=\"center\">half</td>\n<td align=\"center\">16-bit</td>\n<td align=\"center\">中</td>\n<td align=\"center\">颜色计算、法线、屏幕后处理</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">推荐（移动端优化）</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">10-bit</td>\n<td align=\"center\">小</td>\n<td align=\"center\">颜色计算（老设备）</td>\n<td align=\"center\">低</td>\n<td align=\"center\">几乎淘汰</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"GPU渲染管线\"><a href=\"#GPU渲染管线\" class=\"headerlink\" title=\"GPU渲染管线\"></a>GPU渲染管线</h4><p><strong>基本结构</strong>：</p>\n<pre><code>【模型数据】 -&gt; 1️⃣【顶点Shader】 -&gt; 2️⃣【图元装配及光栅化】 -&gt; 3️⃣【片元Shader】 -&gt; 4️⃣【输出合并】\n            |-----------------------------GPU渲染管线---------------------------------------|\n</code></pre>\n<p><strong>1️⃣顶点Shader</strong>：</p>\n<ul>\n<li>将模型数据的模型空间坐标转换到对应的裁剪空间，即输出在裁剪空间下的顶点坐标</li>\n<li>【模型空间】 -&gt; 世界空间 -&gt; 相机空间 -&gt; 【裁剪空间】，中间经过三个矩阵（Model,View,Projection）操作</li>\n</ul>\n<p><strong>2️⃣图元装配及光栅化</strong></p>\n<ul>\n<li>硬件阶段</li>\n<li>生成片元并进行光栅化插值</li>\n</ul>\n<p><strong>3️⃣片元Shader</strong></p>\n<ul>\n<li>每个片元调用片元shader给自身着色</li>\n<li>计算对应的颜色后输出</li>\n</ul>\n<p><strong>4️⃣输出合并</strong></p>\n<ul>\n<li>输出到对应的帧缓冲区</li>\n</ul>\n<p><em><strong>一个完整的Shader通常由顶点Shader和片段Shader共同组成。</strong></em></p>\n<h4 id=\"完整Shader代码\"><a href=\"#完整Shader代码\" class=\"headerlink\" title=\"完整Shader代码\"></a>完整Shader代码</h4><pre><code class=\"language-c#\">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;\n// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;\nShader &quot;CS0102/shader&quot;\n&#123;\n    Properties\n    &#123;\n        // 常用的五种数据类型\n        _Float(&quot;Float&quot;, Float) = 0.0\n        _Range(&quot;Range&quot;, Range(0.0, 1.0)) = 0.0\n        _Vector(&quot;Vector&quot;, Vector) = (1,1,1,1)\n        _Color(&quot;Color&quot;, Color) = (0.5,0.5,0.5,0.5)\n        //_Texture(&quot;Texture&quot;, 2D) = &quot;black&quot; &#123;&#125; \n        _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            // Shader 主要代码部分\n            CGPROGRAM\n            #pragma vertex vert // 指定一个顶点 Shader：vert\n            #pragma fragment frag // 指定一个片元 Shader：frag\n            #include &quot;UnityCG.cginc&quot; // 头文件\n\n            // 从 CPU 端获取模型数据\n            struct appdata &#123;\n                float4 vertex : POSITION;  // 模型顶点坐标\n                // 第一套uv，共4个可用（TEXCOORD0~TEXCOORD3）\n                float2 uv : TEXCOORD0; \n                float3 normal : NORMAL;    // 法线\n                float4 color : COLOR;      // 顶点色\n            &#125;;\n            // 输出结构体定义\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                //通用储存器（插值器），共16个可用（TEXCOORD0~TEXCOORD15）\n                float2 uv:TEXCOORD0;\n            &#125;;\n            float4 _Color;\n            sampler2D _MainTex;\n            float4 _MainTex_ST;//动态链接四个参数\n            // 顶点 Shader\n            v2f vert(appdata v) &#123;\n                v2f o;\n                //float4 pos_world = mul(unity_ObjectToWorld, v.vertex); // 模型空间转世界空间\n                //float4 pos_clip = mul(UNITY_MATRIX_VP, pos_world); // 世界空间直接变换到裁剪空间\n                //o.pos = pos_clip;\n                //或者直接合成一个mvp操作\n                o.pos=UnityObjectToClipPos(v.vertex);\n                //输出uv值\n                //o.uv=v.uv;\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            // 片元 Shader\n            float4 frag(v2f i) : SV_Target &#123;\n                //贴图采样\n                float4 col=tex2D(_MainTex,i.uv);\n                return col;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"PART2\"><a href=\"#PART2\" class=\"headerlink\" title=\"PART2\"></a>PART2</h3><h4 id=\"背面剔除（Backface-Culling）\"><a href=\"#背面剔除（Backface-Culling）\" class=\"headerlink\" title=\"背面剔除（Backface Culling）\"></a>背面剔除（Backface Culling）</h4><p>背面剔除在硬件阶段、NDC空间之后进行，Unity默认使用背面剔除（只渲染正面）。</p>\n<ol>\n<li>Shader代码控制:直接显示出渲染结果</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull Off  //1️⃣不剔除\n            Cull Back //2️⃣默认剔除背面\n            Cull Front//3️⃣剔除正面\n            //注意在CGPROGRAM之前\n            CGPROGRAM\n            ...\n            ENDCG\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>材质球控制：物体材质球处出现可选项：Off&#x2F;Front&#x2F;Back</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull [_CullMode]\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"PART3-纹理映射\"><a href=\"#PART3-纹理映射\" class=\"headerlink\" title=\"PART3 纹理映射\"></a>PART3 纹理映射</h3><h4 id=\"正面纹理采样设定\"><a href=\"#正面纹理采样设定\" class=\"headerlink\" title=\"正面纹理采样设定\"></a>正面纹理采样设定</h4><p>这里用XY坐标值采样贴图，即uv按模型本身的XY展开。<br>代码如下：</p>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                ...\n                float2 pos_uv:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                ...\n                o.pos_uv=v.vertex.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.pos_uv);\n                return col;\n            &#125;\n</code></pre>\n<p>👉️补充：</p>\n<ul>\n<li>正面 XY平面</li>\n<li>侧面 ZY平面</li>\n<li>俯视 XZ平面</li>\n</ul>\n<p>总结：纹理映射的来源不一定是单纯的o.uv的uv坐标，也可以是上面写的o.pos_uv（世界坐标pos_world也可）这种自己设定的值。</p>\n<p>另，如果想三平面都能够完美覆盖涉及到：<strong>三平面映射</strong>。up在此链接中有提到，所以查了其他教程补充在这里。</p>\n<h4 id=\"三平面映射\"><a href=\"#三平面映射\" class=\"headerlink\" title=\"三平面映射\"></a><a href=\"https://www.bilibili.com/opus/814269127492370548\">三平面映射</a></h4><ol>\n<li>**目的：**防止”纹理拉伸”</li>\n</ol>\n<p>防止纹理拉伸传统思路可以手动展开uv坐标以贴合模型起伏，但是难以适应实时渲染的要求，因此引入这一方法：三平面映射。</p>\n<ol start=\"2\">\n<li><p>**应用：**普通网格地形、瀑布、程序化建模的地形、水池的焦散效果</p>\n</li>\n<li><p><strong>实现步骤</strong></p>\n</li>\n</ol>\n<ul>\n<li>根据顶点的世界空间坐标计算对应的UV坐标</li>\n</ul>\n<pre><code class=\"language-c#\">//取每个片元在三个方向的uv坐标\nhalf2 yUV=IN.worldPos.xz/_TextureScale;\nhalf2 xUV=IN.worldPos.yz/_TextureScale;\nhalf2 zUV=IN.worldPos.xy/_TextureScale;\n</code></pre>\n<ul>\n<li>从x&#x2F;y&#x2F;z三个方向对漫反射贴图进行采样</li>\n</ul>\n<pre><code class=\"language-c#\">half3 yDiff=tex2D(_DiffuseMap,yUV);\nhalf3 xDiff=tex2D(_DiffuseMap,xUV);\nhalf3 zDiff=tex2D(_DiffuseMap,zUV);\n</code></pre>\n<ul>\n<li>调整三平面边界过渡的锐利度</li>\n</ul>\n<pre><code class=\"language-c#\">//用法线方向作为从三个方向采样的权重值\n//额外解决纹理接缝问题（法线是连续过渡的）\nhalf3 blendWeights=pow(abs(In.worldNormal),_TriplanarBlendSharpness);\n</code></pre>\n<ul>\n<li>将混合权重值单位化</li>\n</ul>\n<pre><code class=\"language-c#\">//第三步pow锐化三平面边界后，得到的法线值可能偏小\n//重新单位化\nblendWeights=blendWeights/(blendWeights.x+blendWeights.y+blendWeights.z);\n</code></pre>\n<ul>\n<li>按三个面的混合权重，将采样颜色混合在一起</li>\n</ul>\n<pre><code class=\"language-c#\">//根据混合系数混合\np.Albedo=xDiff*blendWeights.x+yDiff*blendWeights.y+zDiff*blendWeights.z;\n</code></pre>\n<p>更多相关内容<a href=\"https://www.bilibili.com/video/BV1AM4y1Y78D/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h4 id=\"渲染扭曲问题\"><a href=\"#渲染扭曲问题\" class=\"headerlink\" title=\"渲染扭曲问题\"></a>渲染扭曲问题</h4><p>打印uv坐标：</p>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.uv);\n                return float4(i.uv,0.0,0.0);\n            &#125;\n</code></pre>\n<p>若uv存在不连续的情况，则会导致贴图采样时引起纹理图像的失真问题。</p>\n<p><strong>👉️为什么会有uv不连续的现象？</strong><br>光栅化过程产生。光栅化时根据三角面的进行，每个三角按照每个三角面进行一个插值。而对于模型而言，其三角网排列就会造成一定程度上的问题。<br>解决方式：</p>\n<ul>\n<li>uv展开并缩放到0~1之间</li>\n<li>模型加面</li>\n<li>手动在片元shader中重新计算uv</li>\n</ul>\n<h3 id=\"PART4-透明度测试-Alpha-test\"><a href=\"#PART4-透明度测试-Alpha-test\" class=\"headerlink\" title=\"PART4 透明度测试 Alpha-test\"></a>PART4 透明度测试 Alpha-test</h3><p>参考链接<a href=\"https://docs.unity3d.com/cn/2020.2/Manual/SL-AlphaTest.html\">1️⃣</a><a href=\"https://blog.csdn.net/qq_34697930/article/details/136530909\">2️⃣</a></p>\n<h4 id=\"输出合并\"><a href=\"#输出合并\" class=\"headerlink\" title=\"输出合并\"></a>输出合并</h4><p>对于<strong>输出合并</strong>阶段，可以细分为：</p>\n<pre><code>【片元数据】Color,Depth\n    ↓\n【Alpha测试】\n    ↓\n【模板测试】Stencil Test\n    ↓\n【深度测试】Depth test\n    ↓\n【混合】Blending\n    ↓\n【帧缓冲区】Color,Depth,Stencil\n</code></pre>\n<h4 id=\"Alpha-test\"><a href=\"#Alpha-test\" class=\"headerlink\" title=\"Alpha-test\"></a>Alpha-test</h4><p>**Alpha 测试是拒绝将像素写入屏幕的最后机会。**在计算出最终输出颜色之后，颜色可选择性地将其 Alpha 值与固定值进行比较。如果测试失败，则不会将像素写入显示屏。</p>\n<p>当下在Shader中，很少会直接用alpha test这个指令。一般用的是更好用、更可控的指令：<code>clip</code>“裁剪”。</p>\n<p>如果clip()括号中的值&lt;0，整个模型将不显示。</p>\n<ol>\n<li>模型的一部分被裁剪掉</li>\n</ol>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 gradient=tex2D(_MainTex,i.uv);\n                clip(gradient-0.1);\n                return gradient.xxx;\n            &#125;\n</code></pre>\n<ol start=\"2\">\n<li>设置一个值实现动态控制<br>好神奇😂我这里模型用的球，Cutout调到0.5变成吃豆人了</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n         _Cutout(&quot;Cutout&quot;,Range(-0.1,1.1))=0.0\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv).r;\n                clip(gradient-_Cutout);\n                return gradient.xxxx;\n                //gradient.xxxx等价于float4(gradient,gradient,gradient,gradient);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>对UV进行动画处理</li>\n</ol>\n<pre><code class=\"language-c#\">                half gradient=tex2D(_MainTex,i.uv+_Time.y).r;\n</code></pre>\n<ol start=\"4\">\n<li>对UV进行动画速度的处理</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _Speed(&quot;Speed&quot;,Vector)=(1,1,0,0)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _Speed;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>noise贴图控制<br>适当的模型+贴图可以实现波形扩散效果</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _NoiseTex(&quot;Noise Tex&quot;,2D)=&quot;white&quot;&#123;&#125;\n         //_MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _NoiseTex_ST;\n            //float4 _MainColor;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n                half noise=tex2D(_NoiseTex,i.uv+_Time.y*_Speed.zw).r;\n                clip(gradient-noise-_Cutout);\n                return noise.xxxx;\n                //return _MainColor;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p><strong>综上</strong> alpha-test可以用来做溶解相关的效果。</p>\n<h3 id=\"PART5-半透明混合-Blending\"><a href=\"#PART5-半透明混合-Blending\" class=\"headerlink\" title=\"PART5 半透明混合 Blending\"></a>PART5 半透明混合 Blending</h3><p>参考链接<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/\">1️⃣</a><a href=\"https://blog.csdn.net/weixin_34505326/article/details/112181270\">2️⃣</a></p>\n<ol>\n<li>实现半透明混合</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;saturate\n    SubShader\n    &#123;\n        Blend SrcAlpha OneMinusSrcAlpha//注意此句在CGPROGRAM之前\n        float4 _MainColor;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half4 col=tex2D(_MainTex,i.uv)*_MainColor;\n                return col;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>关闭ZWrite深度写入<br>半透明混合的使用要注意排序问题：<code>ZWrite Off</code></li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>渲染队列问题<br>先前我们的材质球的Render Queue为2000，处于不透明的渲染队列中。使用半透明效果必须记得使用<code>Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</code>+关掉<code>ZWrite</code>（部分情况下ZWrite需要开启）</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"4\">\n<li>贴图半透效果</li>\n</ol>\n<ul>\n<li>当前贴图无alpha通道，所以只能用其灰度值来做一个半透效果。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz;\n                half alpha=tex2D(_MainTex,i.uv).r*_MainColor.a;\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<p>做出来的球像透明泡泡🤗好好看~</p>\n<ul>\n<li>增加显示强度<blockquote>\n<p>此处要确保alpha值在0~1的范围内，否则开HDR的时候就很容易出问题</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _Emiss(&quot;Emiss&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        float _Emiss;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz*_Emiss;\n\n                half alpha=saturate(tex2D(_MainTex,i.uv).r*_MainColor.a*_Emiss);\n                return float4(col,alpha);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>其他混合模式<br>常用的柔和叠加模式：<code>Blend SrcAlpha One</code></li>\n</ol>\n<h3 id=\"PART6-边缘光\"><a href=\"#PART6-边缘光\" class=\"headerlink\" title=\"PART6 边缘光\"></a>PART6 边缘光</h3><ol>\n<li>得到normal_world</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            struct appdata &#123;\n                float3 normal : NORMAL;\n            &#125;;\n            struct v2f &#123;\n                float3 normal_world:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos=UnityObjectToClipPos(v.vertex);\n                o.normal_world=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz);\n                //\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>得到view_world</li>\n</ol>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                float3 view_world:TEXCOORD2;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                float3 pos_world=mul(unity_ObjectToWorld,v.vertex).xyz;\n                o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);\n            &#125;\n</code></pre>\n<ol start=\"3\">\n<li>在片元Shader中把数据承接过来</li>\n</ol>\n<ul>\n<li><code>dot(a,b)</code>：a向量与b向量进行点乘。<br>两个向量越重合就越接近1；180°为-1。[-1,1]👉️dot结果在[-1,1]</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 normal_world=normalize(i.normal_world);\n                //光栅化的过程会导致向量的长度变化\n                float3 view_world=normalize(i.view_world);\n                float NdoV=saturate(dot(normal_world,view_world));\n                float rim=1.0-NdoV;\n                return NdoV.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"4\">\n<li>得到边缘光效果</li>\n</ol>\n<ul>\n<li>（来自弹幕佬的解释）边缘处的法线和视角方向接近垂直，dot&#x3D;0,1-dot进行取反，边缘就显示出颜色，其他部分就较为透明。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                ...\n                float rim=1.0-NdoV;\n                return rim.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"5\">\n<li>边缘光改色</li>\n</ol>\n<ul>\n<li>也可以用alpha通道调：<code>float alpha=saturate((1.0-NdoV)*_Emiss);</code></li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 col=_MainColor.xyz*_Emiss;//乘倍增系数，Inspector可调\n                ...\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<ol start=\"6\">\n<li>边缘光对比度调节</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _RimPower(&quot;_RimPower&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float _RimPower;\n            half4 frag(v2f i) : SV_Target &#123;\n               float NdoV=pow(saturate(dot(normal_world,view_world)),RimPower);\n               float fresnel=pow((1.0-NdoV),_RimPower);\n               float alpha=saturate(fresnel*_Emiss);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"7\">\n<li>模型透过问题：预先写深度<br>经过上面的步骤，模型能够看到内部的透过结构。如何避免这种现象？</li>\n</ol>\n<p>☝「打开ZWrite」<code>ZWrite On</code>。此时效果其实不算特别完美</p>\n<p>✌「再加一个&#96;Pass」预写一遍深度，代码如下：</p>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass\n        &#123;\n            Cull Of\n            ZWrite On\n            ColorMask 0\n            CGPROGRAM\n            float4 _Color;\n            #pragma vertex vert\n            #pragma fragment frag\n            float4 vert(float4 veryexPos:POSITION):SV_POSITION\n            &#123;\n                return UnityObjectToClipPos(vertexPos);\n            &#125;\n            float4 frag(void):COLOR\n            &#123;\n                return _Color;\n            &#125;\n            ENDCG\n        &#125;\n        Pass\n        &#123;\n            ...\n        &#125;\n    &#125;\n</code></pre>\n<ul>\n<li>把最靠前的三角形的片元的深度预先<code>ZWrite On</code>写好</li>\n<li><code>Color Mask</code>的操作：只写深度，不写任何的颜色信息</li>\n<li>到了第二遍pass绘制的时候，这些片元就通过深度测试，默认把背后的像素剔除</li>\n</ul>\n<p>👉️ASE中有对应的功能，此处仅为简单演示。</p>\n<p>🤯🤯🤯断断续续一个多星期终于把这一小时的视频啃完辣！！！休息休息继续战斗！</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"其他参考链接\"><a href=\"#其他参考链接\" class=\"headerlink\" title=\"其他参考链接\"></a>其他参考链接</h1><p>反射探针：<br><a href=\"https://zhuanlan.zhihu.com/p/438022045\">https://zhuanlan.zhihu.com/p/438022045</a><br>三大Shader编程语言：<br><a href=\"https://blog.csdn.net/weixin_56516170/article/details/135266277\">https://blog.csdn.net/weixin_56516170/article/details/135266277</a><br>《Shader入门精要》源代码:<br><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\">https://github.com/candycat1992/Unity_Shaders_Book</a><br>法线贴图：<br><a href=\"https://blog.csdn.net/weixin_49427945/article/details/136458398\">https://blog.csdn.net/weixin_49427945/article/details/136458398</a><br><a href=\"https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html\">https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html</a></p>\n",
            "tags": [
                "笔记"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "Per aspera ad astra • All posts by \"笔记\" tag",
    "description": "欢迎交流学习!",
    "home_page_url": "https://232akira.github.io",
    "items": [
        {
            "id": "https://232akira.github.io/2025/09/14/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/",
            "url": "https://232akira.github.io/2025/09/14/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/",
            "title": "笔记🗒️ ⋮ 评论系统配置",
            "date_published": "2025-09-14T13:38:03.000Z",
            "content_html": "<blockquote>\n<p>先叨叨一下心路历程。一开始在死磕<strong>waline</strong>的配置（+vercle），结果就是前端有评论模块，但是点击提交评论就会报错<code>Failed to fetch</code>，历经多月绞尽脑汁最终惨败。<br>今天突发奇想换成<strong>twikoo</strong>试一下，结果跟着官方教程一遍过了😭特别感动！！！</p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li>本博客的美丽主题来自👉<a href=\"https://github.com/theme-shoka-x/hexo-theme-shokaX\">ShokaX</a></li>\n<li>美丽主题的评论系统配置<a href=\"https://docs.shokax.kaitaku.xyz/features/comments/\">戳此</a></li>\n<li>Twikoo快速上手<a href=\"https://twikoo.js.org/quick-start.html\">戳此</a></li>\n</ul>\n<h2 id=\"开始配置\"><a href=\"#开始配置\" class=\"headerlink\" title=\"开始配置\"></a>开始配置</h2><p>此博客用的是shokax官方推荐的<code>云函数部署</code>-&gt;<code>Vercel部署</code>的方式。</p>\n<p>主要在<strong>两个网站</strong>上操作：</p>\n<ol>\n<li><code>MongoDB Atlas</code>：云端数据库托管服务</li>\n<li><code>Vercel</code>：云端部署平台</li>\n</ol>\n<p><code>MongoDB Atlas</code>、<code>Vercel</code>、<code>用户评论</code><strong>三者的关系</strong>可以理解为：</p>\n<pre><code>用户评论 -- Vercel --&gt; MongoDB（长期保存）\n</code></pre>\n<h3 id=\"MongoDB-Atlas\"><a href=\"#MongoDB-Atlas\" class=\"headerlink\" title=\"MongoDB Atlas\"></a>MongoDB Atlas</h3><p>官方教程<a href=\"https://twikoo.js.org/mongodb-atlas.html\">戳此</a>。</p>\n<ol>\n<li>注册账号</li>\n<li>新建数据库（区域选择AWS）</li>\n<li>Database Access-&gt;新建权限为Admin的用户并记住账号密码</li>\n<li>Network Access-&gt;添加网络白名单（0.0.0.0&#x2F;0）</li>\n<li>Database-&gt;Connect-&gt;Drivers</li>\n<li>复制<code>数据库连接字符串</code>（<code>&lt;username&gt;:&lt;passname&gt;</code>修改为<code>用户名：密码</code>）</li>\n</ol>\n<p>⚠注意替换用户名密码时把原尖括号删掉！！！</p>\n<h3 id=\"Vercel\"><a href=\"#Vercel\" class=\"headerlink\" title=\"Vercel\"></a>Vercel</h3><p>官方教程<a href=\"https://twikoo.js.org/backend.html#vercel-%E9%83%A8%E7%BD%B2\">戳此</a>。</p>\n<ol>\n<li>注册账号</li>\n<li>将twikoo<a href=\"https://vercel.com/import/project?template=https://github.com/twikoojs/twikoo/tree/main/src/server/vercel-min\">一键部署</a>到vercel</li>\n<li>进入你上一步部署的repo-&gt;settings</li>\n<li>settings-&gt;Environment Variables-&gt;添加环境变量（NAME:<code>MONGODB_URI</code>；VALUE：<code>数据库连接字符串</code>）</li>\n<li>弹窗-&gt;Redeploy</li>\n<li>settings-&gt;Deployment Protection-&gt;<code>Vercel Authentication</code>设置为<code>Disabled</code></li>\n<li>弹窗-&gt;Redeploy</li>\n<li>Overview-&gt;visit-&gt;Twikoo云函数运行正常</li>\n<li>复制<code>visit跳转的网址</code></li>\n</ol>\n<h3 id=\"config-shokax-yml\"><a href=\"#config-shokax-yml\" class=\"headerlink\" title=\"_config.shokax.yml\"></a>_config.shokax.yml</h3><pre><code>#twikoo评论配置\ntwikoo:\n  enable: true # 是否开启\n  mode: vercel # vercel(私有部署) 或 tencent\n  envId: &quot;visit跳转的网址&quot; # twikoo 环境 ID,vercel 和私有部署填地址\n  region: # vercel 和私有部署不填，腾讯云见 twikoo 文档\n</code></pre>\n<hr>\n<p>评论系统就这样配好了！欢迎宝宝们友好交流！！o(<em>￣▽￣</em>)ブ~♥</p>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20MCP%EF%BC%88Model%20Context%20Protocol%EF%BC%89/",
            "url": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20MCP%EF%BC%88Model%20Context%20Protocol%EF%BC%89/",
            "title": "笔记🗒️ ⋮ MCP（Model Context Protocol）",
            "date_published": "2025-08-24T08:30:03.000Z",
            "content_html": "<h2 id=\"应用背景\"><a href=\"#应用背景\" class=\"headerlink\" title=\"应用背景\"></a>应用背景</h2><blockquote>\n<p>你是否向大模型提问过：“现在几点了？”“我这里的天气怎么样？”的问题？那么它能够正确回答吗？</p>\n<p>目前来看——一般会回答错误。</p>\n</blockquote>\n<p>当下，LLM的能力早已不局限于“文本生成”，而是能够通过外部工具的调用变得“手眼通天”：脱离原有的封闭环境，获得了<strong>与外部环境交互</strong>的能力。</p>\n<p>相当于给大模型加上了手脚🧐</p>\n<p><strong>与外部环境交互</strong>通过<code>MCP</code>进行工具调用的规范化，通过<code>A2A</code>实现Agent与Agent之间交互的规范化。</p>\n<h2 id=\"Function-Calling-MCP\"><a href=\"#Function-Calling-MCP\" class=\"headerlink\" title=\"Function Calling-&gt;MCP\"></a>Function Calling-&gt;MCP</h2><p>工具调用基于<code>function calling</code>实现并被广泛用于商业API交互，目前国产的主流LLM大多已支持。<br>而Ahthropic推出的<strong>MCP</strong>（Model Context Protocol）正是针对“工具调用接口的规范化”应运而生的协议。</p>\n<blockquote>\n<p>调用的过程其实是让大模型理解我们需求的过程。</p>\n</blockquote>\n<p>这里按个人理解写一下MCP应用流程：</p>\n<pre><code>用户通过配置MCP服务-&gt;提供工具调用的相关函数及其对应的传参要求，\n\n模型在\n  - 理解用户需求\n  - 学会函数对应参数的攥写格式\n的基础上，\n判断函数是否调用、如何调用、拿到返回的结果后如何分析。\n</code></pre>\n<blockquote>\n<p>Function Calling和MCP是当前技术落地的核心方式。前者侧重模型原生能力，后者强调协议标准化。</p>\n</blockquote>\n<p>那么AI Agent（人工智能代理&#x2F;智能体）则为更高阶的形态，其融合了自主决策+工具调用，能够更加适用于复杂场景。</p>\n<h2 id=\"MCP-A2A\"><a href=\"#MCP-A2A\" class=\"headerlink\" title=\"MCP-&gt;A2A\"></a>MCP-&gt;A2A</h2><p>若再视野拓展至MAS（Multi-Agent Systems）的多智能体系统协作领域，我们就不能不提起<strong>A2A</strong>（Agent-to-Agent Protocol,代理间通信协议）。</p>\n<p>到这里可以将上文提到的三个概念搭建为三层级的技术栈模型：</p>\n<pre><code>       【A2A】         // Agent与Agent~协作网络\n          ↑\n       【MCP】         // Agent与工具~资源与会话管理\n          ↑\n 【Function Calling】  //模型原生能力\n</code></pre>\n<p>Google将A2A比作互联网早期的HTTP协议</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/1916821381879931822\">(7 封私信) 深度研究报告：大模型工具调用（Tool-use）的技术演进与协议生态分析 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/hwhsong/article/details/147244842\">【AI学习】大模型调用外部工具的主流方式对比_大模型工具调用-CSDN博客</a></li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20LangChain/",
            "url": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20LangChain/",
            "title": "笔记🗒️ ⋮ LangChain",
            "date_published": "2025-08-24T08:30:02.000Z",
            "content_html": "<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p><strong>LangChain是一个</strong>用于开发由语言模型驱动的应用程序的<strong>框架</strong>。</p>\n<h2 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h2><h3 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h3><ol>\n<li>Compents</li>\n<li>Chains</li>\n<li>Agents</li>\n</ol>\n<p><a href=\"https://python.langchain.com/docs/get_started/introduction\">https://python.langchain.com/docs/get_started/introduction</a></p>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/",
            "url": "https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/",
            "title": "笔记🗒️ ⋮ AI Agent",
            "date_published": "2025-08-24T08:30:01.000Z",
            "content_html": "<h2 id=\"Agent\"><a href=\"#Agent\" class=\"headerlink\" title=\"Agent\"></a>Agent</h2><p>智能体（Agent）更具备“人类”的思维方式，可以识别任务的需求分析、执行规划和问题决策。</p>\n<p><strong>基于LLM驱动的Agent基本框架：</strong></p>\n<p>![[SVG-1-Agent.svg]]</p>\n<h2 id=\"Agentic-LLMs\"><a href=\"#Agentic-LLMs\" class=\"headerlink\" title=\"Agentic LLMs\"></a>Agentic LLMs</h2><blockquote>\n<p>在使用魔搭社区的<a href=\"https://modelscope.cn/studios/modelscope/mcp-playground\">MCP Playground · 创空间</a>时，看到实验场用的是Qwen3-Coder-480B-A35B-Instruct <code>Agentic 大模型</code>，所以就好奇Agentic大模型是什么个概念🧐</p>\n</blockquote>\n<p>代理型大语言模型（Agent LLMs）是指能够作为智能体（Agent）行动的大语言模型，具备推理、行动和交互的能力。</p>\n<h2 id=\"ReAct\"><a href=\"#ReAct\" class=\"headerlink\" title=\"ReAct\"></a>ReAct</h2><p><a href=\"https://react-lm.github.io/\">https://react-lm.github.io/</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/678046050\">7000长文：一文读懂Agent，大模型的下一站 - 知乎</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/2401_84204207/article/details/147516308\">380篇文献！首份Agentic大模型最新技术综述_agentic+llm-CSDN博客</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/2532014\">【科普篇】LLM、GPT、AIGC、AI Agent、Agentic AI 到底是个啥？-腾讯云开发者社区-腾讯云</a></p>\n</li>\n</ol>\n",
            "tags": [
                "笔记"
            ]
        },
        {
            "id": "https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/",
            "url": "https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/",
            "title": "笔记1️⃣ ⋮ 游戏开发",
            "date_published": "2025-04-06T14:22:22.000Z",
            "content_html": "<p>👌当下主要学习<strong>图形</strong>方向，具体细节可以查看<a href=\"https://docs.unity3d.com/cn/current/Manual/Graphics.html\">Unity官方文档</a>。</p>\n<pre><code>渲染管线\n摄像机\n光照\n模型\n网格\n纹理\n着色器\n材质\nVisual effects\n天空\n颜色\n图形API\nGraphics performance and profiling\n</code></pre>\n<blockquote>\n<p>虽然自己程序方面更擅长C++而且现在用UE也是个趋势，但是Unity普及度更高而且教程更多，UE蓝图也摒弃了传统的纯程序开发路线，所以打好这方面基础是现在最需要做的。如果有任何建议和想法需要交流欢迎联系我！不断试错不断学习中🤗</p>\n</blockquote>\n<p>笔记内容90%来自视频原话，其他内容个人补充，欢迎勘误。<br>学习内容大多来自b站佬们的教程（先三连之后看的！）🤟参考链接点击标题跳转</p>\n<h1 id=\"项目实战-Uinty\"><a href=\"#项目实战-Uinty\" class=\"headerlink\" title=\"项目实战-Uinty\"></a>项目实战-Uinty</h1><h2 id=\"Shader代码基础\"><a href=\"#Shader代码基础\" class=\"headerlink\" title=\"Shader代码基础\"></a><a href=\"https://www.bilibili.com/video/BV1Xu4y1S7LF/?spm_id_from=333.1387.favlist.content.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">Shader代码基础</a></h2><h3 id=\"PART1\"><a href=\"#PART1\" class=\"headerlink\" title=\"PART1\"></a>PART1</h3><h4 id=\"Shader代码基本架构\"><a href=\"#Shader代码基本架构\" class=\"headerlink\" title=\"Shader代码基本架构\"></a>Shader代码基本架构</h4><pre><code class=\"language-c#\">Shader&quot;1️⃣&quot;\n&#123;\n    Properties\n    &#123;\n    2️⃣\n    &#125;\n    SubShader\n    &#123;\n    ️3️⃣\n        Pass\n        &#123;\n        4️⃣\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>1️⃣Shader名称</strong></p>\n<p><strong>2️⃣定义变量位置</strong><br>常见的五种变量类型:</p>\n<ul>\n<li>Float</li>\n<li>Range</li>\n<li>Vector</li>\n<li>Color</li>\n<li>Texture</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        //常用的五种数据类型\n        _Float(&quot;Float&quot;,Float)=0.0\n        _Range(&quot;Range&quot;,Range(0.0,1.0))=0.0\n        _Vector(&quot;Vector&quot;,Vector)=(1,1,1,1)\n        _Color(&quot;Color&quot;,Color)=(0.5,0.5,0.5,0.5)\n        _Texture(&quot;Texture&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n</code></pre>\n<p><strong>3️⃣主要Shader代码部分</strong><br>可以理解成一个Pass等于一个完整的GPU渲染管线，SubShader里可以写多个Pass，写几个代表会被重复渲染几次，而且每次调用的Shader都不一样。</p>\n<pre><code class=\"language-c#\">            CGPROGRAM\n            //中间的任何代码都属于unity cg的范围\n            ENDCG\n</code></pre>\n<ol>\n<li>这里对于<code>float</code>类型<a href=\"https://docs.unity3d.com/cn/current/Manual/SL-VertexProgramInputs.html\">补充</a>一点：</li>\n</ol>\n<ul>\n<li>‌<code>float‌</code>：用于表示单个浮点数，常用于颜色通道、位置坐标等。</li>\n<li>‌<code>float2‌</code>（Vector2）：用于表示二维向量，如二维坐标、UV坐标等。</li>\n<li>‌<code>float3‌</code>（Vector3）：用于表示三维向量，如位置、法线等。</li>\n<li>‌<code>float4‌</code>（Vector4）：用于表示四维向量，如颜色、四元数等。</li>\n</ul>\n<ol start=\"2\">\n<li><p>在unity中，一个模型最多有四套UV</p>\n</li>\n<li><p>float&#x2F;half&#x2F;fixed的区别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">位宽</th>\n<th align=\"center\">适用范围</th>\n<th align=\"center\">常见用途</th>\n<th align=\"center\">精度</th>\n<th align=\"center\">现代GPU支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32-bit</td>\n<td align=\"center\">大</td>\n<td align=\"center\">位置、物理计算、PBR</td>\n<td align=\"center\">高</td>\n<td align=\"center\">强烈推荐</td>\n</tr>\n<tr>\n<td align=\"center\">half</td>\n<td align=\"center\">16-bit</td>\n<td align=\"center\">中</td>\n<td align=\"center\">颜色计算、法线、屏幕后处理</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">推荐（移动端优化）</td>\n</tr>\n<tr>\n<td align=\"center\">fixed</td>\n<td align=\"center\">10-bit</td>\n<td align=\"center\">小</td>\n<td align=\"center\">颜色计算（老设备）</td>\n<td align=\"center\">低</td>\n<td align=\"center\">几乎淘汰</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"GPU渲染管线\"><a href=\"#GPU渲染管线\" class=\"headerlink\" title=\"GPU渲染管线\"></a>GPU渲染管线</h4><p><strong>基本结构</strong>：</p>\n<pre><code>【模型数据】 -&gt; 1️⃣【顶点Shader】 -&gt; 2️⃣【图元装配及光栅化】 -&gt; 3️⃣【片元Shader】 -&gt; 4️⃣【输出合并】\n            |-----------------------------GPU渲染管线---------------------------------------|\n</code></pre>\n<p><strong>1️⃣顶点Shader</strong>：</p>\n<ul>\n<li>将模型数据的模型空间坐标转换到对应的裁剪空间，即输出在裁剪空间下的顶点坐标</li>\n<li>【模型空间】 -&gt; 世界空间 -&gt; 相机空间 -&gt; 【裁剪空间】，中间经过三个矩阵（Model,View,Projection）操作</li>\n</ul>\n<p><strong>2️⃣图元装配及光栅化</strong></p>\n<ul>\n<li>硬件阶段</li>\n<li>生成片元并进行光栅化插值</li>\n</ul>\n<p><strong>3️⃣片元Shader</strong></p>\n<ul>\n<li>每个片元调用片元shader给自身着色</li>\n<li>计算对应的颜色后输出</li>\n</ul>\n<p><strong>4️⃣输出合并</strong></p>\n<ul>\n<li>输出到对应的帧缓冲区</li>\n</ul>\n<p><em><strong>一个完整的Shader通常由顶点Shader和片段Shader共同组成。</strong></em></p>\n<h4 id=\"完整Shader代码\"><a href=\"#完整Shader代码\" class=\"headerlink\" title=\"完整Shader代码\"></a>完整Shader代码</h4><pre><code class=\"language-c#\">// Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39;\n// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39;\nShader &quot;CS0102/shader&quot;\n&#123;\n    Properties\n    &#123;\n        // 常用的五种数据类型\n        _Float(&quot;Float&quot;, Float) = 0.0\n        _Range(&quot;Range&quot;, Range(0.0, 1.0)) = 0.0\n        _Vector(&quot;Vector&quot;, Vector) = (1,1,1,1)\n        _Color(&quot;Color&quot;, Color) = (0.5,0.5,0.5,0.5)\n        //_Texture(&quot;Texture&quot;, 2D) = &quot;black&quot; &#123;&#125; \n        _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            // Shader 主要代码部分\n            CGPROGRAM\n            #pragma vertex vert // 指定一个顶点 Shader：vert\n            #pragma fragment frag // 指定一个片元 Shader：frag\n            #include &quot;UnityCG.cginc&quot; // 头文件\n\n            // 从 CPU 端获取模型数据\n            struct appdata &#123;\n                float4 vertex : POSITION;  // 模型顶点坐标\n                // 第一套uv，共4个可用（TEXCOORD0~TEXCOORD3）\n                float2 uv : TEXCOORD0; \n                float3 normal : NORMAL;    // 法线\n                float4 color : COLOR;      // 顶点色\n            &#125;;\n            // 输出结构体定义\n            struct v2f &#123;\n                float4 pos : SV_POSITION;\n                //通用储存器（插值器），共16个可用（TEXCOORD0~TEXCOORD15）\n                float2 uv:TEXCOORD0;\n            &#125;;\n            float4 _Color;\n            sampler2D _MainTex;\n            float4 _MainTex_ST;//动态链接四个参数\n            // 顶点 Shader\n            v2f vert(appdata v) &#123;\n                v2f o;\n                //float4 pos_world = mul(unity_ObjectToWorld, v.vertex); // 模型空间转世界空间\n                //float4 pos_clip = mul(UNITY_MATRIX_VP, pos_world); // 世界空间直接变换到裁剪空间\n                //o.pos = pos_clip;\n                //或者直接合成一个mvp操作\n                o.pos=UnityObjectToClipPos(v.vertex);\n                //输出uv值\n                //o.uv=v.uv;\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            // 片元 Shader\n            float4 frag(v2f i) : SV_Target &#123;\n                //贴图采样\n                float4 col=tex2D(_MainTex,i.uv);\n                return col;\n            &#125;\n            ENDCG\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"PART2\"><a href=\"#PART2\" class=\"headerlink\" title=\"PART2\"></a>PART2</h3><h4 id=\"背面剔除（Backface-Culling）\"><a href=\"#背面剔除（Backface-Culling）\" class=\"headerlink\" title=\"背面剔除（Backface Culling）\"></a>背面剔除（Backface Culling）</h4><p>背面剔除在硬件阶段、NDC空间之后进行，Unity默认使用背面剔除（只渲染正面）。</p>\n<ol>\n<li>Shader代码控制:直接显示出渲染结果</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull Off  //1️⃣不剔除\n            Cull Back //2️⃣默认剔除背面\n            Cull Front//3️⃣剔除正面\n            //注意在CGPROGRAM之前\n            CGPROGRAM\n            ...\n            ENDCG\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>材质球控制：物体材质球处出现可选项：Off&#x2F;Front&#x2F;Back</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            Cull [_CullMode]\n        &#125;\n    &#125;\n</code></pre>\n<h3 id=\"PART3-纹理映射\"><a href=\"#PART3-纹理映射\" class=\"headerlink\" title=\"PART3 纹理映射\"></a>PART3 纹理映射</h3><h4 id=\"正面纹理采样设定\"><a href=\"#正面纹理采样设定\" class=\"headerlink\" title=\"正面纹理采样设定\"></a>正面纹理采样设定</h4><p>这里用XY坐标值采样贴图，即uv按模型本身的XY展开。<br>代码如下：</p>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                ...\n                float2 pos_uv:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                ...\n                o.pos_uv=v.vertex.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.pos_uv);\n                return col;\n            &#125;\n</code></pre>\n<p>👉️补充：</p>\n<ul>\n<li>正面 XY平面</li>\n<li>侧面 ZY平面</li>\n<li>俯视 XZ平面</li>\n</ul>\n<p>总结：纹理映射的来源不一定是单纯的o.uv的uv坐标，也可以是上面写的o.pos_uv（世界坐标pos_world也可）这种自己设定的值。</p>\n<p>另，如果想三平面都能够完美覆盖涉及到：<strong>三平面映射</strong>。up在此链接中有提到，所以查了其他教程补充在这里。</p>\n<h4 id=\"三平面映射\"><a href=\"#三平面映射\" class=\"headerlink\" title=\"三平面映射\"></a><a href=\"https://www.bilibili.com/opus/814269127492370548\">三平面映射</a></h4><ol>\n<li>**目的：**防止”纹理拉伸”</li>\n</ol>\n<p>防止纹理拉伸传统思路可以手动展开uv坐标以贴合模型起伏，但是难以适应实时渲染的要求，因此引入这一方法：三平面映射。</p>\n<ol start=\"2\">\n<li><p>**应用：**普通网格地形、瀑布、程序化建模的地形、水池的焦散效果</p>\n</li>\n<li><p><strong>实现步骤</strong></p>\n</li>\n</ol>\n<ul>\n<li>根据顶点的世界空间坐标计算对应的UV坐标</li>\n</ul>\n<pre><code class=\"language-c#\">//取每个片元在三个方向的uv坐标\nhalf2 yUV=IN.worldPos.xz/_TextureScale;\nhalf2 xUV=IN.worldPos.yz/_TextureScale;\nhalf2 zUV=IN.worldPos.xy/_TextureScale;\n</code></pre>\n<ul>\n<li>从x&#x2F;y&#x2F;z三个方向对漫反射贴图进行采样</li>\n</ul>\n<pre><code class=\"language-c#\">half3 yDiff=tex2D(_DiffuseMap,yUV);\nhalf3 xDiff=tex2D(_DiffuseMap,xUV);\nhalf3 zDiff=tex2D(_DiffuseMap,zUV);\n</code></pre>\n<ul>\n<li>调整三平面边界过渡的锐利度</li>\n</ul>\n<pre><code class=\"language-c#\">//用法线方向作为从三个方向采样的权重值\n//额外解决纹理接缝问题（法线是连续过渡的）\nhalf3 blendWeights=pow(abs(In.worldNormal),_TriplanarBlendSharpness);\n</code></pre>\n<ul>\n<li>将混合权重值单位化</li>\n</ul>\n<pre><code class=\"language-c#\">//第三步pow锐化三平面边界后，得到的法线值可能偏小\n//重新单位化\nblendWeights=blendWeights/(blendWeights.x+blendWeights.y+blendWeights.z);\n</code></pre>\n<ul>\n<li>按三个面的混合权重，将采样颜色混合在一起</li>\n</ul>\n<pre><code class=\"language-c#\">//根据混合系数混合\np.Albedo=xDiff*blendWeights.x+yDiff*blendWeights.y+zDiff*blendWeights.z;\n</code></pre>\n<p>更多相关内容<a href=\"https://www.bilibili.com/video/BV1AM4y1Y78D/?spm_id_from=333.337.search-card.all.click&vd_source=6cef69f555ee1eb889d44945f2a3a38b\">戳此</a></p>\n<h4 id=\"渲染扭曲问题\"><a href=\"#渲染扭曲问题\" class=\"headerlink\" title=\"渲染扭曲问题\"></a>渲染扭曲问题</h4><p>打印uv坐标：</p>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 col=tex2D(_MainTex,i.uv);\n                return float4(i.uv,0.0,0.0);\n            &#125;\n</code></pre>\n<p>若uv存在不连续的情况，则会导致贴图采样时引起纹理图像的失真问题。</p>\n<p><strong>👉️为什么会有uv不连续的现象？</strong><br>光栅化过程产生。光栅化时根据三角面的进行，每个三角按照每个三角面进行一个插值。而对于模型而言，其三角网排列就会造成一定程度上的问题。<br>解决方式：</p>\n<ul>\n<li>uv展开并缩放到0~1之间</li>\n<li>模型加面</li>\n<li>手动在片元shader中重新计算uv</li>\n</ul>\n<h3 id=\"PART4-透明度测试-Alpha-test\"><a href=\"#PART4-透明度测试-Alpha-test\" class=\"headerlink\" title=\"PART4 透明度测试 Alpha-test\"></a>PART4 透明度测试 Alpha-test</h3><p>参考链接<a href=\"https://docs.unity3d.com/cn/2020.2/Manual/SL-AlphaTest.html\">1️⃣</a><a href=\"https://blog.csdn.net/qq_34697930/article/details/136530909\">2️⃣</a></p>\n<h4 id=\"输出合并\"><a href=\"#输出合并\" class=\"headerlink\" title=\"输出合并\"></a>输出合并</h4><p>对于<strong>输出合并</strong>阶段，可以细分为：</p>\n<pre><code>【片元数据】Color,Depth\n    ↓\n【Alpha测试】\n    ↓\n【模板测试】Stencil Test\n    ↓\n【深度测试】Depth test\n    ↓\n【混合】Blending\n    ↓\n【帧缓冲区】Color,Depth,Stencil\n</code></pre>\n<h4 id=\"Alpha-test\"><a href=\"#Alpha-test\" class=\"headerlink\" title=\"Alpha-test\"></a>Alpha-test</h4><p>**Alpha 测试是拒绝将像素写入屏幕的最后机会。**在计算出最终输出颜色之后，颜色可选择性地将其 Alpha 值与固定值进行比较。如果测试失败，则不会将像素写入显示屏。</p>\n<p>当下在Shader中，很少会直接用alpha test这个指令。一般用的是更好用、更可控的指令：<code>clip</code>“裁剪”。</p>\n<p>如果clip()括号中的值&lt;0，整个模型将不显示。</p>\n<ol>\n<li>模型的一部分被裁剪掉</li>\n</ol>\n<pre><code class=\"language-c#\">            float4 frag(v2f i) : SV_Target &#123;\n                float4 gradient=tex2D(_MainTex,i.uv);\n                clip(gradient-0.1);\n                return gradient.xxx;\n            &#125;\n</code></pre>\n<ol start=\"2\">\n<li>设置一个值实现动态控制<br>好神奇😂我这里模型用的球，Cutout调到0.5变成吃豆人了</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainTex(&quot;MainTex&quot;,2D)=&quot;black&quot;&#123;&#125;\n         _Cutout(&quot;Cutout&quot;,Range(-0.1,1.1))=0.0\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&quot;CullMode&quot;,float)=2\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv).r;\n                clip(gradient-_Cutout);\n                return gradient.xxxx;\n                //gradient.xxxx等价于float4(gradient,gradient,gradient,gradient);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>对UV进行动画处理</li>\n</ol>\n<pre><code class=\"language-c#\">                half gradient=tex2D(_MainTex,i.uv+_Time.y).r;\n</code></pre>\n<ol start=\"4\">\n<li>对UV进行动画速度的处理</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _Speed(&quot;Speed&quot;,Vector)=(1,1,0,0)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _Speed;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>noise贴图控制<br>适当的模型+贴图可以实现波形扩散效果</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _NoiseTex(&quot;Noise Tex&quot;,2D)=&quot;white&quot;&#123;&#125;\n         //_MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float4 _NoiseTex_ST;\n            //float4 _MainColor;\n            half4 frag(v2f i) : SV_Target &#123;\n                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;\n                half noise=tex2D(_NoiseTex,i.uv+_Time.y*_Speed.zw).r;\n                clip(gradient-noise-_Cutout);\n                return noise.xxxx;\n                //return _MainColor;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p><strong>综上</strong> alpha-test可以用来做溶解相关的效果。</p>\n<h3 id=\"PART5-半透明混合-Blending\"><a href=\"#PART5-半透明混合-Blending\" class=\"headerlink\" title=\"PART5 半透明混合 Blending\"></a>PART5 半透明混合 Blending</h3><p>参考链接<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/\">1️⃣</a><a href=\"https://blog.csdn.net/weixin_34505326/article/details/112181270\">2️⃣</a></p>\n<ol>\n<li>实现半透明混合</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _MainColor(&quot;MainColor&quot;,Color)=(1,1,1,1)\n    &#125;saturate\n    SubShader\n    &#123;\n        Blend SrcAlpha OneMinusSrcAlpha//注意此句在CGPROGRAM之前\n        float4 _MainColor;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half4 col=tex2D(_MainTex,i.uv)*_MainColor;\n                return col;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>关闭ZWrite深度写入<br>半透明混合的使用要注意排序问题：<code>ZWrite Off</code></li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"3\">\n<li>渲染队列问题<br>先前我们的材质球的Render Queue为2000，处于不透明的渲染队列中。使用半透明效果必须记得使用<code>Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;</code>+关掉<code>ZWrite</code>（部分情况下ZWrite需要开启）</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass&#123;\n            ZWrite Off\n            Blend SrcAlpha OneMinusSrcAlpha\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"4\">\n<li>贴图半透效果</li>\n</ol>\n<ul>\n<li>当前贴图无alpha通道，所以只能用其灰度值来做一个半透效果。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz;\n                half alpha=tex2D(_MainTex,i.uv).r*_MainColor.a;\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<p>做出来的球像透明泡泡🤗好好看~</p>\n<ul>\n<li>增加显示强度<blockquote>\n<p>此处要确保alpha值在0~1的范围内，否则开HDR的时候就很容易出问题</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n         _Emiss(&quot;Emiss&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        float _Emiss;\n        Pass\n        &#123;\n            half4 frag(v2f i) : SV_Target &#123;\n                half3 col=_MainColor.xyz*_Emiss;\n\n                half alpha=saturate(tex2D(_MainTex,i.uv).r*_MainColor.a*_Emiss);\n                return float4(col,alpha);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"5\">\n<li>其他混合模式<br>常用的柔和叠加模式：<code>Blend SrcAlpha One</code></li>\n</ol>\n<h3 id=\"PART6-边缘光\"><a href=\"#PART6-边缘光\" class=\"headerlink\" title=\"PART6 边缘光\"></a>PART6 边缘光</h3><ol>\n<li>得到normal_world</li>\n</ol>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Pass\n        &#123;\n            struct appdata &#123;\n                float3 normal : NORMAL;\n            &#125;;\n            struct v2f &#123;\n                float3 normal_world:TEXCOORD1;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                v2f o;\n                o.pos=UnityObjectToClipPos(v.vertex);\n                o.normal_world=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz);\n                //\n                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;\n                return o;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"2\">\n<li>得到view_world</li>\n</ol>\n<pre><code class=\"language-c#\">            struct v2f &#123;\n                float3 view_world:TEXCOORD2;\n            &#125;;\n            v2f vert(appdata v) &#123;\n                float3 pos_world=mul(unity_ObjectToWorld,v.vertex).xyz;\n                o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);\n            &#125;\n</code></pre>\n<ol start=\"3\">\n<li>在片元Shader中把数据承接过来</li>\n</ol>\n<ul>\n<li><code>dot(a,b)</code>：a向量与b向量进行点乘。<br>两个向量越重合就越接近1；180°为-1。[-1,1]👉️dot结果在[-1,1]</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 normal_world=normalize(i.normal_world);\n                //光栅化的过程会导致向量的长度变化\n                float3 view_world=normalize(i.view_world);\n                float NdoV=saturate(dot(normal_world,view_world));\n                float rim=1.0-NdoV;\n                return NdoV.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"4\">\n<li>得到边缘光效果</li>\n</ol>\n<ul>\n<li>（来自弹幕佬的解释）边缘处的法线和视角方向接近垂直，dot&#x3D;0,1-dot进行取反，边缘就显示出颜色，其他部分就较为透明。</li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                ...\n                float rim=1.0-NdoV;\n                return rim.xxxx;\n            &#125;\n</code></pre>\n<ol start=\"5\">\n<li>边缘光改色</li>\n</ol>\n<ul>\n<li>也可以用alpha通道调：<code>float alpha=saturate((1.0-NdoV)*_Emiss);</code></li>\n</ul>\n<pre><code class=\"language-c#\">            half4 frag(v2f i) : SV_Target &#123;\n                float3 col=_MainColor.xyz*_Emiss;//乘倍增系数，Inspector可调\n                ...\n                return float4(col,alpha);\n            &#125;\n</code></pre>\n<ol start=\"6\">\n<li>边缘光对比度调节</li>\n</ol>\n<pre><code class=\"language-c#\">    Properties\n    &#123;\n        _RimPower(&quot;_RimPower&quot;,Float)=1.0\n    &#125;\n    SubShader\n    &#123;\n        Pass\n        &#123;\n            float _RimPower;\n            half4 frag(v2f i) : SV_Target &#123;\n               float NdoV=pow(saturate(dot(normal_world,view_world)),RimPower);\n               float fresnel=pow((1.0-NdoV),_RimPower);\n               float alpha=saturate(fresnel*_Emiss);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<ol start=\"7\">\n<li>模型透过问题：预先写深度<br>经过上面的步骤，模型能够看到内部的透过结构。如何避免这种现象？</li>\n</ol>\n<p>☝「打开ZWrite」<code>ZWrite On</code>。此时效果其实不算特别完美</p>\n<p>✌「再加一个&#96;Pass」预写一遍深度，代码如下：</p>\n<pre><code class=\"language-c#\">    SubShader\n    &#123;\n        Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;\n        Pass\n        &#123;\n            Cull Of\n            ZWrite On\n            ColorMask 0\n            CGPROGRAM\n            float4 _Color;\n            #pragma vertex vert\n            #pragma fragment frag\n            float4 vert(float4 veryexPos:POSITION):SV_POSITION\n            &#123;\n                return UnityObjectToClipPos(vertexPos);\n            &#125;\n            float4 frag(void):COLOR\n            &#123;\n                return _Color;\n            &#125;\n            ENDCG\n        &#125;\n        Pass\n        &#123;\n            ...\n        &#125;\n    &#125;\n</code></pre>\n<ul>\n<li>把最靠前的三角形的片元的深度预先<code>ZWrite On</code>写好</li>\n<li><code>Color Mask</code>的操作：只写深度，不写任何的颜色信息</li>\n<li>到了第二遍pass绘制的时候，这些片元就通过深度测试，默认把背后的像素剔除</li>\n</ul>\n<p>👉️ASE中有对应的功能，此处仅为简单演示。</p>\n<p>🤯🤯🤯断断续续一个多星期终于把这一小时的视频啃完辣！！！休息休息继续战斗！</p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"其他参考链接\"><a href=\"#其他参考链接\" class=\"headerlink\" title=\"其他参考链接\"></a>其他参考链接</h1><p>反射探针：<br><a href=\"https://zhuanlan.zhihu.com/p/438022045\">https://zhuanlan.zhihu.com/p/438022045</a><br>三大Shader编程语言：<br><a href=\"https://blog.csdn.net/weixin_56516170/article/details/135266277\">https://blog.csdn.net/weixin_56516170/article/details/135266277</a><br>《Shader入门精要》源代码:<br><a href=\"https://github.com/candycat1992/Unity_Shaders_Book\">https://github.com/candycat1992/Unity_Shaders_Book</a><br>法线贴图：<br><a href=\"https://blog.csdn.net/weixin_49427945/article/details/136458398\">https://blog.csdn.net/weixin_49427945/article/details/136458398</a><br><a href=\"https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html\">https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html</a></p>\n",
            "tags": [
                "笔记"
            ]
        }
    ]
}
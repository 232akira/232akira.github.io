<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Per aspera ad astra • Posts by &#34;笔记&#34; tag</title>
        <link>https://232akira.github.io</link>
        <description>欢迎交流学习!</description>
        <language>zh-CN</language>
        <pubDate>Sat, 25 Oct 2025 13:12:12 +0800</pubDate>
        <lastBuildDate>Sat, 25 Oct 2025 13:12:12 +0800</lastBuildDate>
        <category>记录</category>
        <category>专题</category>
        <category>力扣</category>
        <category>算法</category>
        <category>TIPS</category>
        <category>备忘录</category>
        <category>AI</category>
        <category>案例</category>
        <category>指南</category>
        <category>笔记</category>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/10/25/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Git%20&amp;%20GitHub%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</guid>
            <title>笔记🗒️ ⋮ Git相关</title>
            <link>https://232akira.github.io/2025/10/25/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20Git%20&amp;%20GitHub%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</link>
            <category>笔记</category>
            <pubDate>Sat, 25 Oct 2025 13:12:12 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Git相关补充也可访问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指南🧭 ⋮ 开源贡献&lt;/li&gt;
&lt;li&gt;指南🧭 ⋮ Obsidian Git同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Repo&#34;&gt;&lt;a href=&#34;#Repo&#34; class=&#34;headerlink&#34; title=&#34;Repo&#34;&gt;&lt;/a&gt;Repo&lt;/h3&gt;&lt;p&gt;repository，代码仓库&lt;/p&gt;
&lt;h3 id=&#34;Fork&#34;&gt;&lt;a href=&#34;#Fork&#34; class=&#34;headerlink&#34; title=&#34;Fork&#34;&gt;&lt;/a&gt;Fork&lt;/h3&gt;&lt;p&gt;分叉&lt;/p&gt;
&lt;h3 id=&#34;Clone&#34;&gt;&lt;a href=&#34;#Clone&#34; class=&#34;headerlink&#34; title=&#34;Clone&#34;&gt;&lt;/a&gt;Clone&lt;/h3&gt;&lt;p&gt;克隆&lt;/p&gt;
&lt;h3 id=&#34;Issues&#34;&gt;&lt;a href=&#34;#Issues&#34; class=&#34;headerlink&#34; title=&#34;Issues&#34;&gt;&lt;/a&gt;Issues&lt;/h3&gt;&lt;p&gt;议题&lt;/p&gt;
&lt;h3 id=&#34;PR（Pull-Requests）&#34;&gt;&lt;a href=&#34;#PR（Pull-Requests）&#34; class=&#34;headerlink&#34; title=&#34;PR（Pull Requests）&#34;&gt;&lt;/a&gt;PR（Pull Requests）&lt;/h3&gt;&lt;p&gt;合并申请。请求原作者把你fork仓库里的某个branch的改动，merge进他们的主仓库。&lt;/p&gt;
&lt;h3 id=&#34;Wiki&#34;&gt;&lt;a href=&#34;#Wiki&#34; class=&#34;headerlink&#34; title=&#34;Wiki&#34;&gt;&lt;/a&gt;Wiki&lt;/h3&gt;&lt;h3 id=&#34;branch&#34;&gt;&lt;a href=&#34;#branch&#34; class=&#34;headerlink&#34; title=&#34;branch&#34;&gt;&lt;/a&gt;branch&lt;/h3&gt;&lt;p&gt;分支&lt;/p&gt;
&lt;h3 id=&#34;merge&#34;&gt;&lt;a href=&#34;#merge&#34; class=&#34;headerlink&#34; title=&#34;merge&#34;&gt;&lt;/a&gt;merge&lt;/h3&gt;&lt;p&gt;合并&lt;/p&gt;
&lt;h3 id=&#34;commit&#34;&gt;&lt;a href=&#34;#commit&#34; class=&#34;headerlink&#34; title=&#34;commit&#34;&gt;&lt;/a&gt;commit&lt;/h3&gt;&lt;p&gt;提交&lt;/p&gt;
&lt;h3 id=&#34;FAQ&#34;&gt;&lt;a href=&#34;#FAQ&#34; class=&#34;headerlink&#34; title=&#34;FAQ&#34;&gt;&lt;/a&gt;FAQ&lt;/h3&gt;&lt;p&gt;Frequently Asked Questions，常见问题解答。&lt;/p&gt;
&lt;h3 id=&#34;Issue状态&#34;&gt;&lt;a href=&#34;#Issue状态&#34; class=&#34;headerlink&#34; title=&#34;Issue状态&#34;&gt;&lt;/a&gt;Issue状态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;open（开启）&lt;/li&gt;
&lt;li&gt;closed（关闭）&lt;/li&gt;
&lt;li&gt;reopened（重新开启）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;任务状态&#34;&gt;&lt;a href=&#34;#任务状态&#34; class=&#34;headerlink&#34; title=&#34;任务状态&#34;&gt;&lt;/a&gt;任务状态&lt;/h3&gt;&lt;p&gt;（Task Status，看板状态）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TODO（待办）&lt;/li&gt;
&lt;li&gt;WIP（Work In Progress，进行中）&lt;/li&gt;
&lt;li&gt;Done（已完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他&#34;&gt;&lt;a href=&#34;#其他&#34; class=&#34;headerlink&#34; title=&#34;其他&#34;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个Issue可关联多个任务，每个任务有自己的&lt;span style=&#34;border-bottom:2px dashed pink;&#34;&gt;任务状态&lt;/span&gt;，每个Issue有自己的&lt;span style=&#34;border-bottom:2px dashed pink;&#34;&gt;issue状态&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;画了张图：&lt;br&gt;&lt;a href=&#34;https://imgchr.com/i/pVvWksU&#34;&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://s21.ax1x.com/2025/10/26/pVvWksU.png&#34; alt=&#34;常用Git关系&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/09/29/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/</guid>
            <title>笔记🗒️ ⋮ AI Agent</title>
            <link>https://232akira.github.io/2025/09/29/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/</link>
            <category>笔记</category>
            <pubDate>Mon, 29 Sep 2025 16:30:01 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;Agent&#34;&gt;&lt;a href=&#34;#Agent&#34; class=&#34;headerlink&#34; title=&#34;Agent&#34;&gt;&lt;/a&gt;Agent&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;长期以来&lt;/strong&gt;，通用人工智能（Artificial General Intelligence，&lt;strong&gt;AGI&lt;/strong&gt;）&lt;strong&gt;一直被人类所追求&lt;/strong&gt;。&lt;br&gt;从1950年代Alan Turing的设想开始，Agent技术从早期的构想阶段逐渐成熟并落地，在2020年至今进入了爆发期——大模型Agent时代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;AI Agent&lt;/strong&gt;（Agent&amp;#x2F;代理&amp;#x2F;智能体…）更具备“人类”的思维方式，可以识别任务的需求分析、执行规划和问题决策。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一种说法……💭&lt;/strong&gt;&lt;br&gt;AI Agent是prompt工程的一种升级。而当下的商业产品也确实在走着&lt;code&gt;Chatbot&lt;/code&gt;-&amp;gt;&lt;code&gt;Copilot&lt;/code&gt;-&amp;gt;&lt;code&gt;Agent&lt;/code&gt;的演变路径。&lt;/p&gt;
&lt;h3 id=&#34;基于LLM驱动的AI-Agent&#34;&gt;&lt;a href=&#34;#基于LLM驱动的AI-Agent&#34; class=&#34;headerlink&#34; title=&#34;基于LLM驱动的AI Agent&#34;&gt;&lt;/a&gt;基于LLM驱动的AI Agent&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/pVyvhy6&#34;&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://s21.ax1x.com/2025/08/27/pVyvhy6.png&#34; alt=&#34;pVyvhy6.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当下，我们常见的&lt;strong&gt;Agent&lt;/strong&gt;往往就是&lt;strong&gt;基于LLM驱动的&lt;/strong&gt;AI Agent。在其体系中，LLM作为智能体的“大脑”（🧠），其他能力，如规划（Planning）、记忆（Memory）、工具使用（Tools）等作为补充。&lt;/p&gt;
&lt;h4 id=&#34;1️⃣规划能力（Planning）&#34;&gt;&lt;a href=&#34;#1️⃣规划能力（Planning）&#34; class=&#34;headerlink&#34; title=&#34;1️⃣规划能力（Planning）&#34;&gt;&lt;/a&gt;1️⃣规划能力（Planning）&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.  任务拆解&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;CoT（Chain of Thought）思维链&lt;/strong&gt;&lt;br&gt;告知模型要“step by step”，也就是去尝试把复杂任务拆解成更小的、更简单的任务列表。其使模型的思考过程更可解释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ToT（Tree of Thoughts）思维树&lt;/strong&gt;&lt;br&gt;ToT继承了CoT，并在CoT的基础上做了扩展：进一步要求LLM对子步骤生成更多思考，形成思维树。其结果的搜索可以是&lt;code&gt;BFS&lt;/code&gt;（breadth-first search）或&lt;code&gt;DFS&lt;/code&gt;(depth-first search)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.  自我反思&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ReAct（Reasoning and Acting）&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：是&lt;a href=&#34;https://arxiv.org/pdf/2210.03629&#34;&gt;ReAct&lt;/a&gt;不是前端框架React！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即&lt;strong&gt;推理与行动&lt;/strong&gt;：追踪LLM的生成过程（与外部系统交互、思考等）。相当于用自然语言做logging。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Reflexion&lt;/strong&gt;&lt;br&gt;即&lt;strong&gt;反思&lt;/strong&gt;：给agents装备动态记忆和自我反省能力，以增强推理能力的框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：区别&lt;code&gt;reflection&lt;/code&gt;与&lt;code&gt;reflexion&lt;/code&gt;!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;CoH（Chain of Hindsight）后见链&lt;/strong&gt;&lt;br&gt;让模型学习人类是如何根据反馈（尤其是负面反馈）来逐步改进和修正其输出的。其本质上是一种模型训练方法&amp;#x2F;推理策略，而不是像CoT、ToT、ReAct那样的&lt;a href=&#34;&#34;&gt;Prompt Engineering&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2️⃣记忆能力（Memory）&#34;&gt;&lt;a href=&#34;#2️⃣记忆能力（Memory）&#34; class=&#34;headerlink&#34; title=&#34;2️⃣记忆能力（Memory）&#34;&gt;&lt;/a&gt;2️⃣记忆能力（Memory）&lt;/h4&gt;&lt;p&gt;记忆可以被定义为获取、存储、保留、事后取回等针对信息的流程。一定程度上可与人类的记忆类型进行映射。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/pVyzlVS&#34;&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://s21.ax1x.com/2025/08/27/pVyzlVS.jpg&#34; alt=&#34;pVyzlVS.jpg&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里就不照搬&lt;a href=&#34;https://lilianweng.github.io/posts/2023-06-23-agent/&#34;&gt;原文&lt;/a&gt;了，简单拉个表总结一下👇&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;记忆类型&lt;/th&gt;
&lt;th&gt;英文名&lt;/th&gt;
&lt;th&gt;时长&lt;/th&gt;
&lt;th&gt;人类记忆&lt;/th&gt;
&lt;th&gt;映射到Agent&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;感觉记忆&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Sensory&lt;/strong&gt; Memory&lt;/td&gt;
&lt;td&gt;几秒&lt;/td&gt;
&lt;td&gt;瞬间的原始感官输入&lt;/td&gt;
&lt;td&gt;对原始输入做Embedding&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;短期记忆&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Short-Term&lt;/strong&gt; Memory&lt;/td&gt;
&lt;td&gt;20~30秒&lt;/td&gt;
&lt;td&gt;临时存储少量信息&lt;/td&gt;
&lt;td&gt;上下文学习（In-Context Learning）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长期记忆&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Long-Term&lt;/strong&gt; Memory&lt;/td&gt;
&lt;td&gt;几天~几十年&lt;/td&gt;
&lt;td&gt;长期存储大量信息&lt;/td&gt;
&lt;td&gt;外部的向量数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&#34;3️⃣工具使用（Tool-use）&#34;&gt;&lt;a href=&#34;#3️⃣工具使用（Tool-use）&#34; class=&#34;headerlink&#34; title=&#34;3️⃣工具使用（Tool use）&#34;&gt;&lt;/a&gt;3️⃣工具使用（Tool use）&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;调用外部API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. function call：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. mcp（model context protocol）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型上下文协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开源框架&#34;&gt;&lt;a href=&#34;#开源框架&#34; class=&#34;headerlink&#34; title=&#34;开源框架&#34;&gt;&lt;/a&gt;开源框架&lt;/h2&gt;&lt;h3 id=&#34;CrewAI&#34;&gt;&lt;a href=&#34;#CrewAI&#34; class=&#34;headerlink&#34; title=&#34;CrewAI&#34;&gt;&lt;/a&gt;CrewAI&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://crewai.org.cn/&#34;&gt;CrewAI官网戳此&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multi-Agent&lt;/li&gt;
&lt;li&gt;Orchestration&lt;/li&gt;
&lt;li&gt;Collaboration&lt;/li&gt;
&lt;li&gt;Crews&lt;/li&gt;
&lt;li&gt;Process&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LangGraph&#34;&gt;&lt;a href=&#34;#LangGraph&#34; class=&#34;headerlink&#34; title=&#34;LangGraph&#34;&gt;&lt;/a&gt;LangGraph&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://www.langchain.com/langgraph&#34;&gt;LangGraph官网戳此&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stateful&lt;/li&gt;
&lt;li&gt;Workflows&lt;/li&gt;
&lt;li&gt;Cycles&lt;/li&gt;
&lt;li&gt;Graph&lt;/li&gt;
&lt;li&gt;Control Flow&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LlamaIndex&#34;&gt;&lt;a href=&#34;#LlamaIndex&#34; class=&#34;headerlink&#34; title=&#34;LlamaIndex&#34;&gt;&lt;/a&gt;LlamaIndex&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://docs.llamaindex.ai/en/stable/&#34;&gt;LlamaIndex官网戳此&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;li&gt;RAG&lt;/li&gt;
&lt;li&gt;Retrieval&lt;/li&gt;
&lt;li&gt;Querying&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Strands-Agents&#34;&gt;&lt;a href=&#34;#Strands-Agents&#34; class=&#34;headerlink&#34; title=&#34;Strands Agents&#34;&gt;&lt;/a&gt;Strands Agents&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://strandsagents.com/latest/&#34;&gt;Strands Agents官网戳此&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Financial&lt;/li&gt;
&lt;li&gt;Data Analysis&lt;/li&gt;
&lt;li&gt;Pre-built&lt;/li&gt;
&lt;li&gt;Domain-Specific&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Agent-Infra&#34;&gt;&lt;a href=&#34;#Agent-Infra&#34; class=&#34;headerlink&#34; title=&#34;Agent Infra&#34;&gt;&lt;/a&gt;Agent Infra&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;即AI Agentic基础设施&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;AgentCore&#34;&gt;&lt;a href=&#34;#AgentCore&#34; class=&#34;headerlink&#34; title=&#34;AgentCore&#34;&gt;&lt;/a&gt;AgentCore&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;即Amazon Bedrock AgentCore&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;未完待续……&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://lilianweng.github.io/posts/2023-06-23-agent/&#34;&gt;LLM Powered Autonomous Agents | Lil’Log&lt;/a&gt; ⭐&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/641322714&#34;&gt;LLM Powered Autonomous Agents（中翻+insight） - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/678046050&#34;&gt;7000长文：一文读懂Agent，大模型的下一站 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/2401_84204207/article/details/147516308&#34;&gt;380篇文献！首份Agentic大模型最新技术综述_agentic+llm-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/2532014&#34;&gt;【科普篇】LLM、GPT、AIGC、AI Agent、Agentic AI 到底是个啥？-腾讯云开发者社区-腾讯云&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/641322714&#34;&gt;(9 封私信) LLM Powered Autonomous Agents（中翻+insight） - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.woshipm.com/ai/6246084.html&#34;&gt;万字Agent详解：Agent的发展和应用 | 人人都是产品经理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://react-lm.github.io/&#34;&gt;ReAct: Synergizing Reasoning and Acting in Language Models&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/09/14/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</guid>
            <title>笔记🗒️ ⋮ 评论系统配置</title>
            <link>https://232akira.github.io/2025/09/14/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</link>
            <category>笔记</category>
            <pubDate>Sun, 14 Sep 2025 21:38:03 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;先叨叨一下心路历程。一开始在死磕&lt;strong&gt;waline&lt;/strong&gt;的配置（+vercle），结果就是前端有评论模块，但是点击提交评论就会报错&lt;code&gt;Failed to fetch&lt;/code&gt;，历经多月绞尽脑汁最终惨败。&lt;br&gt;今天突发奇想换成&lt;strong&gt;twikoo&lt;/strong&gt;试一下，结果跟着官方教程一遍过了😭特别感动！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本博客的美丽主题来自👉&lt;a href=&#34;https://github.com/theme-shoka-x/hexo-theme-shokaX&#34;&gt;ShokaX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;美丽主题的评论系统配置&lt;a href=&#34;https://docs.shokax.kaitaku.xyz/features/comments/&#34;&gt;戳此&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twikoo快速上手&lt;a href=&#34;https://twikoo.js.org/quick-start.html&#34;&gt;戳此&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开始配置&#34;&gt;&lt;a href=&#34;#开始配置&#34; class=&#34;headerlink&#34; title=&#34;开始配置&#34;&gt;&lt;/a&gt;开始配置&lt;/h2&gt;&lt;p&gt;此博客用的是shokax官方推荐的&lt;code&gt;云函数部署&lt;/code&gt;-&amp;gt;&lt;code&gt;Vercel部署&lt;/code&gt;的方式。&lt;/p&gt;
&lt;p&gt;主要在&lt;strong&gt;两个网站&lt;/strong&gt;上操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MongoDB Atlas&lt;/code&gt;：云端数据库托管服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vercel&lt;/code&gt;：云端部署平台&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;MongoDB Atlas&lt;/code&gt;、&lt;code&gt;Vercel&lt;/code&gt;、&lt;code&gt;用户评论&lt;/code&gt;&lt;strong&gt;三者的关系&lt;/strong&gt;可以理解为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户评论 -- Vercel --&amp;gt; MongoDB（长期保存）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;MongoDB-Atlas&#34;&gt;&lt;a href=&#34;#MongoDB-Atlas&#34; class=&#34;headerlink&#34; title=&#34;MongoDB Atlas&#34;&gt;&lt;/a&gt;MongoDB Atlas&lt;/h3&gt;&lt;p&gt;官方教程&lt;a href=&#34;https://twikoo.js.org/mongodb-atlas.html&#34;&gt;戳此&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册账号&lt;/li&gt;
&lt;li&gt;新建数据库（区域选择AWS）&lt;/li&gt;
&lt;li&gt;Database Access-&amp;gt;新建权限为Admin的用户并记住账号密码&lt;/li&gt;
&lt;li&gt;Network Access-&amp;gt;添加网络白名单（0.0.0.0&amp;#x2F;0）&lt;/li&gt;
&lt;li&gt;Database-&amp;gt;Connect-&amp;gt;Drivers&lt;/li&gt;
&lt;li&gt;复制&lt;code&gt;数据库连接字符串&lt;/code&gt;（&lt;code&gt;&amp;lt;username&amp;gt;:&amp;lt;passname&amp;gt;&lt;/code&gt;修改为&lt;code&gt;用户名：密码&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;⚠注意替换用户名密码时把原尖括号删掉！！！&lt;/p&gt;
&lt;h3 id=&#34;Vercel&#34;&gt;&lt;a href=&#34;#Vercel&#34; class=&#34;headerlink&#34; title=&#34;Vercel&#34;&gt;&lt;/a&gt;Vercel&lt;/h3&gt;&lt;p&gt;官方教程&lt;a href=&#34;https://twikoo.js.org/backend.html#vercel-%E9%83%A8%E7%BD%B2&#34;&gt;戳此&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册账号&lt;/li&gt;
&lt;li&gt;将twikoo&lt;a href=&#34;https://vercel.com/import/project?template=https://github.com/twikoojs/twikoo/tree/main/src/server/vercel-min&#34;&gt;一键部署&lt;/a&gt;到vercel&lt;/li&gt;
&lt;li&gt;进入你上一步部署的repo-&amp;gt;settings&lt;/li&gt;
&lt;li&gt;settings-&amp;gt;Environment Variables-&amp;gt;添加环境变量（NAME:&lt;code&gt;MONGODB_URI&lt;/code&gt;；VALUE：&lt;code&gt;数据库连接字符串&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;弹窗-&amp;gt;Redeploy&lt;/li&gt;
&lt;li&gt;settings-&amp;gt;Deployment Protection-&amp;gt;&lt;code&gt;Vercel Authentication&lt;/code&gt;设置为&lt;code&gt;Disabled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;弹窗-&amp;gt;Redeploy&lt;/li&gt;
&lt;li&gt;Overview-&amp;gt;visit-&amp;gt;Twikoo云函数运行正常&lt;/li&gt;
&lt;li&gt;复制&lt;code&gt;visit跳转的网址&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;config-shokax-yml&#34;&gt;&lt;a href=&#34;#config-shokax-yml&#34; class=&#34;headerlink&#34; title=&#34;_config.shokax.yml&#34;&gt;&lt;/a&gt;_config.shokax.yml&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#twikoo评论配置
twikoo:
  enable: true # 是否开启
  mode: vercel # vercel(私有部署) 或 tencent
  envId: &amp;quot;visit跳转的网址&amp;quot; # twikoo 环境 ID,vercel 和私有部署填地址
  region: # vercel 和私有部署不填，腾讯云见 twikoo 文档
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;评论系统就这样配好了！欢迎宝宝们友好交流！！o(&lt;em&gt;￣▽￣&lt;/em&gt;)ブ~♥&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20MCP%EF%BC%88Model%20Context%20Protocol%EF%BC%89/</guid>
            <title>笔记🗒️ ⋮ MCP（Model Context Protocol）</title>
            <link>https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20MCP%EF%BC%88Model%20Context%20Protocol%EF%BC%89/</link>
            <category>笔记</category>
            <pubDate>Sun, 24 Aug 2025 16:30:03 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;应用背景&#34;&gt;&lt;a href=&#34;#应用背景&#34; class=&#34;headerlink&#34; title=&#34;应用背景&#34;&gt;&lt;/a&gt;应用背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你是否向大模型提问过：“现在几点了？”“我这里的天气怎么样？”的问题？那么它能够正确回答吗？&lt;/p&gt;
&lt;p&gt;目前来看——一般会回答错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当下，LLM的能力早已不局限于“文本生成”，而是能够通过外部工具的调用变得“手眼通天”：脱离原有的封闭环境，获得了&lt;strong&gt;与外部环境交互&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;相当于给大模型加上了手脚🧐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与外部环境交互&lt;/strong&gt;通过&lt;code&gt;MCP&lt;/code&gt;进行工具调用的规范化，通过&lt;code&gt;A2A&lt;/code&gt;实现Agent与Agent之间交互的规范化。&lt;/p&gt;
&lt;h2 id=&#34;Function-Calling-MCP&#34;&gt;&lt;a href=&#34;#Function-Calling-MCP&#34; class=&#34;headerlink&#34; title=&#34;Function Calling-&amp;gt;MCP&#34;&gt;&lt;/a&gt;Function Calling-&amp;gt;MCP&lt;/h2&gt;&lt;p&gt;工具调用基于&lt;code&gt;function calling&lt;/code&gt;实现并被广泛用于商业API交互，目前国产的主流LLM大多已支持。&lt;br&gt;而Ahthropic推出的&lt;strong&gt;MCP&lt;/strong&gt;（Model Context Protocol）正是针对“工具调用接口的规范化”应运而生的协议。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;调用的过程其实是让大模型理解我们需求的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里按个人理解写一下MCP应用流程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用户通过配置MCP服务-&amp;gt;提供工具调用的相关函数及其对应的传参要求，

模型在
  - 理解用户需求
  - 学会函数对应参数的攥写格式
的基础上，
判断函数是否调用、如何调用、拿到返回的结果后如何分析。
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Function Calling和MCP是当前技术落地的核心方式。前者侧重模型原生能力，后者强调协议标准化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么AI Agent（人工智能代理&amp;#x2F;智能体）则为更高阶的形态，其融合了自主决策+工具调用，能够更加适用于复杂场景。&lt;/p&gt;
&lt;h2 id=&#34;MCP-A2A&#34;&gt;&lt;a href=&#34;#MCP-A2A&#34; class=&#34;headerlink&#34; title=&#34;MCP-&amp;gt;A2A&#34;&gt;&lt;/a&gt;MCP-&amp;gt;A2A&lt;/h2&gt;&lt;p&gt;若再视野拓展至MAS（Multi-Agent Systems）的多智能体系统协作领域，我们就不能不提起&lt;strong&gt;A2A&lt;/strong&gt;（Agent-to-Agent Protocol,代理间通信协议）。&lt;/p&gt;
&lt;p&gt;到这里可以将上文提到的三个概念搭建为三层级的技术栈模型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       【A2A】         // Agent与Agent~协作网络
          ↑
       【MCP】         // Agent与工具~资源与会话管理
          ↑
 【Function Calling】  //模型原生能力
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Google将A2A比作互联网早期的HTTP协议&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/1916821381879931822&#34;&gt;(7 封私信) 深度研究报告：大模型工具调用（Tool-use）的技术演进与协议生态分析 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hwhsong/article/details/147244842&#34;&gt;【AI学习】大模型调用外部工具的主流方式对比_大模型工具调用-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20LangChain/</guid>
            <title>笔记🗒️ ⋮ LangChain</title>
            <link>https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20LangChain/</link>
            <category>笔记</category>
            <pubDate>Sun, 24 Aug 2025 16:30:02 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;定义&#34;&gt;&lt;a href=&#34;#定义&#34; class=&#34;headerlink&#34; title=&#34;定义&#34;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;LangChain是一个&lt;/strong&gt;用于开发由语言模型驱动的应用程序的&lt;strong&gt;框架&lt;/strong&gt;。也就是可以将LLM、向量数据库、交互层prompt、外部知识和外部工具等整合到一起&lt;/p&gt;
&lt;h2 id=&#34;六大组件&#34;&gt;&lt;a href=&#34;#六大组件&#34; class=&#34;headerlink&#34; title=&#34;六大组件&#34;&gt;&lt;/a&gt;六大组件&lt;/h2&gt;&lt;p&gt;LangChain的六大组件分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model I&amp;#x2F;O&lt;/li&gt;
&lt;li&gt;Data Connection&lt;/li&gt;
&lt;li&gt;Chains&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;Agent&lt;/li&gt;
&lt;li&gt;Callback&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-Model-I-O&#34;&gt;&lt;a href=&#34;#1-Model-I-O&#34; class=&#34;headerlink&#34; title=&#34;1. Model I&amp;#x2F;O&#34;&gt;&lt;/a&gt;1. Model I&amp;#x2F;O&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;模型输入输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-Data-Connection&#34;&gt;&lt;a href=&#34;#2-Data-Connection&#34; class=&#34;headerlink&#34; title=&#34;2. Data Connection&#34;&gt;&lt;/a&gt;2. Data Connection&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;数据连接&amp;#x2F;增强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供文档加载、转换、存储和查询数据的构建块。&lt;/p&gt;
&lt;h3 id=&#34;3-Chains&#34;&gt;&lt;a href=&#34;#3-Chains&#34; class=&#34;headerlink&#34; title=&#34;3. Chains&#34;&gt;&lt;/a&gt;&lt;strong&gt;3. Chains&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;链&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多个LLM模型包装器或其他组件进行链式连接。&lt;/p&gt;
&lt;h3 id=&#34;4-Memory&#34;&gt;&lt;a href=&#34;#4-Memory&#34; class=&#34;headerlink&#34; title=&#34;4. Memory&#34;&gt;&lt;/a&gt;4. Memory&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;记忆&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;支持读取和写入记忆模块，可独立使用或集成到链。&lt;/p&gt;
&lt;h3 id=&#34;5-Agent&#34;&gt;&lt;a href=&#34;#5-Agent&#34; class=&#34;headerlink&#34; title=&#34;5. Agent&#34;&gt;&lt;/a&gt;&lt;strong&gt;5. Agent&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用LLM选择操作序列而非硬编码。&lt;/p&gt;
&lt;h3 id=&#34;6-Callback&#34;&gt;&lt;a href=&#34;#6-Callback&#34; class=&#34;headerlink&#34; title=&#34;6. Callback&#34;&gt;&lt;/a&gt;6. Callback&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;回调&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;允许开发者在LLM应用的各个阶段对状态进行干预。&lt;/p&gt;
&lt;h2 id=&#34;ReAct&#34;&gt;&lt;a href=&#34;#ReAct&#34; class=&#34;headerlink&#34; title=&#34;ReAct&#34;&gt;&lt;/a&gt;ReAct&lt;/h2&gt;&lt;p&gt;在&lt;a href=&#34;https://232akira.github.io/2025/08/24/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20AI%20Agent/&#34;&gt;笔记🗒️ ⋮ AI Agent&lt;/a&gt;中也有提到。这里详细说明一下LangChain&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;未完待续……&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://python.langchain.com/docs/get_started/introduction&#34;&gt;https://python.langchain.com/docs/get_started/introduction&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/2301_81940605/article/details/138605789&#34;&gt;全网最全：一文入门最热的LLM应用开发框架LangChain_langchain开发-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</guid>
            <title>笔记🗒️ ⋮ 游戏开发</title>
            <link>https://232akira.github.io/2025/04/06/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0%F0%9F%97%92%EF%B8%8F%20%E2%8B%AE%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link>
            <category>笔记</category>
            <pubDate>Sun, 06 Apr 2025 22:22:22 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;👌当下主要学习&lt;strong&gt;图形&lt;/strong&gt;方向，具体细节可以查看&lt;a href=&#34;https://docs.unity3d.com/cn/current/Manual/Graphics.html&#34;&gt;Unity官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;渲染管线
摄像机
光照
模型
网格
纹理
着色器
材质
Visual effects
天空
颜色
图形API
Graphics performance and profiling
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然自己程序方面更擅长C++而且现在用UE也是个趋势，但是Unity普及度更高而且教程更多，UE蓝图也摒弃了传统的纯程序开发路线，所以打好这方面基础是现在最需要做的。如果有任何建议和想法需要交流欢迎联系我！不断试错不断学习中🤗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔记内容90%来自视频原话，其他内容个人补充，欢迎勘误。&lt;br&gt;学习内容大多来自b站佬们的教程（先三连之后看的！）🤟参考链接点击标题跳转&lt;/p&gt;
&lt;h1 id=&#34;项目实战-Uinty&#34;&gt;&lt;a href=&#34;#项目实战-Uinty&#34; class=&#34;headerlink&#34; title=&#34;项目实战-Uinty&#34;&gt;&lt;/a&gt;项目实战-Uinty&lt;/h1&gt;&lt;h2 id=&#34;Shader代码基础&#34;&gt;&lt;a href=&#34;#Shader代码基础&#34; class=&#34;headerlink&#34; title=&#34;Shader代码基础&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Xu4y1S7LF/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=6cef69f555ee1eb889d44945f2a3a38b&#34;&gt;Shader代码基础&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;PART1&#34;&gt;&lt;a href=&#34;#PART1&#34; class=&#34;headerlink&#34; title=&#34;PART1&#34;&gt;&lt;/a&gt;PART1&lt;/h3&gt;&lt;h4 id=&#34;Shader代码基本架构&#34;&gt;&lt;a href=&#34;#Shader代码基本架构&#34; class=&#34;headerlink&#34; title=&#34;Shader代码基本架构&#34;&gt;&lt;/a&gt;Shader代码基本架构&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;Shader&amp;quot;1️⃣&amp;quot;
&amp;#123;
    Properties
    &amp;#123;
    2️⃣
    &amp;#125;
    SubShader
    &amp;#123;
    ️3️⃣
        Pass
        &amp;#123;
        4️⃣
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1️⃣Shader名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2️⃣定义变量位置&lt;/strong&gt;&lt;br&gt;常见的五种变量类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Float&lt;/li&gt;
&lt;li&gt;Range&lt;/li&gt;
&lt;li&gt;Vector&lt;/li&gt;
&lt;li&gt;Color&lt;/li&gt;
&lt;li&gt;Texture&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
        //常用的五种数据类型
        _Float(&amp;quot;Float&amp;quot;,Float)=0.0
        _Range(&amp;quot;Range&amp;quot;,Range(0.0,1.0))=0.0
        _Vector(&amp;quot;Vector&amp;quot;,Vector)=(1,1,1,1)
        _Color(&amp;quot;Color&amp;quot;,Color)=(0.5,0.5,0.5,0.5)
        _Texture(&amp;quot;Texture&amp;quot;,2D)=&amp;quot;black&amp;quot;&amp;#123;&amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3️⃣主要Shader代码部分&lt;/strong&gt;&lt;br&gt;可以理解成一个Pass等于一个完整的GPU渲染管线，SubShader里可以写多个Pass，写几个代表会被重复渲染几次，而且每次调用的Shader都不一样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            CGPROGRAM
            //中间的任何代码都属于unity cg的范围
            ENDCG
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;这里对于&lt;code&gt;float&lt;/code&gt;类型&lt;a href=&#34;https://docs.unity3d.com/cn/current/Manual/SL-VertexProgramInputs.html&#34;&gt;补充&lt;/a&gt;一点：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;‌&lt;code&gt;float‌&lt;/code&gt;：用于表示单个浮点数，常用于颜色通道、位置坐标等。&lt;/li&gt;
&lt;li&gt;‌&lt;code&gt;float2‌&lt;/code&gt;（Vector2）：用于表示二维向量，如二维坐标、UV坐标等。&lt;/li&gt;
&lt;li&gt;‌&lt;code&gt;float3‌&lt;/code&gt;（Vector3）：用于表示三维向量，如位置、法线等。&lt;/li&gt;
&lt;li&gt;‌&lt;code&gt;float4‌&lt;/code&gt;（Vector4）：用于表示四维向量，如颜色、四元数等。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;在unity中，一个模型最多有四套UV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;float&amp;#x2F;half&amp;#x2F;fixed的区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;位宽&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;适用范围&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常见用途&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;精度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;现代GPU支持情况&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;float&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32-bit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;位置、物理计算、PBR&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;高&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;强烈推荐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;half&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16-bit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;中&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;颜色计算、法线、屏幕后处理&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;中等&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;推荐（移动端优化）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;fixed&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10-bit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;颜色计算（老设备）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;低&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;几乎淘汰&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;GPU渲染管线&#34;&gt;&lt;a href=&#34;#GPU渲染管线&#34; class=&#34;headerlink&#34; title=&#34;GPU渲染管线&#34;&gt;&lt;/a&gt;GPU渲染管线&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;基本结构&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;【模型数据】 -&amp;gt; 1️⃣【顶点Shader】 -&amp;gt; 2️⃣【图元装配及光栅化】 -&amp;gt; 3️⃣【片元Shader】 -&amp;gt; 4️⃣【输出合并】
            |-----------------------------GPU渲染管线---------------------------------------|
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1️⃣顶点Shader&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将模型数据的模型空间坐标转换到对应的裁剪空间，即输出在裁剪空间下的顶点坐标&lt;/li&gt;
&lt;li&gt;【模型空间】 -&amp;gt; 世界空间 -&amp;gt; 相机空间 -&amp;gt; 【裁剪空间】，中间经过三个矩阵（Model,View,Projection）操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2️⃣图元装配及光栅化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件阶段&lt;/li&gt;
&lt;li&gt;生成片元并进行光栅化插值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3️⃣片元Shader&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个片元调用片元shader给自身着色&lt;/li&gt;
&lt;li&gt;计算对应的颜色后输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4️⃣输出合并&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出到对应的帧缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;一个完整的Shader通常由顶点Shader和片段Shader共同组成。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;完整Shader代码&#34;&gt;&lt;a href=&#34;#完整Shader代码&#34; class=&#34;headerlink&#34; title=&#34;完整Shader代码&#34;&gt;&lt;/a&gt;完整Shader代码&lt;/h4&gt;&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;// Upgrade NOTE: replaced &amp;#39;mul(UNITY_MATRIX_MVP,*)&amp;#39; with &amp;#39;UnityObjectToClipPos(*)&amp;#39;
// Upgrade NOTE: replaced &amp;#39;_Object2World&amp;#39; with &amp;#39;unity_ObjectToWorld&amp;#39;
Shader &amp;quot;CS0102/shader&amp;quot;
&amp;#123;
    Properties
    &amp;#123;
        // 常用的五种数据类型
        _Float(&amp;quot;Float&amp;quot;, Float) = 0.0
        _Range(&amp;quot;Range&amp;quot;, Range(0.0, 1.0)) = 0.0
        _Vector(&amp;quot;Vector&amp;quot;, Vector) = (1,1,1,1)
        _Color(&amp;quot;Color&amp;quot;, Color) = (0.5,0.5,0.5,0.5)
        //_Texture(&amp;quot;Texture&amp;quot;, 2D) = &amp;quot;black&amp;quot; &amp;#123;&amp;#125; 
        _MainTex(&amp;quot;MainTex&amp;quot;,2D)=&amp;quot;black&amp;quot;&amp;#123;&amp;#125;
    &amp;#125;
    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            // Shader 主要代码部分
            CGPROGRAM
            #pragma vertex vert // 指定一个顶点 Shader：vert
            #pragma fragment frag // 指定一个片元 Shader：frag
            #include &amp;quot;UnityCG.cginc&amp;quot; // 头文件

            // 从 CPU 端获取模型数据
            struct appdata &amp;#123;
                float4 vertex : POSITION;  // 模型顶点坐标
                // 第一套uv，共4个可用（TEXCOORD0~TEXCOORD3）
                float2 uv : TEXCOORD0; 
                float3 normal : NORMAL;    // 法线
                float4 color : COLOR;      // 顶点色
            &amp;#125;;
            // 输出结构体定义
            struct v2f &amp;#123;
                float4 pos : SV_POSITION;
                //通用储存器（插值器），共16个可用（TEXCOORD0~TEXCOORD15）
                float2 uv:TEXCOORD0;
            &amp;#125;;
            float4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;//动态链接四个参数
            // 顶点 Shader
            v2f vert(appdata v) &amp;#123;
                v2f o;
                //float4 pos_world = mul(unity_ObjectToWorld, v.vertex); // 模型空间转世界空间
                //float4 pos_clip = mul(UNITY_MATRIX_VP, pos_world); // 世界空间直接变换到裁剪空间
                //o.pos = pos_clip;
                //或者直接合成一个mvp操作
                o.pos=UnityObjectToClipPos(v.vertex);
                //输出uv值
                //o.uv=v.uv;
                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;
                return o;
            &amp;#125;
            // 片元 Shader
            float4 frag(v2f i) : SV_Target &amp;#123;
                //贴图采样
                float4 col=tex2D(_MainTex,i.uv);
                return col;
            &amp;#125;
            ENDCG
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;PART2&#34;&gt;&lt;a href=&#34;#PART2&#34; class=&#34;headerlink&#34; title=&#34;PART2&#34;&gt;&lt;/a&gt;PART2&lt;/h3&gt;&lt;h4 id=&#34;背面剔除（Backface-Culling）&#34;&gt;&lt;a href=&#34;#背面剔除（Backface-Culling）&#34; class=&#34;headerlink&#34; title=&#34;背面剔除（Backface Culling）&#34;&gt;&lt;/a&gt;背面剔除（Backface Culling）&lt;/h4&gt;&lt;p&gt;背面剔除在硬件阶段、NDC空间之后进行，Unity默认使用背面剔除（只渲染正面）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shader代码控制:直接显示出渲染结果&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            Cull Off  //1️⃣不剔除
            Cull Back //2️⃣默认剔除背面
            Cull Front//3️⃣剔除正面
            //注意在CGPROGRAM之前
            CGPROGRAM
            ...
            ENDCG
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;材质球控制：物体材质球处出现可选项：Off&amp;#x2F;Front&amp;#x2F;Back&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&amp;quot;CullMode&amp;quot;,float)=2
    &amp;#125;
    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            Cull [_CullMode]
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;PART3-纹理映射&#34;&gt;&lt;a href=&#34;#PART3-纹理映射&#34; class=&#34;headerlink&#34; title=&#34;PART3 纹理映射&#34;&gt;&lt;/a&gt;PART3 纹理映射&lt;/h3&gt;&lt;h4 id=&#34;正面纹理采样设定&#34;&gt;&lt;a href=&#34;#正面纹理采样设定&#34; class=&#34;headerlink&#34; title=&#34;正面纹理采样设定&#34;&gt;&lt;/a&gt;正面纹理采样设定&lt;/h4&gt;&lt;p&gt;这里用XY坐标值采样贴图，即uv按模型本身的XY展开。&lt;br&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            struct v2f &amp;#123;
                ...
                float2 pos_uv:TEXCOORD1;
            &amp;#125;;
            v2f vert(appdata v) &amp;#123;
                ...
                o.pos_uv=v.vertex.xy*_MainTex_ST.xy+_MainTex_ST.zw;
                return o;
            &amp;#125;
            float4 frag(v2f i) : SV_Target &amp;#123;
                float4 col=tex2D(_MainTex,i.pos_uv);
                return col;
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👉️补充：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正面 XY平面&lt;/li&gt;
&lt;li&gt;侧面 ZY平面&lt;/li&gt;
&lt;li&gt;俯视 XZ平面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：纹理映射的来源不一定是单纯的o.uv的uv坐标，也可以是上面写的o.pos_uv（世界坐标pos_world也可）这种自己设定的值。&lt;/p&gt;
&lt;p&gt;另，如果想三平面都能够完美覆盖涉及到：&lt;strong&gt;三平面映射&lt;/strong&gt;。up在此链接中有提到，所以查了其他教程补充在这里。&lt;/p&gt;
&lt;h4 id=&#34;三平面映射&#34;&gt;&lt;a href=&#34;#三平面映射&#34; class=&#34;headerlink&#34; title=&#34;三平面映射&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://www.bilibili.com/opus/814269127492370548&#34;&gt;三平面映射&lt;/a&gt;&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;**目的：**防止”纹理拉伸”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;防止纹理拉伸传统思路可以手动展开uv坐标以贴合模型起伏，但是难以适应实时渲染的要求，因此引入这一方法：三平面映射。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;**应用：**普通网格地形、瀑布、程序化建模的地形、水池的焦散效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;实现步骤&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;根据顶点的世界空间坐标计算对应的UV坐标&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;//取每个片元在三个方向的uv坐标
half2 yUV=IN.worldPos.xz/_TextureScale;
half2 xUV=IN.worldPos.yz/_TextureScale;
half2 zUV=IN.worldPos.xy/_TextureScale;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;从x&amp;#x2F;y&amp;#x2F;z三个方向对漫反射贴图进行采样&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;half3 yDiff=tex2D(_DiffuseMap,yUV);
half3 xDiff=tex2D(_DiffuseMap,xUV);
half3 zDiff=tex2D(_DiffuseMap,zUV);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;调整三平面边界过渡的锐利度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;//用法线方向作为从三个方向采样的权重值
//额外解决纹理接缝问题（法线是连续过渡的）
half3 blendWeights=pow(abs(In.worldNormal),_TriplanarBlendSharpness);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;将混合权重值单位化&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;//第三步pow锐化三平面边界后，得到的法线值可能偏小
//重新单位化
blendWeights=blendWeights/(blendWeights.x+blendWeights.y+blendWeights.z);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;按三个面的混合权重，将采样颜色混合在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;//根据混合系数混合
p.Albedo=xDiff*blendWeights.x+yDiff*blendWeights.y+zDiff*blendWeights.z;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多相关内容&lt;a href=&#34;https://www.bilibili.com/video/BV1AM4y1Y78D/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6cef69f555ee1eb889d44945f2a3a38b&#34;&gt;戳此&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;渲染扭曲问题&#34;&gt;&lt;a href=&#34;#渲染扭曲问题&#34; class=&#34;headerlink&#34; title=&#34;渲染扭曲问题&#34;&gt;&lt;/a&gt;渲染扭曲问题&lt;/h4&gt;&lt;p&gt;打印uv坐标：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            float4 frag(v2f i) : SV_Target &amp;#123;
                float4 col=tex2D(_MainTex,i.uv);
                return float4(i.uv,0.0,0.0);
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若uv存在不连续的情况，则会导致贴图采样时引起纹理图像的失真问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;👉️为什么会有uv不连续的现象？&lt;/strong&gt;&lt;br&gt;光栅化过程产生。光栅化时根据三角面的进行，每个三角按照每个三角面进行一个插值。而对于模型而言，其三角网排列就会造成一定程度上的问题。&lt;br&gt;解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uv展开并缩放到0~1之间&lt;/li&gt;
&lt;li&gt;模型加面&lt;/li&gt;
&lt;li&gt;手动在片元shader中重新计算uv&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;PART4-透明度测试-Alpha-test&#34;&gt;&lt;a href=&#34;#PART4-透明度测试-Alpha-test&#34; class=&#34;headerlink&#34; title=&#34;PART4 透明度测试 Alpha-test&#34;&gt;&lt;/a&gt;PART4 透明度测试 Alpha-test&lt;/h3&gt;&lt;p&gt;参考链接&lt;a href=&#34;https://docs.unity3d.com/cn/2020.2/Manual/SL-AlphaTest.html&#34;&gt;1️⃣&lt;/a&gt;&lt;a href=&#34;https://blog.csdn.net/qq_34697930/article/details/136530909&#34;&gt;2️⃣&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;输出合并&#34;&gt;&lt;a href=&#34;#输出合并&#34; class=&#34;headerlink&#34; title=&#34;输出合并&#34;&gt;&lt;/a&gt;输出合并&lt;/h4&gt;&lt;p&gt;对于&lt;strong&gt;输出合并&lt;/strong&gt;阶段，可以细分为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;【片元数据】Color,Depth
    ↓
【Alpha测试】
    ↓
【模板测试】Stencil Test
    ↓
【深度测试】Depth test
    ↓
【混合】Blending
    ↓
【帧缓冲区】Color,Depth,Stencil
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;Alpha-test&#34;&gt;&lt;a href=&#34;#Alpha-test&#34; class=&#34;headerlink&#34; title=&#34;Alpha-test&#34;&gt;&lt;/a&gt;Alpha-test&lt;/h4&gt;&lt;p&gt;**Alpha 测试是拒绝将像素写入屏幕的最后机会。**在计算出最终输出颜色之后，颜色可选择性地将其 Alpha 值与固定值进行比较。如果测试失败，则不会将像素写入显示屏。&lt;/p&gt;
&lt;p&gt;当下在Shader中，很少会直接用alpha test这个指令。一般用的是更好用、更可控的指令：&lt;code&gt;clip&lt;/code&gt;“裁剪”。&lt;/p&gt;
&lt;p&gt;如果clip()括号中的值&amp;lt;0，整个模型将不显示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模型的一部分被裁剪掉&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            float4 frag(v2f i) : SV_Target &amp;#123;
                float4 gradient=tex2D(_MainTex,i.uv);
                clip(gradient-0.1);
                return gradient.xxx;
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设置一个值实现动态控制&lt;br&gt;好神奇😂我这里模型用的球，Cutout调到0.5变成吃豆人了&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
         _MainTex(&amp;quot;MainTex&amp;quot;,2D)=&amp;quot;black&amp;quot;&amp;#123;&amp;#125;
         _Cutout(&amp;quot;Cutout&amp;quot;,Range(-0.1,1.1))=0.0
        [Enum(UnityEngine.Rendering.CullMode)]_CullMode(&amp;quot;CullMode&amp;quot;,float)=2
    &amp;#125;
    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            half4 frag(v2f i) : SV_Target &amp;#123;
                half gradient=tex2D(_MainTex,i.uv).r;
                clip(gradient-_Cutout);
                return gradient.xxxx;
                //gradient.xxxx等价于float4(gradient,gradient,gradient,gradient);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;对UV进行动画处理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;                half gradient=tex2D(_MainTex,i.uv+_Time.y).r;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;对UV进行动画速度的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
        _Speed(&amp;quot;Speed&amp;quot;,Vector)=(1,1,0,0)
    &amp;#125;
    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            float4 _Speed;
            half4 frag(v2f i) : SV_Target &amp;#123;
                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;noise贴图控制&lt;br&gt;适当的模型+贴图可以实现波形扩散效果&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
         _NoiseTex(&amp;quot;Noise Tex&amp;quot;,2D)=&amp;quot;white&amp;quot;&amp;#123;&amp;#125;
         //_MainColor(&amp;quot;MainColor&amp;quot;,Color)=(1,1,1,1)
    &amp;#125;
    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            float4 _NoiseTex_ST;
            //float4 _MainColor;
            half4 frag(v2f i) : SV_Target &amp;#123;
                half gradient=tex2D(_MainTex,i.uv+_Time.y*_Speed.xy).r;
                half noise=tex2D(_NoiseTex,i.uv+_Time.y*_Speed.zw).r;
                clip(gradient-noise-_Cutout);
                return noise.xxxx;
                //return _MainColor;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;综上&lt;/strong&gt; alpha-test可以用来做溶解相关的效果。&lt;/p&gt;
&lt;h3 id=&#34;PART5-半透明混合-Blending&#34;&gt;&lt;a href=&#34;#PART5-半透明混合-Blending&#34; class=&#34;headerlink&#34; title=&#34;PART5 半透明混合 Blending&#34;&gt;&lt;/a&gt;PART5 半透明混合 Blending&lt;/h3&gt;&lt;p&gt;参考链接&lt;a href=&#34;https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/03%20Blending/&#34;&gt;1️⃣&lt;/a&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_34505326/article/details/112181270&#34;&gt;2️⃣&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现半透明混合&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
         _MainColor(&amp;quot;MainColor&amp;quot;,Color)=(1,1,1,1)
    &amp;#125;saturate
    SubShader
    &amp;#123;
        Blend SrcAlpha OneMinusSrcAlpha//注意此句在CGPROGRAM之前
        float4 _MainColor;
        Pass
        &amp;#123;
            half4 frag(v2f i) : SV_Target &amp;#123;
                half4 col=tex2D(_MainTex,i.uv)*_MainColor;
                return col;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;关闭ZWrite深度写入&lt;br&gt;半透明混合的使用要注意排序问题：&lt;code&gt;ZWrite Off&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    SubShader
    &amp;#123;
        Pass&amp;#123;
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;渲染队列问题&lt;br&gt;先前我们的材质球的Render Queue为2000，处于不透明的渲染队列中。使用半透明效果必须记得使用&lt;code&gt;Tags&amp;#123;&amp;quot;Queue&amp;quot;=&amp;quot;Transparent&amp;quot;&amp;#125;&lt;/code&gt;+关掉&lt;code&gt;ZWrite&lt;/code&gt;（部分情况下ZWrite需要开启）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    SubShader
    &amp;#123;
        Tags&amp;#123;&amp;quot;Queue&amp;quot;=&amp;quot;Transparent&amp;quot;&amp;#125;
        Pass&amp;#123;
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;贴图半透效果&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当前贴图无alpha通道，所以只能用其灰度值来做一个半透效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            half4 frag(v2f i) : SV_Target &amp;#123;
                half3 col=_MainColor.xyz;
                half alpha=tex2D(_MainTex,i.uv).r*_MainColor.a;
                return float4(col,alpha);
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;做出来的球像透明泡泡🤗好好看~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加显示强度&lt;blockquote&gt;
&lt;p&gt;此处要确保alpha值在0~1的范围内，否则开HDR的时候就很容易出问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
         _Emiss(&amp;quot;Emiss&amp;quot;,Float)=1.0
    &amp;#125;
    SubShader
    &amp;#123;
        float _Emiss;
        Pass
        &amp;#123;
            half4 frag(v2f i) : SV_Target &amp;#123;
                half3 col=_MainColor.xyz*_Emiss;

                half alpha=saturate(tex2D(_MainTex,i.uv).r*_MainColor.a*_Emiss);
                return float4(col,alpha);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;其他混合模式&lt;br&gt;常用的柔和叠加模式：&lt;code&gt;Blend SrcAlpha One&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;PART6-边缘光&#34;&gt;&lt;a href=&#34;#PART6-边缘光&#34; class=&#34;headerlink&#34; title=&#34;PART6 边缘光&#34;&gt;&lt;/a&gt;PART6 边缘光&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;得到normal_world&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            struct appdata &amp;#123;
                float3 normal : NORMAL;
            &amp;#125;;
            struct v2f &amp;#123;
                float3 normal_world:TEXCOORD1;
            &amp;#125;;
            v2f vert(appdata v) &amp;#123;
                v2f o;
                o.pos=UnityObjectToClipPos(v.vertex);
                o.normal_world=normalize(mul(float4(v.normal,0.0),unity_WorldToObject).xyz);
                //
                o.uv=v.uv*_MainTex_ST.xy+_MainTex_ST.zw;
                return o;
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;得到view_world&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            struct v2f &amp;#123;
                float3 view_world:TEXCOORD2;
            &amp;#125;;
            v2f vert(appdata v) &amp;#123;
                float3 pos_world=mul(unity_ObjectToWorld,v.vertex).xyz;
                o.view_world=normalize(_WorldSpaceCameraPos.xyz-pos_world);
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在片元Shader中把数据承接过来&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dot(a,b)&lt;/code&gt;：a向量与b向量进行点乘。&lt;br&gt;两个向量越重合就越接近1；180°为-1。[-1,1]👉️dot结果在[-1,1]&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            half4 frag(v2f i) : SV_Target &amp;#123;
                float3 normal_world=normalize(i.normal_world);
                //光栅化的过程会导致向量的长度变化
                float3 view_world=normalize(i.view_world);
                float NdoV=saturate(dot(normal_world,view_world));
                float rim=1.0-NdoV;
                return NdoV.xxxx;
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;得到边缘光效果&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;（来自弹幕佬的解释）边缘处的法线和视角方向接近垂直，dot&amp;#x3D;0,1-dot进行取反，边缘就显示出颜色，其他部分就较为透明。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            half4 frag(v2f i) : SV_Target &amp;#123;
                ...
                float rim=1.0-NdoV;
                return rim.xxxx;
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;边缘光改色&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;也可以用alpha通道调：&lt;code&gt;float alpha=saturate((1.0-NdoV)*_Emiss);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;            half4 frag(v2f i) : SV_Target &amp;#123;
                float3 col=_MainColor.xyz*_Emiss;//乘倍增系数，Inspector可调
                ...
                return float4(col,alpha);
            &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;边缘光对比度调节&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    Properties
    &amp;#123;
        _RimPower(&amp;quot;_RimPower&amp;quot;,Float)=1.0
    &amp;#125;
    SubShader
    &amp;#123;
        Pass
        &amp;#123;
            float _RimPower;
            half4 frag(v2f i) : SV_Target &amp;#123;
               float NdoV=pow(saturate(dot(normal_world,view_world)),RimPower);
               float fresnel=pow((1.0-NdoV),_RimPower);
               float alpha=saturate(fresnel*_Emiss);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;模型透过问题：预先写深度&lt;br&gt;经过上面的步骤，模型能够看到内部的透过结构。如何避免这种现象？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;☝「打开ZWrite」&lt;code&gt;ZWrite On&lt;/code&gt;。此时效果其实不算特别完美&lt;/p&gt;
&lt;p&gt;✌「再加一个&amp;#96;Pass」预写一遍深度，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;    SubShader
    &amp;#123;
        Tags&amp;#123;&amp;quot;Queue&amp;quot;=&amp;quot;Transparent&amp;quot;&amp;#125;
        Pass
        &amp;#123;
            Cull Of
            ZWrite On
            ColorMask 0
            CGPROGRAM
            float4 _Color;
            #pragma vertex vert
            #pragma fragment frag
            float4 vert(float4 veryexPos:POSITION):SV_POSITION
            &amp;#123;
                return UnityObjectToClipPos(vertexPos);
            &amp;#125;
            float4 frag(void):COLOR
            &amp;#123;
                return _Color;
            &amp;#125;
            ENDCG
        &amp;#125;
        Pass
        &amp;#123;
            ...
        &amp;#125;
    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;把最靠前的三角形的片元的深度预先&lt;code&gt;ZWrite On&lt;/code&gt;写好&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Color Mask&lt;/code&gt;的操作：只写深度，不写任何的颜色信息&lt;/li&gt;
&lt;li&gt;到了第二遍pass绘制的时候，这些片元就通过深度测试，默认把背后的像素剔除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;👉️ASE中有对应的功能，此处仅为简单演示。&lt;/p&gt;
&lt;p&gt;🤯🤯🤯断断续续一个多星期终于把这一小时的视频啃完辣！！！休息休息继续战斗！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;a href=&#34;#&#34; class=&#34;headerlink&#34; title=&#34;&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h1 id=&#34;其他参考链接&#34;&gt;&lt;a href=&#34;#其他参考链接&#34; class=&#34;headerlink&#34; title=&#34;其他参考链接&#34;&gt;&lt;/a&gt;其他参考链接&lt;/h1&gt;&lt;p&gt;反射探针：&lt;br&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/438022045&#34;&gt;https://zhuanlan.zhihu.com/p/438022045&lt;/a&gt;&lt;br&gt;三大Shader编程语言：&lt;br&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_56516170/article/details/135266277&#34;&gt;https://blog.csdn.net/weixin_56516170/article/details/135266277&lt;/a&gt;&lt;br&gt;《Shader入门精要》源代码:&lt;br&gt;&lt;a href=&#34;https://github.com/candycat1992/Unity_Shaders_Book&#34;&gt;https://github.com/candycat1992/Unity_Shaders_Book&lt;/a&gt;&lt;br&gt;法线贴图：&lt;br&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_49427945/article/details/136458398&#34;&gt;https://blog.csdn.net/weixin_49427945/article/details/136458398&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html&#34;&gt;https://docs.unity3d.com/cn/2021.1/Manual/StandardShaderMaterialParameterNormalMap.html&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
